%!PS
%
% Barcode Writer in Pure PostScript
% https://bwipp.terryburton.co.uk
%
% Copyright (c) 2004-2026 Terry Burton
%
% Resource timing utility using the hooks framework.
%
% Usage:
%
%   gs -q -dNOSAFER -dNOPAUSE -dBATCH -sDEVICE=nullpage \
%      -I build/resource/Resource -f contrib/development/resource_timer.ps -c '
%      10 10 moveto (Hello World) (version=40) /qrcode /uk.co.terryburton.bwipp findresource exec
%      resource_timer_report
%   '

%
% Storage dict for timing data (in global VM for hook access)
%
currentglobal true setglobal
userdict /resource_timer_ctx 32 dict put
resource_timer_ctx begin

%
% Per-resource timing storage:
%
/timing_data 64 dict def     % resource_name -> { label -> << /start N /end N >> }
/timing_order 64 dict def    % resource_name -> [labels in order]
/resource_order [] def       % [resource names in order of first appearance]

%
% Helper: Split a string by dots, returning array of components
%
/split_by_dot {  % (a.b.c) -> [(a) (b) (c)]
    mark exch
    {  % loop
        dup length 0 eq { pop exit } if
        (.) search {
            % Stack: (post) (.) (pre)
            3 1 roll pop  % Stack: (pre) (post) - pre accumulated, post continues
        } {
            % (remaining) - no more dots, final component on stack
            exit
        } ifelse
    } loop
    counttomark array astore exch pop
} bind def

%
% Helper: Build all ancestor paths for a label
% (a.b.c) -> [(a) (a.b) (a.b.c)]
%
/build_ancestors {  % (a.b.c) -> [(a) (a.b) (a.b.c)]
    //split_by_dot exec  % [(a) (b) (c)]
    mark                 % [(a) (b) (c)] mark
    ()                   % [(a) (b) (c)] mark () - empty prefix
    3 -1 roll            % mark () [(a) (b) (c)]
    {
        % Stack: mark [ancestors...] (prefix) (component)
        exch dup length 0 eq {
            % First component: prefix is empty, use component as-is
            pop dup  % mark (component) (component)
        } {
            % Build: prefix + "." + component
            % Stack: mark [ancestors...] (component) (prefix)
            1 index length 1 add 1 index length add string  % new string sized for prefix.component
            % Stack: [anc...] (component) (prefix) (newstr): idx 0=newstr 1=prefix 2=component
            dup 0 3 index putinterval                       % copy prefix at pos 0
            % After dup 0: idx 0=0 1=newstr 2=newstr 3=prefix 4=component -> 3 index = prefix
            dup 2 index length (.) putinterval              % add dot at prefix.length
            % After dup: idx 0=newstr 1=newstr 2=prefix -> 2 index = prefix
            dup 2 index length 1 add 4 index putinterval    % add component at prefix.length+1
            % After dup len add: idx 0=int 1=newstr 2=newstr 3=prefix 4=component -> 4 index = component
            % Stack: [anc...] (component) (prefix) (newstr)
            exch pop exch pop                               % [anc...] (newstr)
            dup  % duplicate as new prefix
        } ifelse
    } forall
    pop  % Remove final prefix
    counttomark array astore exch pop
} bind def

%
% Helper: Get depth of a path (number of dots + 1)
%
/path_depth {  % (a.b.c) -> 3
    0 exch { (.) 0 get eq { 1 add } if } forall 1 add
} bind def

%
% Helper: Append item to an array
%
/array_append {
    1 index length 1 add array
    dup 0 4 index putinterval
    dup 3 index length 3 index put
    3 1 roll pop pop
} bind def

%
% Reset timing data for new run
%
/reset_timing_data {
    currentglobal      % Save current state
    true setglobal     % Switch to global
    //resource_timer_ctx /timing_data 64 dict put
    //resource_timer_ctx /timing_order 64 dict put
    //resource_timer_ctx /resource_order [] put
    setglobal          % Restore saved state
} bind def

%
% Before hook: record start time for pending measurement
%
/timing_before {
    10 dict begin
    % Stack: (label) /resname
    /resname exch dup length string cvs def
    /label exch def
    /savedglobal currentglobal def
    true setglobal

    % Ensure resource has entries in timing_data and timing_order
    //resource_timer_ctx /timing_data get resname known not {
        //resource_timer_ctx /timing_data get resname 64 dict put
        //resource_timer_ctx /timing_order get resname [] put
        //resource_timer_ctx /resource_order get resname //array_append exec
        //resource_timer_ctx exch /resource_order exch put
    } if

    % Get this resource's dicts
    /res_tdata //resource_timer_ctx /timing_data get resname get def
    /res_torder //resource_timer_ctx /timing_order get resname get def

    /now realtime def
    res_tdata label known not {
        % First time seeing this label: initialize stats
        res_tdata label <<
            /pending_start now
            /first_start now
            /last_end now
            /count 0
            /sum 0
            /min 999999999
            /max 0
        >> put
        //resource_timer_ctx /timing_order get resname res_torder label //array_append exec put
    } {
        % Already seen - record pending start for this invocation
        res_tdata label get /pending_start now put
    } ifelse

    savedglobal setglobal
    end
} bind def

%
% After hook: compute duration and update stats
%
/timing_after {
    10 dict begin
    % Stack: (label) /resname
    /resname exch dup length string cvs def
    /label exch def

    % Get this resource's timing_data dict if it exists
    //resource_timer_ctx /timing_data get resname known {
        /res_tdata //resource_timer_ctx /timing_data get resname get def
        res_tdata label known {
            /entry res_tdata label get def
            /now realtime def
            /duration now entry /pending_start get sub def

            % Update stats
            entry /last_end now put
            entry /count entry /count get 1 add put
            entry /sum entry /sum get duration add put
            duration entry /min get lt { entry /min duration put } if
            duration entry /max get gt { entry /max duration put } if
        } if
    } if
    end
} bind def

%
% Compute hierarchical timings for a specific resource
% (resname) compute_hierarchical_timings -> dict
%
/compute_hierarchical_timings {
    /resname exch def
    //resource_timer_ctx /timing_data get resname get /tdata exch def
    //resource_timer_ctx /timing_order get resname get /torder exch def

    % Build set of all paths (leaves and ancestors)
    64 dict /all_paths exch def
    torder {
        //build_ancestors exec {
            all_paths exch true put
        } forall
    } forall

    % Create result dict with leaf times and computed parent times
    64 dict /result exch def

    % Copy all leaf timings (with full stats)
    torder {
        /lbl exch def
        tdata lbl get /entry exch def
        result lbl <<
            /first_start entry /first_start get
            /last_end entry /last_end get
            /count entry /count get
            /sum entry /sum get
            /min entry /min get
            /max entry /max get
        >> put
    } forall

    % Compute synthetic parent times from children
    all_paths {
        pop  % value (always true)
        /path exch def

        % Only process if this is a synthetic parent (not in timing_data)
        tdata path known not {
            /min_start null def
            /max_end null def

            torder {
                /child exch def
                % Check if child is descendant of path (starts with path.)
                child length path length gt {
                    child 0 path length getinterval path eq {
                        child path length get (.) 0 get eq {
                            % child is descendant of path
                            tdata child get
                            dup /first_start get  % entry start_val
                            min_start null eq {
                                /min_start exch def
                            } {
                                dup min_start lt { /min_start exch def } { pop } ifelse
                            } ifelse
                            % Stack: entry
                            /last_end get  % end_val
                            max_end null eq {
                                /max_end exch def
                            } {
                                dup max_end gt { /max_end exch def } { pop } ifelse
                            } ifelse
                        } if
                    } if
                } if
            } forall

            min_start null ne {
                result path <<
                    /first_start min_start
                    /last_end max_end
                    /count 0  % Synthetic parent - no direct count
                    /sum 0
                    /min 0
                    /max 0
                >> put
            } if
        } if
    } forall

    result
} bind def

%
% Build ordered list including synthetic parents (parents before children)
% (resname) build_ordered_paths -> [paths...]
%
/build_ordered_paths {
    /resname exch def
    //resource_timer_ctx /timing_order get resname get /torder exch def

    % Output paths in order: for each leaf, emit its ancestors first (if not yet emitted)
    64 dict /emitted exch def
    mark
    torder {
        //build_ancestors exec {
            dup emitted exch known not {
                dup emitted exch true put
            } { pop } ifelse
        } forall
    } forall
    counttomark array astore exch pop
} bind def

%
% Helper: print right-aligned integer in field of given width
%
/print_int_field {  % int width -> -
    exch 10 string cvs  % width (str)
    dup length          % width (str) len
    3 -1 roll exch sub  % (str) padding
    dup 0 gt { { ( ) print } repeat } { pop } ifelse
    print
} bind def

%
% Format and print timing report for a single resource
% (resname) print_resource_report
%
/print_resource_report {
    /resname exch def
    resname //compute_hierarchical_timings exec /htimings exch def
    resname //build_ordered_paths exec /ordered exch def

    % Check if any entry has count > 1
    /has_multi false def
    ordered {
        htimings exch get /count get 1 gt { /has_multi true def } if
    } forall

    % Print header for this resource
    () =
    (Timing report for ) print resname print (:) =
    () =
    % Header: 36 + 10 + 2 + 10 + 2 + 7 + 2 + 7 + 2 + 9 + 2 + 10 = 99 chars
    (Process                             ) print
    (     Start) print (  ) print (       End) print
    (  ) print (    Min) print (  ) print (    Max) print
    (  ) print (  Mean\(N\)) print (  ) print (Total \(ms\)) =
    (---------------------------------------------------------------------------------------------------) =

    ordered {
        /path exch def
        htimings path known {
            htimings path get /entry exch def

            % Build indentation based on depth
            path //path_depth exec 1 sub 2 mul string
            dup length 0 gt { dup 0 1 2 index length 1 sub { 2 index exch 32 put } for } if
            /indent exch def

            % Build padded path string (36 chars total)
            36 string /pathstr exch def
            0 1 35 { pathstr exch 32 put } for  % Fill with spaces
            pathstr 0 indent putinterval
            /maxlen 36 indent length sub def
            path length maxlen gt { /plen maxlen def } { /plen path length def } ifelse
            pathstr indent length path 0 plen getinterval putinterval

            pathstr print
            entry /first_start get 10 //print_int_field exec
            (  ) print
            entry /last_end get 10 //print_int_field exec

            entry /count get /cnt exch def
            cnt 1 gt {
                % Multiple invocations: show min, max, mean(N), total
                /sum entry /sum get def
                (  ) print entry /min get 7 //print_int_field exec
                (  ) print entry /max get 7 //print_int_field exec
                % Format mean(N) right-aligned in 9 chars
                /meanstr sum cnt div cvi 10 string cvs def
                /cntstr cnt 10 string cvs def
                /meanfull meanstr length 1 add cntstr length add 1 add string def
                meanfull 0 meanstr putinterval
                meanfull meanstr length (\() putinterval
                meanfull meanstr length 1 add cntstr putinterval
                meanfull meanfull length 1 sub (\)) putinterval
                (  ) print 9 meanfull length sub { ( ) print } repeat meanfull print
                (  ) print sum 10 //print_int_field exec
            } {
                % Single invocation or synthetic parent: show only total
                % Skip: gap(2)+Min(7)+gap(2)+Max(7)+gap(2)+Mean(9)+gap(2) = 31, then Total(10)
                /total cnt 0 gt { entry /sum get } { entry /last_end get entry /first_start get sub } ifelse def
                (                               ) print
                total 10 //print_int_field exec
            } ifelse
            () =
        } if
    } forall
} bind def

%
% Format and print timing report for all resources
%
/print_timing_report {
    //resource_timer_ctx /resource_order get {
        //print_resource_report exec
    } forall
    () =
    (Note: Capture resolution limited to 1ms) =
} bind def

%
% Print timing report and reset for next run
%
/resource_timer_report {
    //print_timing_report exec
    //reset_timing_data exec
} bind def

%
% Initialize hooks on script load
%
//reset_timing_data exec
currentglobal         % Save current state
true setglobal        % Switch to global
userdict /uk.co.terryburton.bwipp.global_ctx <<
    /enabledebug true
    /enabledontdraw true
    /hooks <<
        /before //timing_before
        /after //timing_after
    >>
>> put
setglobal             % Restore saved state

%
% Export main procedure to userdict
%
userdict /resource_timer_report //resource_timer_report put

end
setglobal  % Restore previous allocation mode
