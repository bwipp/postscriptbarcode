%!PS-Adobe-2.0
%%Creator: dvips(k) 5.92b Copyright 2002 Radical Eye Software
%%Title: barcodewriter.dvi
%%Pages: 24
%%PageOrder: Ascend
%%BoundingBox: 0 0 596 842
%%DocumentFonts: Times-Roman Symbol CMMI10 Times-Bold Courier
%%+ Times-Italic CMSY10
%%EndComments
%DVIPSWebPage: (www.radicaleye.com)
%DVIPSCommandLine: /usr/bin/dvips -q barcodewriter.dvi -o
%+ postscriptbarcode/docs/barcodewriter.ps
%DVIPSParameters: dpi=600, compressed
%DVIPSSource:  TeX output 2006.09.26:1409
%%BeginProcSet: texc.pro
%!
/TeXDict 300 dict def TeXDict begin/N{def}def/B{bind def}N/S{exch}N/X{S
N}B/A{dup}B/TR{translate}N/isls false N/vsize 11 72 mul N/hsize 8.5 72
mul N/landplus90{false}def/@rigin{isls{[0 landplus90{1 -1}{-1 1}ifelse 0
0 0]concat}if 72 Resolution div 72 VResolution div neg scale isls{
landplus90{VResolution 72 div vsize mul 0 exch}{Resolution -72 div hsize
mul 0}ifelse TR}if Resolution VResolution vsize -72 div 1 add mul TR[
matrix currentmatrix{A A round sub abs 0.00001 lt{round}if}forall round
exch round exch]setmatrix}N/@landscape{/isls true N}B/@manualfeed{
statusdict/manualfeed true put}B/@copies{/#copies X}B/FMat[1 0 0 -1 0 0]
N/FBB[0 0 0 0]N/nn 0 N/IEn 0 N/ctr 0 N/df-tail{/nn 8 dict N nn begin
/FontType 3 N/FontMatrix fntrx N/FontBBox FBB N string/base X array
/BitMaps X/BuildChar{CharBuilder}N/Encoding IEn N end A{/foo setfont}2
array copy cvx N load 0 nn put/ctr 0 N[}B/sf 0 N/df{/sf 1 N/fntrx FMat N
df-tail}B/dfs{div/sf X/fntrx[sf 0 0 sf neg 0 0]N df-tail}B/E{pop nn A
definefont setfont}B/Cw{Cd A length 5 sub get}B/Ch{Cd A length 4 sub get
}B/Cx{128 Cd A length 3 sub get sub}B/Cy{Cd A length 2 sub get 127 sub}
B/Cdx{Cd A length 1 sub get}B/Ci{Cd A type/stringtype ne{ctr get/ctr ctr
1 add N}if}B/id 0 N/rw 0 N/rc 0 N/gp 0 N/cp 0 N/G 0 N/CharBuilder{save 3
1 roll S A/base get 2 index get S/BitMaps get S get/Cd X pop/ctr 0 N Cdx
0 Cx Cy Ch sub Cx Cw add Cy setcachedevice Cw Ch true[1 0 0 -1 -.1 Cx
sub Cy .1 sub]/id Ci N/rw Cw 7 add 8 idiv string N/rc 0 N/gp 0 N/cp 0 N{
rc 0 ne{rc 1 sub/rc X rw}{G}ifelse}imagemask restore}B/G{{id gp get/gp
gp 1 add N A 18 mod S 18 idiv pl S get exec}loop}B/adv{cp add/cp X}B
/chg{rw cp id gp 4 index getinterval putinterval A gp add/gp X adv}B/nd{
/cp 0 N rw exit}B/lsh{rw cp 2 copy get A 0 eq{pop 1}{A 255 eq{pop 254}{
A A add 255 and S 1 and or}ifelse}ifelse put 1 adv}B/rsh{rw cp 2 copy
get A 0 eq{pop 128}{A 255 eq{pop 127}{A 2 idiv S 128 and or}ifelse}
ifelse put 1 adv}B/clr{rw cp 2 index string putinterval adv}B/set{rw cp
fillstr 0 4 index getinterval putinterval adv}B/fillstr 18 string 0 1 17
{2 copy 255 put pop}for N/pl[{adv 1 chg}{adv 1 chg nd}{1 add chg}{1 add
chg nd}{adv lsh}{adv lsh nd}{adv rsh}{adv rsh nd}{1 add adv}{/rc X nd}{
1 add set}{1 add clr}{adv 2 chg}{adv 2 chg nd}{pop nd}]A{bind pop}
forall N/D{/cc X A type/stringtype ne{]}if nn/base get cc ctr put nn
/BitMaps get S ctr S sf 1 ne{A A length 1 sub A 2 index S get sf div put
}if put/ctr ctr 1 add N}B/I{cc 1 add D}B/bop{userdict/bop-hook known{
bop-hook}if/SI save N @rigin 0 0 moveto/V matrix currentmatrix A 1 get A
mul exch 0 get A mul add .99 lt{/QV}{/RV}ifelse load def pop pop}N/eop{
SI restore userdict/eop-hook known{eop-hook}if showpage}N/@start{
userdict/start-hook known{start-hook}if pop/VResolution X/Resolution X
1000 div/DVImag X/IEn 256 array N 2 string 0 1 255{IEn S A 360 add 36 4
index cvrs cvn put}for pop 65781.76 div/vsize X 65781.76 div/hsize X}N
/p{show}N/RMat[1 0 0 -1 0 0]N/BDot 260 string N/Rx 0 N/Ry 0 N/V{}B/RV/v{
/Ry X/Rx X V}B statusdict begin/product where{pop false[(Display)(NeXT)
(LaserWriter 16/600)]{A length product length le{A length product exch 0
exch getinterval eq{pop true exit}if}{pop}ifelse}forall}{false}ifelse
end{{gsave TR -.1 .1 TR 1 1 scale Rx Ry false RMat{BDot}imagemask
grestore}}{{gsave TR -.1 .1 TR Rx Ry scale 1 1 false RMat{BDot}
imagemask grestore}}ifelse B/QV{gsave newpath transform round exch round
exch itransform moveto Rx 0 rlineto 0 Ry neg rlineto Rx neg 0 rlineto
fill grestore}B/a{moveto}B/delta 0 N/tail{A/delta X 0 rmoveto}B/M{S p
delta add tail}B/b{S p tail}B/c{-4 M}B/d{-3 M}B/e{-2 M}B/f{-1 M}B/g{0 M}
B/h{1 M}B/i{2 M}B/j{3 M}B/k{4 M}B/w{0 rmoveto}B/l{p -4 w}B/m{p -3 w}B/n{
p -2 w}B/o{p -1 w}B/q{p 1 w}B/r{p 2 w}B/s{p 3 w}B/t{p 4 w}B/x{0 S
rmoveto}B/y{3 2 roll p a}B/bos{/SS save N}B/eos{SS restore}B end

%%EndProcSet
%%BeginProcSet: pstricks.pro
%!
% PostScript prologue for pstricks.tex.
% Version 97 patch 3, 98/06/01
% For distribution, see pstricks.tex.
%
/tx@Dict 200 dict def tx@Dict begin
/ADict 25 dict def
/CM { matrix currentmatrix } bind def
/SLW /setlinewidth load def
/CLW /currentlinewidth load def
/CP /currentpoint load def
/ED { exch def } bind def
/L /lineto load def
/T /translate load def
/TMatrix { } def
/RAngle { 0 } def
/Atan { /atan load stopped { pop pop 0 } if } def
/Div { dup 0 eq { pop } { div } ifelse } def
/NET { neg exch neg exch T } def
/Pyth { dup mul exch dup mul add sqrt } def
/PtoC { 2 copy cos mul 3 1 roll sin mul } def
/PathLength@ { /z z y y1 sub x x1 sub Pyth add def /y1 y def /x1 x def }
def
/PathLength { flattenpath /z 0 def { /y1 ED /x1 ED /y2 y1 def /x2 x1 def
} { /y ED /x ED PathLength@ } {} { /y y2 def /x x2 def PathLength@ }
/pathforall load stopped { pop pop pop pop } if z } def
/STP { .996264 dup scale } def
/STV { SDict begin normalscale end STP  } def
/DashLine { dup 0 gt { /a .5 def PathLength exch div } { pop /a 1 def
PathLength } ifelse /b ED /x ED /y ED /z y x add def b a .5 sub 2 mul y
mul sub z Div round z mul a .5 sub 2 mul y mul add b exch Div dup y mul
/y ED x mul /x ED x 0 gt y 0 gt and { [ y x ] 1 a sub y mul } { [ 1 0 ]
0 } ifelse setdash stroke } def
/DotLine { /b PathLength def /a ED /z ED /y CLW def /z y z add def a 0 gt
{ /b b a div def } { a 0 eq { /b b y sub def } { a -3 eq { /b b y add
def } if } ifelse } ifelse [ 0 b b z Div round Div dup 0 le { pop 1 } if
] a 0 gt { 0 } { y 2 div a -2 gt { neg } if } ifelse setdash 1
setlinecap stroke } def
/LineFill { gsave abs CLW add /a ED a 0 dtransform round exch round exch
2 copy idtransform exch Atan rotate idtransform pop /a ED .25 .25
% DG/SR modification begin - Dec. 12, 1997 - Patch 2
%itransform translate pathbbox /y2 ED a Div ceiling cvi /x2 ED /y1 ED a
itransform pathbbox /y2 ED a Div ceiling cvi /x2 ED /y1 ED a
% DG/SR modification end
Div cvi /x1 ED /y2 y2 y1 sub def clip newpath 2 setlinecap systemdict
/setstrokeadjust known { true setstrokeadjust } if x2 x1 sub 1 add { x1
% DG/SR modification begin - Jun.  1, 1998 - Patch 3 (from Michael Vulis)
% a mul y1 moveto 0 y2 rlineto stroke /x1 x1 1 add def } repeat grestore }
% def
a mul y1 moveto 0 y2 rlineto stroke /x1 x1 1 add def } repeat grestore
pop pop } def
% DG/SR modification end
/BeginArrow { ADict begin /@mtrx CM def gsave 2 copy T 2 index sub neg
exch 3 index sub exch Atan rotate newpath } def
/EndArrow { @mtrx setmatrix CP grestore end } def
/Arrow { CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1
scale } if w neg h moveto 0 0 L w h L w neg a neg rlineto gsave fill
grestore } def
/Tbar { CLW mul add /z ED z -2 div CLW 2 div moveto z 0 rlineto stroke 0
CLW moveto } def
/Bracket { CLW mul add dup CLW sub 2 div /x ED mul CLW add /y ED /z CLW 2
div def x neg y moveto x neg CLW 2 div L x CLW 2 div L x y L stroke 0
CLW moveto } def
/RoundBracket { CLW mul add dup 2 div /x ED mul /y ED /mtrx CM def 0 CLW
2 div T x y mul 0 ne { x y scale } if 1 1 moveto .85 .5 .35 0 0 0
curveto -.35 0 -.85 .5 -1 1 curveto mtrx setmatrix stroke 0 CLW moveto }
def
/SD { 0 360 arc fill } def
/EndDot { { /z DS def } { /z 0 def } ifelse /b ED 0 z DS SD b { 0 z DS
CLW sub SD } if 0 DS z add CLW 4 div sub moveto } def
/Shadow { [ { /moveto load } { /lineto load } { /curveto load } {
/closepath load } /pathforall load stopped { pop pop pop pop CP /moveto
load } if ] cvx newpath 3 1 roll T exec } def
/NArray { aload length 2 div dup dup cvi eq not { exch pop } if /n exch
cvi def } def
/NArray { /f ED counttomark 2 div dup cvi /n ED n eq not { exch pop } if
f { ] aload /Points ED } { n 2 mul 1 add -1 roll pop } ifelse } def
/Line { NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if ArrowA /n n 2 sub
def n { Lineto } repeat CP 4 2 roll ArrowB L pop pop } if } def
/Arcto { /a [ 6 -2 roll ] cvx def a r /arcto load stopped { 5 } { 4 }
ifelse { pop } repeat a } def
/CheckClosed { dup n 2 mul 1 sub index eq 2 index n 2 mul 1 add index eq
and { pop pop /n n 1 sub def } if } def
/Polygon { NArray n 2 eq { 0 0 /n 3 def } if n 3 lt { n { pop pop }
repeat } { n 3 gt { CheckClosed } if n 2 mul -2 roll /y0 ED /x0 ED /y1
ED /x1 ED x1 y1 /x1 x0 x1 add 2 div def /y1 y0 y1 add 2 div def x1 y1
moveto /n n 2 sub def n { Lineto } repeat x1 y1 x0 y0 6 4 roll Lineto
Lineto pop pop closepath } ifelse } def
/Diamond { /mtrx CM def T rotate /h ED /w ED dup 0 eq { pop } { CLW mul
neg /d ED /a w h Atan def /h d a sin Div h add def /w d a cos Div w add
def } ifelse mark w 2 div h 2 div w 0 0 h neg w neg 0 0 h w 2 div h 2
div /ArrowA { moveto } def /ArrowB { } def false Line closepath mtrx
setmatrix } def
% DG modification begin - Jan. 15, 1997
%/Triangle { /mtrx CM def translate rotate /h ED 2 div /w ED dup 0 eq {
%pop } { CLW mul /d ED /h h d w h Atan sin Div sub def /w w d h w Atan 2
%div dup cos exch sin Div mul sub def } ifelse mark 0 d w neg d 0 h w d 0
%d /ArrowA { moveto } def /ArrowB { } def false Line closepath mtrx
%setmatrix } def
/Triangle { /mtrx CM def translate rotate /h ED 2 div /w ED dup
CLW mul /d ED /h h d w h Atan sin Div sub def /w w d h w Atan 2
div dup cos exch sin Div mul sub def mark 0 d w neg d 0 h w d 0
d /ArrowA { moveto } def /ArrowB { } def false Line closepath mtrx
% DG/SR modification begin - Jun.  1, 1998 - Patch 3 (from Michael Vulis)
% setmatrix } def
setmatrix pop } def
% DG/SR modification end
/CCA { /y ED /x ED 2 copy y sub /dy1 ED x sub /dx1 ED /l1 dx1 dy1 Pyth
def } def
/CCA { /y ED /x ED 2 copy y sub /dy1 ED x sub /dx1 ED /l1 dx1 dy1 Pyth
def } def
/CC { /l0 l1 def /x1 x dx sub def /y1 y dy sub def /dx0 dx1 def /dy0 dy1
def CCA /dx dx0 l1 c exp mul dx1 l0 c exp mul add def /dy dy0 l1 c exp
mul dy1 l0 c exp mul add def /m dx0 dy0 Atan dx1 dy1 Atan sub 2 div cos
abs b exp a mul dx dy Pyth Div 2 div def /x2 x l0 dx mul m mul sub def
/y2 y l0 dy mul m mul sub def /dx l1 dx mul m mul neg def /dy l1 dy mul
m mul neg def } def
/IC { /c c 1 add def c 0 lt { /c 0 def } { c 3 gt { /c 3 def } if }
ifelse /a a 2 mul 3 div 45 cos b exp div def CCA /dx 0 def /dy 0 def }
def
/BOC { IC CC x2 y2 x1 y1 ArrowA CP 4 2 roll x y curveto } def
/NC { CC x1 y1 x2 y2 x y curveto } def
/EOC { x dx sub y dy sub 4 2 roll ArrowB 2 copy curveto } def
/BAC { IC CC x y moveto CC x1 y1 CP ArrowA } def
/NAC { x2 y2 x y curveto CC x1 y1 } def
/EAC { x2 y2 x y ArrowB curveto pop pop } def
/OpenCurve { NArray n 3 lt { n { pop pop } repeat } { BOC /n n 3 sub def
n { NC } repeat EOC } ifelse } def
/AltCurve { { false NArray n 2 mul 2 roll [ n 2 mul 3 sub 1 roll ] aload
/Points ED n 2 mul -2 roll } { false NArray } ifelse n 4 lt { n { pop
pop } repeat } { BAC /n n 4 sub def n { NAC } repeat EAC } ifelse } def
/ClosedCurve { NArray n 3 lt { n { pop pop } repeat } { n 3 gt {
CheckClosed } if 6 copy n 2 mul 6 add 6 roll IC CC x y moveto n { NC }
repeat closepath pop pop } ifelse } def
/SQ { /r ED r r moveto r r neg L r neg r neg L r neg r L fill } def
/ST { /y ED /x ED x y moveto x neg y L 0 x L fill } def
/SP { /r ED gsave 0 r moveto 4 { 72 rotate 0 r L } repeat fill grestore }
def
/FontDot { DS 2 mul dup matrix scale matrix concatmatrix exch matrix
rotate matrix concatmatrix exch findfont exch makefont setfont } def
/Rect { x1 y1 y2 add 2 div moveto x1 y2 lineto x2 y2 lineto x2 y1 lineto
x1 y1 lineto closepath } def
/OvalFrame { x1 x2 eq y1 y2 eq or { pop pop x1 y1 moveto x2 y2 L } { y1
y2 sub abs x1 x2 sub abs 2 copy gt { exch pop } { pop } ifelse 2 div
exch { dup 3 1 roll mul exch } if 2 copy lt { pop } { exch pop } ifelse
/b ED x1 y1 y2 add 2 div moveto x1 y2 x2 y2 b arcto x2 y2 x2 y1 b arcto
x2 y1 x1 y1 b arcto x1 y1 x1 y2 b arcto 16 { pop } repeat closepath }
ifelse } def
/Frame { CLW mul /a ED 3 -1 roll 2 copy gt { exch } if a sub /y2 ED a add
/y1 ED 2 copy gt { exch } if a sub /x2 ED a add /x1 ED 1 index 0 eq {
pop pop Rect } { OvalFrame } ifelse } def
/BezierNArray { /f ED counttomark 2 div dup cvi /n ED n eq not { exch pop
} if n 1 sub neg 3 mod 3 add 3 mod { 0 0 /n n 1 add def } repeat f { ]
aload /Points ED } { n 2 mul 1 add -1 roll pop } ifelse } def
/OpenBezier { BezierNArray n 1 eq { pop pop } { ArrowA n 4 sub 3 idiv { 6
2 roll 4 2 roll curveto } repeat 6 2 roll 4 2 roll ArrowB curveto }
ifelse } def
/ClosedBezier { BezierNArray n 1 eq { pop pop } { moveto n 1 sub 3 idiv {
6 2 roll 4 2 roll curveto } repeat closepath } ifelse } def
/BezierShowPoints { gsave Points aload length 2 div cvi /n ED moveto n 1
sub { lineto } repeat CLW 2 div SLW [ 4 4 ] 0 setdash stroke grestore }
def
/Parab { /y0 exch def /x0 exch def /y1 exch def /x1 exch def /dx x0 x1
sub 3 div def /dy y0 y1 sub 3 div def x0 dx sub y0 dy add x1 y1 ArrowA
x0 dx add y0 dy add x0 2 mul x1 sub y1 ArrowB curveto /Points [ x1 y1 x0
y0 x0 2 mul x1 sub y1 ] def } def
/Grid { newpath /a 4 string def /b ED /c ED /n ED cvi dup 1 lt { pop 1 }
if /s ED s div dup 0 eq { pop 1 } if /dy ED s div dup 0 eq { pop 1 } if
/dx ED dy div round dy mul /y0 ED dx div round dx mul /x0 ED dy div
round cvi /y2 ED dx div round cvi /x2 ED dy div round cvi /y1 ED dx div
round cvi /x1 ED /h y2 y1 sub 0 gt { 1 } { -1 } ifelse def /w x2 x1 sub
0 gt { 1 } { -1 } ifelse def b 0 gt { /z1 b 4 div CLW 2 div add def
/Helvetica findfont b scalefont setfont /b b .95 mul CLW 2 div add def }
if systemdict /setstrokeadjust known { true setstrokeadjust /t { } def }
{ /t { transform 0.25 sub round 0.25 add exch 0.25 sub round 0.25 add
exch itransform } bind def } ifelse gsave n 0 gt { 1 setlinecap [ 0 dy n
div ] dy n div 2 div setdash } { 2 setlinecap } ifelse /i x1 def /f y1
dy mul n 0 gt { dy n div 2 div h mul sub } if def /g y2 dy mul n 0 gt {
dy n div 2 div h mul add } if def x2 x1 sub w mul 1 add dup 1000 gt {
pop 1000 } if { i dx mul dup y0 moveto b 0 gt { gsave c i a cvs dup
stringwidth pop /z2 ED w 0 gt {z1} {z1 z2 add neg} ifelse h 0 gt {b neg}
{z1} ifelse rmoveto show grestore } if dup t f moveto g t L stroke /i i
w add def } repeat grestore gsave n 0 gt
% DG/SR modification begin - Nov. 7, 1997 - Patch 1
%{ 1 setlinecap [ 0 dx n div ] dy n div 2 div setdash }
{ 1 setlinecap [ 0 dx n div ] dx n div 2 div setdash }
% DG/SR modification end
{ 2 setlinecap } ifelse /i y1 def /f x1 dx mul
n 0 gt { dx n div 2 div w mul sub } if def /g x2 dx mul n 0 gt { dx n
div 2 div w mul add } if def y2 y1 sub h mul 1 add dup 1000 gt { pop
1000 } if { newpath i dy mul dup x0 exch moveto b 0 gt { gsave c i a cvs
dup stringwidth pop /z2 ED w 0 gt {z1 z2 add neg} {z1} ifelse h 0 gt
{z1} {b neg} ifelse rmoveto show grestore } if dup f exch t moveto g
exch t L stroke /i i h add def } repeat grestore } def
/ArcArrow { /d ED /b ED /a ED gsave newpath 0 -1000 moveto clip newpath 0
1 0 0 b grestore c mul /e ED pop pop pop r a e d PtoC y add exch x add
exch r a PtoC y add exch x add exch b pop pop pop pop a e d CLW 8 div c
mul neg d } def
/Ellipse { /mtrx CM def T scale 0 0 1 5 3 roll arc mtrx setmatrix } def
/Rot { CP CP translate 3 -1 roll neg rotate NET  } def
/RotBegin { tx@Dict /TMatrix known not { /TMatrix { } def /RAngle { 0 }
def } if /TMatrix [ TMatrix CM ] cvx def /a ED a Rot /RAngle [ RAngle
dup a add ] cvx def } def
/RotEnd { /TMatrix [ TMatrix setmatrix ] cvx def /RAngle [ RAngle pop ]
cvx def } def
/PutCoor { gsave CP T CM STV exch exec moveto setmatrix CP grestore } def
/PutBegin { /TMatrix [ TMatrix CM ] cvx def CP 4 2 roll T moveto } def
/PutEnd { CP /TMatrix [ TMatrix setmatrix ] cvx def moveto } def
/Uput { /a ED add 2 div /h ED 2 div /w ED /s a sin def /c a cos def /b s
abs c abs 2 copy gt dup /q ED { pop } { exch pop } ifelse def /w1 c b
div w mul def /h1 s b div h mul def q { w1 abs w sub dup c mul abs } {
h1 abs h sub dup s mul abs } ifelse } def
/UUput { /z ED abs /y ED /x ED q { x s div c mul abs y gt } { x c div s
mul abs y gt } ifelse { x x mul y y mul sub z z mul add sqrt z add } { q
{ x s div } { x c div } ifelse abs } ifelse a PtoC h1 add exch w1 add
exch } def
/BeginOL { dup (all) eq exch TheOL eq or { IfVisible not { Visible
/IfVisible true def } if } { IfVisible { Invisible /IfVisible false def
} if } ifelse } def
/InitOL { /OLUnit [ 3000 3000 matrix defaultmatrix dtransform ] cvx def
/Visible { CP OLUnit idtransform T moveto } def /Invisible { CP OLUnit
neg exch neg exch idtransform T moveto } def /BOL { BeginOL } def
/IfVisible true def } def
end
% END pstricks.pro

%%EndProcSet
%%BeginProcSet: pst-dots.pro
%!PS-Adobe-2.0
%%Title: Dot Font for PSTricks
%%Creator: Timothy Van Zandt <tvz@Princeton.EDU>
%%Creation Date: May 7, 1993
%% Version 97 patch 1, 99/12/16
%% Modified by Etienne Riga <etienne.riga@skynet.be> - Dec. 16, 1999
%% to add /Diamond, /SolidDiamond and /BoldDiamond
10 dict dup begin
  /FontType 3 def
  /FontMatrix [ .001 0 0 .001 0 0 ] def
  /FontBBox [ 0 0 0 0 ] def
  /Encoding 256 array def
  0 1 255 { Encoding exch /.notdef put } for
  Encoding
    dup (b) 0 get /Bullet put
    dup (c) 0 get /Circle put
    dup (C) 0 get /BoldCircle put
    dup (u) 0 get /SolidTriangle put
    dup (t) 0 get /Triangle put
    dup (T) 0 get /BoldTriangle put
    dup (r) 0 get /SolidSquare put
    dup (s) 0 get /Square put
    dup (S) 0 get /BoldSquare put
    dup (q) 0 get /SolidPentagon put
    dup (p) 0 get /Pentagon put
    dup (P) 0 get /BoldPentagon put
% DG/SR modification begin - Dec. 16, 1999 - From Etienne Riga
    dup (l) 0 get /SolidDiamond put
    dup (d) 0 get /Diamond put
        (D) 0 get /BoldDiamond put
% DG/SR modification end
  /Metrics 13 dict def
  Metrics begin
    /Bullet        1000   def
    /Circle        1000   def
    /BoldCircle    1000   def
    /SolidTriangle 1344   def
    /Triangle      1344   def
    /BoldTriangle  1344   def
    /SolidSquare    886   def
    /Square         886   def
    /BoldSquare     886   def
    /SolidPentagon 1093.2 def
    /Pentagon      1093.2 def
    /BoldPentagon  1093.2 def
% DG/SR modification begin - Dec. 16, 1999 - From Etienne Riga
    /SolidDiamond  1008   def
    /Diamond       1008   def
    /BoldDiamond   1008   def
% DG/SR modification end
    /.notdef 0 def
  end
  /BBoxes 13 dict def
  BBoxes begin
    /Circle        { -550 -550 550 550 } def
    /BoldCircle    /Circle load def
    /Bullet        /Circle load def
    /Triangle      { -571.5 -330 571.5 660 } def
    /BoldTriangle  /Triangle load def
    /SolidTriangle /Triangle load def
    /Square        { -450 -450 450 450 } def
    /BoldSquare    /Square load def
    /SolidSquare   /Square load def
    /Pentagon      { -546.6 -465 546.6 574.7 } def
    /BoldPentagon  /Pentagon load def
    /SolidPentagon /Pentagon load def
% DG/SR modification begin - Dec. 16, 1999 - From Etienne Riga
    /Diamond       { -428.5 -742.5 428.5 742.5 } def
    /BoldDiamond   /Diamond load def
    /SolidDiamond  /Diamond load def
% DG/SR modification end
    /.notdef { 0 0 0 0 } def
  end
  /CharProcs 20 dict def
  CharProcs begin
    /Adjust {
      2 copy dtransform floor .5 add exch floor .5 add exch idtransform
      3 -1 roll div 3 1 roll exch div exch scale
    } def
    /CirclePath    { 0 0 500 0 360 arc closepath } def
    /Bullet        { 500 500 Adjust CirclePath fill } def
    /Circle        { 500 500 Adjust CirclePath .9 .9 scale CirclePath
                     eofill } def
    /BoldCircle    { 500 500 Adjust CirclePath .8 .8 scale CirclePath
                     eofill } def
    /BoldCircle    { CirclePath .8 .8 scale CirclePath eofill } def
    /TrianglePath  { 0  660 moveto -571.5 -330 lineto 571.5 -330 lineto
                     closepath } def
    /SolidTriangle { TrianglePath fill } def
    /Triangle      { TrianglePath .85 .85 scale TrianglePath eofill } def
    /BoldTriangle  { TrianglePath .7 .7 scale TrianglePath eofill } def
    /SquarePath    { -450 450 moveto 450 450 lineto 450 -450 lineto
                     -450 -450 lineto closepath } def
    /SolidSquare   { SquarePath fill } def
    /Square        { SquarePath .89 .89 scale SquarePath eofill } def
    /BoldSquare    { SquarePath .78 .78 scale SquarePath eofill } def
    /PentagonPath  {
      -337.8 -465   moveto
       337.8 -465   lineto
       546.6  177.6 lineto
         0    574.7 lineto
      -546.6  177.6 lineto
      closepath
    } def
    /SolidPentagon { PentagonPath fill } def
    /Pentagon      { PentagonPath .89 .89 scale PentagonPath eofill } def
    /BoldPentagon  { PentagonPath .78 .78 scale PentagonPath eofill } def
% DG/SR modification begin - Dec. 16, 1999 - From Etienne Riga
    /DiamondPath   { 0 742.5 moveto -428.5 0 lineto 0 -742.5 lineto
                     428.5 0 lineto closepath } def
    /SolidDiamond  { DiamondPath fill } def
    /Diamond       { DiamondPath .85 .85 scale DiamondPath eofill } def
    /BoldDiamond   { DiamondPath .7 .7 scale DiamondPath eofill } def
% DG/SR modification end
    /.notdef { } def
  end
  /BuildGlyph {
    exch
    begin
      Metrics 1 index get exec 0
      BBoxes 3 index get exec
      setcachedevice
      CharProcs begin load exec end
    end
  } def
  /BuildChar {
    1 index /Encoding get exch get
    1 index /BuildGlyph get exec
  } bind def
end
/PSTricksDotFont exch definefont pop
%END pst-dots.pro

%%EndProcSet
%%BeginProcSet: pst-barcode.pro
%!PS-Adobe-2.0
%%Creator: Terry Burton
%%DocumentPaperSizes: a4
%%EndComments
%%EndProlog

% Barcode Writer in Pure PostScript - Version 2006-09-26
% http://www.terryburton.co.uk/barcodewriter/
%
% Copyright (c) 2006 Terry Burton - tez@terryburton.co.uk
%
% Permission is hereby granted, free of charge, to any
% person obtaining a copy of this software and associated
% documentation files (the "Software"), to deal in the
% Software without restriction, including without
% limitation the rights to use, copy, modify, merge,
% publish, distribute, sublicense, and/or sell copies of
% the Software, and to permit persons to whom the Software
% is furnished to do so, subject to the following
% conditions:
%
% The above copyright notice and this permission notice
% shall be included in all copies or substantial portions
% of the Software.
%
% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY
% KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
% THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
% PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
% THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
% DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
% CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
% CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
% IN THE SOFTWARE.

% Uncomment this next line to allow these procedure definitions to 
% remain resident within a printer's PostScript virtual machine 
% so that the barcode generation capability persists between jobs.

% serverdict begin 0 exitserver 

% --BEGIN TEMPLATE--

% --BEGIN ENCODER ean13--
% --DESC: EAN-13
% --EXAM: 977147396801
/ean13 {

    0 begin

    /options exch def                  % We are given an option string
    /useropts options def
    /barcode exch def                  % We are given a barcode string

    /includetext false def             % Enable/disable text
    /textfont /Helvetica def
    /textsize 12 def
    /textpos -4 def
    /height 1 def
    
    % Parse the input options
    options {
        token false eq {exit} if dup length string cvs (=) search
        true eq {cvlit exch pop exch def} {cvlit true def} ifelse
    } loop
    
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textpos textpos cvr def
    /height height cvr def
    
    /barlen barcode length def         % Length of the code

    % Add checksum digit to barcode if length is even
    barlen 2 mod 0 eq {
        /pad barlen 1 add string def   % Create pad one bigger than barcode
        /checksum 0 def
        0 1 barlen 1 sub {
            /i exch def
            /barchar barcode i get 48 sub def
            i 2 mod 0 eq {
                /checksum barchar checksum add def
            } {
                /checksum barchar 3 mul checksum add def
            } ifelse
        } for
        /checksum 10 checksum 10 mod sub 10 mod def
        pad 0 barcode putinterval       % Add barcode to the start of the pad
        pad barlen checksum 48 add put  % Put ascii for checksum at end of pad
        /barcode pad def                % barcode=pad
        /barlen barlen 1 add def        % barlen++
    } if

    % Create an array containing the character mappings
    /encs
    [ (3211) (2221) (2122) (1411) (1132)
      (1231) (1114) (1312) (1213) (3112)
      (111) (11111) (111)
    ] def

    % Create a string of the available characters
    /barchars (0123456789) def

    % Digits to mirror on left side
    /mirrormaps
    [ (000000) (001011) (001101) (001110) (010011)
      (011001) (011100) (010101) (010110) (011010)
    ] def

    /sbs barlen 1 sub 4 mul 11 add string def
    /txt barlen array def
  
    % Put the start character
    sbs 0 encs 10 get putinterval

    % First digit - determine mirrormap by this and show before guard bars
    /mirrormap mirrormaps barcode 0 get 48 sub get def
    txt 0 [barcode 0 1 getinterval -10 textpos textfont textsize] put

    % Left side - performs mirroring
    1 1 6 {
        % Lookup the encoding for the each barcode character
        /i exch def
        barcode i 1 getinterval barchars exch search
        pop                            % Discard true leaving pre
        length /indx exch def          % indx is the length of pre
        pop pop                        % Discard seek and post
        /enc encs indx get def         % Get the indxth encoding
        mirrormap i 1 sub get 49 eq {   % Reverse enc if 1 in this position in mirrormap
            /enclen enc length def
            /revenc enclen string def
            0 1 enclen 1 sub {
                /j exch def
                /char enc j get def
                revenc enclen j sub 1 sub char put
            } for
            /enc revenc def
        } if
        sbs i 1 sub 4 mul 3 add enc putinterval   % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 1 sub 7 mul 4 add textpos textfont textsize] put
    } for

    % Put the middle character
    sbs 7 1 sub 4 mul 3 add encs 11 get putinterval

    % Right side
    7 1 12 {
        % Lookup the encoding for the each barcode character
        /i exch def
        barcode i 1 getinterval barchars exch search
        pop                            % Discard true leaving pre
        length /indx exch def          % indx is the length of pre
        pop pop                        % Discard seek and post
        /enc encs indx get def         % Get the indxth encoding
        sbs i 1 sub 4 mul 8 add enc putinterval  % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 1 sub 7 mul 8 add textpos textfont textsize] put
    } for

    % Put the end character
    sbs barlen 1 sub 4 mul 8 add encs 12 get putinterval
    
    % Return the arguments
    /retval 4 dict def
    retval (sbs) [sbs {48 sub} forall] put
    includetext {
        retval (bhs) [height height 12{height .075 sub}repeat height height 12{height .075 sub}repeat height height] put
        retval (bbs) [0 0 12{.075}repeat 0 0 12{.075}repeat 0 0] put
        retval (txt) txt put
    } {
        retval (bhs) [30{height}repeat] put        
        retval (bbs) [30{0}repeat] put
    } ifelse
    retval (opt) useropts put
    retval (guardrightpos) 10 put
    retval (borderbottom) 5 put
    retval
    
    end

} bind def
/ean13 load 0 1 dict put
% --END ENCODER ean13--

% --BEGIN ENCODER ean8--
% --DESC: EAN-8
% --EXAM: 01335583
/ean8 {

    0 begin

    /options exch def                  % We are given an option string
    /useropts options def
    /barcode exch def                  % We are given a barcode string

    /includetext false def              % Enable/disable text
    /textfont /Helvetica def
    /textsize 12 def
    /textpos -4 def
    /height 1 def
    
    % Parse the input options
    options {
        token false eq {exit} if dup length string cvs (=) search
        true eq {cvlit exch pop exch def} {cvlit true def} ifelse
    } loop
    
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textpos textpos cvr def
    /height height cvr def
    
    % Create an array containing the character mappings
    /encs
    [ (3211) (2221) (2122) (1411) (1132)
      (1231) (1114) (1312) (1213) (3112)
      (111) (11111) (111)
    ] def

    % Create a string of the available characters
    /barchars (0123456789) def

    /barlen barcode length def           % Length of the code
    /sbs barlen 4 mul 11 add string def
    /txt barlen array def
    
    % Put the start character
    sbs 0 encs 10 get putinterval

    % Left side
    0 1 3 {
        % Lookup the encoding for the each barcode character
        /i exch def
        barcode i 1 getinterval barchars exch search
        pop                                % Discard true leaving pre
        length /indx exch def              % indx is the length of pre
        pop pop                            % Discard seek and post
        /enc encs indx get def             % Get the indxth encoding
        sbs i 4 mul 3 add enc putinterval  % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 7 mul 4 add textpos textfont textsize] put
    } for

    % Put the middle character
    sbs 4 4 mul 3 add encs 11 get putinterval

    % Right side
    4 1 7 {
        % Lookup the encoding for the each barcode character
        /i exch def
        barcode i 1 getinterval barchars exch search
        pop                                % Discard true leaving pre
        length /indx exch def              % indx is the length of pre
        pop pop                            % Discard seek and post
        /enc encs indx get def             % Get the indxth encoding
        sbs i 4 mul 8 add enc putinterval  % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 7 mul 8 add textpos textfont textsize] put
    } for

    % Put the end character
    sbs barlen 4 mul 8 add encs 12 get putinterval

    % Return the arguments
    /retval 4 dict def
    retval (sbs) [sbs {48 sub} forall] put
    includetext {
        retval (bhs) [height height 8{height .075 sub}repeat height height 8{height .075 sub}repeat height height] put
        retval (bbs) [0 0 8{.075}repeat 0 0 8{.075}repeat 0 0] put
        retval (txt) txt put
    } {
        retval (bhs) [22{height}repeat] put        
        retval (bbs) [22{0}repeat] put
    } ifelse
    retval (opt) useropts put
    retval (guardleftpos) 10 put
    retval (guardrightpos) 10 put
    retval (borderbottom) 5 put
    retval

    end

} bind def
/ean8 load 0 1 dict put
% --END ENCODER ean8--

% --BEGIN ENCODER upca--
% --DESC: UPC-A
% --EXAM: 78858101497
/upca {

    0 begin

    /options exch def
    /useropts options def
    /barcode exch def             % We are given a barcode string

    /includetext false def         % Enable/disable text
    /textfont /Helvetica def
    /textsize 12 def
    /textpos -4 def
    /height 1 def
    
    % Parse the input options
    options {
        token false eq {exit} if dup length string cvs (=) search
        true eq {cvlit exch pop exch def} {cvlit true def} ifelse
    } loop
    
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textpos textpos cvr def
    /height height cvr def
    
    /barlen barcode length def         % Length of the code

    % Add checksum digit to barcode if length is odd
    barlen 2 mod 0 ne {
        /pad barlen 1 add string def   % Create pad one bigger than barcode
        /checksum 0 def
        0 1 barlen 1 sub {
           /i exch def
           /barchar barcode i get 48 sub def
           i 2 mod 0 ne {
               /checksum checksum barchar add def
           } {
               /checksum checksum barchar 3 mul add def
           } ifelse
        } for
        /checksum 10 checksum 10 mod sub 10 mod def
        pad 0 barcode putinterval       % Add barcode to the start of the pad
        pad barlen checksum 48 add put  % Put ascii for checksum at end of pad
        /barcode pad def                % barcode=pad
        /barlen barlen 1 add def        % barlen++
    } if

    % Create an array containing the character mappings
    /encs
    [ (3211) (2221) (2122) (1411) (1132)
      (1231) (1114) (1312) (1213) (3112)
      (111) (11111) (111)
    ] def

    % Create a string of the available characters
    /barchars (0123456789) def

    /sbs barlen 4 mul 11 add string def
    /txt barlen array def

    % Put the start character
    sbs 0 encs 10 get putinterval

    % Left side
    0 1 5 {
        % Lookup the encoding for the each barcode character
        /i exch def
        barcode i 1 getinterval barchars exch search
        pop                                % Discard true leaving pre
        length /indx exch def              % indx is the length of pre
        pop pop                            % Discard seek and post
        /enc encs indx get def             % Get the indxth encoding
        sbs i 4 mul 3 add enc putinterval  % Put encoded digit into sbs
        i 0 eq {      % First digit is before the guard bars
            txt 0 [barcode 0 1 getinterval -7 textpos textfont textsize 2 sub] put
        } {
            txt i [barcode i 1 getinterval i 7 mul 4 add textpos textfont textsize] put
        } ifelse
    } for

    % Put the middle character
    sbs 6 4 mul 3 add encs 11 get putinterval

    % Right side
    6 1 11 {
        % Lookup the encoding for the each barcode character
        /i exch def
        barcode i 1 getinterval barchars exch search
        pop                                % Discard true leaving pre
        length /indx exch def              % indx is the length of pre
        pop pop                            % Discard seek and post
        /enc encs indx get def             % Get the indxth encoding
        sbs i 4 mul 8 add enc putinterval  % Put encoded digit into sbs
        i 11 eq {       % Last digit is after guard bars
            txt 11 [barcode 11 1 getinterval 96 textpos textfont textsize 2 sub] put
        } {
            txt i [barcode i 1 getinterval i 7 mul 8 add textpos textfont textsize] put
        } ifelse
    } for

    % Put the end character
    sbs barlen 4 mul 8 add encs 12 get putinterval

    % Return the arguments
    /retval 4 dict def
    retval (sbs) [sbs {48 sub} forall] put
    includetext {
        retval (bhs) [4{height}repeat 10{height .075 sub}repeat height height 10{height .075 sub}repeat 5{height}repeat] put      
        retval (bbs) [0 0 0 0 10{.075}repeat 0 0 10{.075}repeat 0 0 0 0 0] put
        retval (txt) txt put
    } {
        retval (bhs) [31{height}repeat] put
        retval (bbs) [31{0}repeat] put
    } ifelse
    retval (opt) useropts put
    retval (borderbottom) 5 put
    retval

    end

} bind def
/upca load 0 1 dict put
% --END ENCODER upca--

% --BEGIN ENCODER upce--
% --DESC: UPC-E
% --EXAM: 0123456
/upce {

    0 begin

    /options exch def                   % We are given an option string
    /useropts options def
    /barcode exch def                   % We are given a barcode string

    /includetext false def               % Enable/disable text
    /textfont /Helvetica def
    /textsize 12 def
    /textpos -4 def
    /height 1 def
    
    % Parse the input options
    options {
        token false eq {exit} if dup length string cvs (=) search
        true eq {cvlit exch pop exch def} {cvlit true def} ifelse
    } loop
    
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textpos textpos cvr def
    /height height cvr def
    
    /barlen barcode length def          % Length of the code

    % Create an array containing the character mappings
    /encs
    [ (3211) (2221) (2122) (1411) (1132)
      (1231) (1114) (1312) (1213) (3112)
      (111) (1111111)
    ] def

    % Create a string of the available characters
    /barchars (0123456789) def

    /mirrormaps
    [ (000111) (001011) (001101) (001110) (010011)
      (011001) (011100) (010101) (010110) (011010)
    ] def

    % Add checksum digit to barcode if length is odd
    barlen 2 mod 0 ne {
        /pad barlen 1 add string def    % Create pad one bigger than barcode
        /checksum 0 def
        0 1 barlen 1 sub {
            /i exch def
            /barchar barcode i get 48 sub def
            i 2 mod 0 ne {
                /checksum barchar checksum add def
            } {
                /checksum barchar 3 mul checksum add def
            } ifelse
        } for
        /checksum 10 checksum 10 mod sub 10 mod def
        pad 0 barcode putinterval       % Add barcode to the start of the pad
        pad barlen checksum 48 add put  % Put ascii for checksum at end of pad
        /barcode pad def                % barcode=pad
        /barlen barlen 1 add def        % barlen++
    } if
    /txt barlen array def
    txt 0 [barcode 0 1 getinterval -7 textpos textfont textsize 2 sub] put

    % Determine the mirror map based on checksum
    /mirrormap mirrormaps barcode barlen 1 sub get 48 sub get def

    % Invert the mirrormap if we are using a non-zero number system
    barcode 0 get 48 eq {
        /invt mirrormap length string def
        0 1 mirrormap length 1 sub {
            /i exch def
            mirrormap i get 48 eq {
                invt i 49 put
            } {
                invt i 48 put
            } ifelse
        } for
        /mirrormap invt def
    } if

    /sbs barlen 2 sub 4 mul 10 add string def

    % Put the start character
    sbs 0 encs 10 get putinterval

    1 1 6 {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                            % Discard true leaving pre
        length /indx exch def          % indx is the length of pre
        pop pop                        % Discard seek and post
        /enc encs indx get def         % Get the indxth encoding
        mirrormap i 1 sub get 49 eq {  % Reverse enc if 1 in this position in mirrormap        
            /enclen enc length def
            /revenc enclen string def
            0 1 enclen 1 sub {
                /j exch def
                /char enc j get def
                revenc enclen j sub 1 sub char put
            } for
            /enc revenc def
        } if
        sbs i 1 sub 4 mul 3 add enc putinterval   % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 1 sub 7 mul 4 add textpos textfont textsize] put
    } for

    txt 7 [barcode 7 1 getinterval 6 7 mul 11 add textpos textfont textsize 2 sub] put

    % Put the end character
    sbs barlen 2 sub 4 mul 3 add encs 11 get putinterval

    % Return the arguments
    /retval 4 dict def
    retval (sbs) [sbs {48 sub} forall] put
    includetext {
        retval (bhs) [height height 12{height .075 sub}repeat height height height] put      
        retval (bbs) [0 0 12{.075}repeat 0 0 0] put    
        retval (txt) txt put
    } {
        retval (bhs) [17{height}repeat] put      
        retval (bbs) [17{0}repeat] put    
    } ifelse
    retval (opt) useropts put
    retval (borderbottom) 5 put
    retval

    end

} bind def
/upce load 0 1 dict put
% --END ENCODER upce--

% --BEGIN ENCODER ean5--
% --DESC: EAN-5 (5 digit addon)
% --EXAM: 0123456
/ean5 {

    0 begin

    /options exch def                   % We are given an option string
    /useropts options def
    /barcode exch def                   % We are given a barcode string

    /includetext false def              % Enable/disable text
    /textfont /Helvetica def
    /textsize 12 def
    /textpos (unset) def
    /height 0.7 def    
    
    % Parse the input options
    options {
        token false eq {exit} if dup length string cvs (=) search
        true eq {cvlit exch pop exch def} {cvlit true def} ifelse
    } loop
    
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /height height cvr def
    textpos (unset) eq {
        /textpos height 72 mul 1 add def
    } {
        /textpos textpos cvr def
    } ifelse
    
    /barlen barcode length def          % Length of the code

    % Create an array containing the character mappings
    /encs
    [ (3211) (2221) (2122) (1411) (1132)
      (1231) (1114) (1312) (1213) (3112)
      (112) (11)
    ] def

    % Create a string of the available characters
    /barchars (0123456789) def

    % Determine the mirror map based on mod 10 checksum
    /mirrormaps
    [ (11000) (10100) (10010) (10001) (01100)
      (00110) (00011) (01010) (01001) (00101)
    ] def
    /checksum 0 def
    0 1 4 {
        /i exch def
        /barchar barcode i get 48 sub def
        i 2 mod 0 eq {
            /checksum barchar 3 mul checksum add def
        } {
            /checksum barchar 9 mul checksum add def
        } ifelse
    } for
    /checksum checksum 10 mod def
    /mirrormap mirrormaps checksum get def

    /sbs 31 string def
    /txt 5 array def
   
    0 1 4 {
        /i exch def

        % Prefix with either a start character or separator character
        i 0 eq {
            sbs 0 encs 10 get putinterval
        } {
            sbs i 1 sub 6 mul 7 add encs 11 get putinterval
        } ifelse

        % Lookup the encoding for the barcode character
        barcode i 1 getinterval barchars exch search
        pop                     % Discard true leaving pre
        length /indx exch def   % indx is the length of pre
        pop pop                 % Discard seek and post
        /enc encs indx get def  % Get the indxth encoding
        mirrormap i get 49 eq { % Reverse enc if 1 in this position in mirrormap
            /enclen enc length def
            /revenc enclen string def
            0 1 enclen 1 sub {
                /j exch def
                /char enc j get def
                revenc enclen j sub 1 sub char put
            } for
            /enc revenc def
        } if
        sbs i 6 mul 3 add enc putinterval   % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 1 sub 9 mul 13 add textpos textfont textsize] put
    } for

    % Return the arguments
    /retval 4 dict def
    retval (sbs) [sbs {48 sub} forall] put
    retval (bhs) [16{height}repeat] put
    retval (bbs) [16{0}repeat] put
    includetext {
        retval (txt) txt put
    } if
    retval (opt) useropts put
    retval (guardrightpos) 10 put
    retval (guardrightypos) textpos 4 add put
    retval (bordertop) 10 put
    retval

    end

} bind def
/ean5 load 0 1 dict put
% --END ENCODER ean5--

% --BEGIN ENCODER ean2--
% --DESC: EAN-2 (2 digit addon)
% --EXAM: 05
/ean2 {

    0 begin

    /options exch def                   % We are given an options string
    /useropts options def
    /barcode exch def                   % We are given a barcode string

    /includetext false def               % Enable/disable text
    /textfont /Helvetica def
    /textsize 12 def
    /textpos (unset) def
    /height 0.7 def
    
    % Parse the input options
    options {
        token false eq {exit} if dup length string cvs (=) search
        true eq {cvlit exch pop exch def} {cvlit true def} ifelse
    } loop
    
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /height height cvr def
    textpos (unset) eq {
        /textpos height 72 mul 1 add def
    } {
        /textpos textpos cvr def
    } ifelse
    
    /barlen barcode length def          % Length of the code

    % Create an array containing the character mappings
    /encs
    [ (3211) (2221) (2122) (1411) (1132)
      (1231) (1114) (1312) (1213) (3112)
      (112) (11)
    ] def

    % Create a string of the available characters
    /barchars (0123456789) def

    % Determine the mirror map based on mod 4 checksum
    /mirrormap [(00) (01) (10) (11)] barcode 0 2 getinterval cvi 4 mod get def

    /sbs 13 string def
    /txt 2 array def
    
    0 1 1 {
        /i exch def

        % Prefix with either a start character or separator character
        i 0 eq {
            sbs 0 encs 10 get putinterval
        } {
            sbs i 1 sub 6 mul 7 add encs 11 get putinterval
        } ifelse

        % Lookup the encoding for the barcode character
        barcode i 1 getinterval barchars exch search
        pop                     % Discard true leaving pre
        length /indx exch def   % indx is the length of pre
        pop pop                 % Discard seek and post
        /enc encs indx get def  % Get the indxth encoding
        mirrormap i get 49 eq { % Reverse enc if 1 in this position in mirrormap    
            /enclen enc length def
            /revenc enclen string def
            0 1 enclen 1 sub {
                /j exch def
                /char enc j get def
                revenc enclen j sub 1 sub char put
            } for
            /enc revenc def
        } if
        sbs i 6 mul 3 add enc putinterval   % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 1 sub 9 mul 13 add textpos textfont textsize] put
    } for

    % Return the arguments
    /retval 4 dict def
    retval (sbs) [sbs {48 sub} forall] put
    retval (bhs) [12{height}repeat] put
    retval (bbs) [12{0}repeat] put
    includetext {
        retval (txt) txt put
    } if
    retval (opt) useropts put
    retval (guardrightpos) 10 put
    retval (guardrightypos) textpos 4 add put
    retval (bordertop) 10 put
    retval

    end

} bind def
/ean2 load 0 1 dict put
% --END ENCODER ean2--

% --BEGIN ENCODER isbn--
% --REQUIRES ean13--
% --DESC: ISBN
% --EXAM: 1-86074-271
/isbn {

    0 begin

    /options exch def      % We are given an options string
    /useropts options def
    /isbntxt exch def      % We are given the isbn text with dashes

    /includetext false def  % Enable/disable ISBN text
    /isbnfont /Courier def
    /isbnsize 9 def
    /isbnpos (unset) def
    /height 1 def
    
    % Parse the input options
    options {
        token false eq {exit} if dup length string cvs (=) search
        true eq {cvlit exch pop exch def} {cvlit true def} ifelse
    } loop
    
    /isbnfont isbnfont cvlit def
    /isbnsize isbnsize cvr def
    /height height cvr def
    isbnpos (unset) eq {
        /isbnpos height 72 mul 3 add def
    } {
        /isbnpos isbnpos cvr def
    } ifelse
    
    % Read the digits from isbntxt and calculate checksums
    /isbn 13 string def
    /checksum10 0 def
    /checksum13 0 def
    /i 0 def /n 0 def
    { % loop
        /isbnchar isbntxt i get 48 sub def
        isbnchar -3 ne {     % Ignore dashes
            isbn n isbnchar 48 add put
            /checksum10 checksum10 10 n sub isbnchar mul add def
            n 2 mod 0 eq {
                /checksum13 isbnchar checksum13 add def
            } {
                /checksum13 isbnchar 3 mul checksum13 add def
            } ifelse
            /n n 1 add def
        } if
        /i i 1 add def
        i isbntxt length eq {exit} if
    } loop

    % Add the ISBN header to the isbntxt
    n 9 eq n 10 eq or {
        /checksum 11 checksum10 11 mod sub 11 mod def
        /isbn isbn 0 9 getinterval def
        /pad 18 string def
    } {
        /checksum 10 checksum13 10 mod sub 10 mod def
        /isbn isbn 0 12 getinterval def
        /pad 22 string def
    } ifelse
    pad 0 (ISBN ) putinterval
    pad 5 isbntxt putinterval  % Add isbntxt to the pad

    % Add checksum digit if isbntxt length is 11 or 15
    isbntxt length 11 eq isbntxt length 15 eq or {
        pad isbntxt length 5 add 45 put  % Put a dash
        checksum 10 eq {
            pad isbntxt length 6 add checksum 78 add put  % Check digit for 10 is X
        } {
            pad isbntxt length 6 add checksum 48 add put  % Put check digit
        } ifelse
    } if
    /isbntxt pad def                    % isbntxt=pad

    % Convert ISBN digits to EAN-13
    /barcode 12 string def
    isbn length 9 eq {        
        barcode 0 (978) putinterval
        barcode 3 isbn putinterval
    } {
        barcode 0 isbn putinterval
    } ifelse

    % Get the result of encoding with ean13    
    /args barcode options ean13 def

    % Add the ISBN text
    includetext {
        isbn length 9 eq {
            /isbnxpos -1 def
        } {
            /isbnxpos -12 def
        } ifelse
        args (txt) known {
            /txt args (txt) get def
            /newtxt txt length 1 add array def
            newtxt 0 txt putinterval
            newtxt newtxt length 1 sub [isbntxt isbnxpos isbnpos isbnfont isbnsize] put
            args (txt) newtxt put
        } {
            args (txt) [ [isbntxt isbnxpos isbnpos isbnfont isbnsize] ] put
        } ifelse
    } if

    args (opt) useropts put
    args

    end
 
} bind def
/isbn load 0 1 dict put
% --END ENCODER isbn--

% --BEGIN ENCODER code128--
% --DESC: Code 128
% --EXAM: ^104^102Count^0990123456789^101!
/code128 {

    0 begin                  % Confine variables to local scope

    /options exch def        % We are given an option string
    /useropts options def
    /barcode exch def        % We are given a barcode string

    /includetext false def    % Enable/disable text
    /textfont /Courier def
    /textsize 10 def
    /textpos -7 def
    /height 1 def
    
    % Parse the input options
    options {
        token false eq {exit} if dup length string cvs (=) search
        true eq {cvlit exch pop exch def} {cvlit true def} ifelse
    } loop
    
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textpos textpos cvr def
    /height height cvr def
    
    % Create an array containing the character mappings
    /encs
    [ (212222) (222122) (222221) (121223) (121322) (131222) (122213)
      (122312) (132212) (221213) (221312) (231212) (112232) (122132)
      (122231) (113222) (123122) (123221) (223211) (221132) (221231)
      (213212) (223112) (312131) (311222) (321122) (321221) (312212)
      (322112) (322211) (212123) (212321) (232121) (111323) (131123)
      (131321) (112313) (132113) (132311) (211313) (231113) (231311)
      (112133) (112331) (132131) (113123) (113321) (133121) (313121)
      (211331) (231131) (213113) (213311) (213131) (311123) (311321)
      (331121) (312113) (312311) (332111) (314111) (221411) (431111)
      (111224) (111422) (121124) (121421) (141122) (141221) (112214)
      (112412) (122114) (122411) (142112) (142211) (241211) (221114)
      (413111) (241112) (134111) (111242) (121142) (121241) (114212)
      (124112) (124211) (411212) (421112) (421211) (212141) (214121)
      (412121) (111143) (111341) (131141) (114113) (114311) (411113)
      (411311) (113141) (114131) (311141) (411131) (211412) (211214)
      (211232) (2331112)
    ] def

    % Create a string of the available characters for alphabets A and B
    /barchars ( !"#$%&'\(\)*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~) def
    /barlen barcode length def    % Length of the code
    /sbs barlen 6 mul string def  % sbs is 6 times length of barcode
    /txt barlen array def

    /mode -1 def         % A=0, B=1, C=2
    /checksum barcode 1 3 getinterval cvi def  % Initialise the checksum

    /i 0 def /j 0 def
    { % loop
        i barlen eq {exit} if
        barcode i 1 getinterval (^) eq {
            % indx is given by the next three characters
            /indx barcode i 1 add 3 getinterval cvi def
            txt j [( ) j 11 mul textpos textfont textsize] put
            /i i 4 add def
        } {
            % indx depends on the mode
            mode 2 eq {
                /indx barcode i 2 getinterval cvi def
                txt j [barcode i 2 getinterval j 11 mul textpos textfont textsize] put
                /i i 2 add def
            } {
                barchars barcode i 1 getinterval search
                pop                    % Discard true leaving pre
                length /indx exch def  % indx is the length of pre
                pop pop                % Discard seek and post
                txt j [barchars indx 1 getinterval j 11 mul textpos textfont textsize] put
                /i i 1 add def
            } ifelse
        } ifelse
        /enc encs indx get def         % Get the indxth encoding
        sbs j 6 mul enc putinterval    % Put encoded digit into sbs

        % Update the mode
        indx 101 eq indx 103 eq or {/mode 0 def} if
        indx 100 eq indx 104 eq or {/mode 1 def} if
        indx 99 eq indx 105 eq or {/mode 2 def} if

        /checksum indx j mul checksum add def  % checksum+=indx*j
        /j j 1 add def
    } loop

    % Put the checksum character
    /checksum checksum 103 mod def
    sbs j 6 mul encs checksum get putinterval

    % Put the end character
    sbs j 6 mul 6 add encs 106 get putinterval

    % Shrink sbs and txt to fit exactly
    /sbs sbs 0 j 6 mul 13 add getinterval def
    /txt txt 0 j getinterval def

    % Return the arguments
    /retval 1 dict def
    retval (sbs) [sbs {48 sub} forall] put
    retval (bhs) [sbs length 1 add 2 idiv {height} repeat] put
    retval (bbs) [sbs length 1 add 2 idiv {0} repeat] put
    includetext {
        retval (txt) txt put
    } if
    retval (opt) useropts put
    retval

    end

} bind def
/code128 load 0 1 dict put
% --END ENCODER code128--

% --BEGIN ENCODER code39--
% --DESC: Code 39
% --EXAM: THIS IS CODE 39
/code39 {

    0 begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /useropts options def
    /barcode exch def       % We are given a barcode string

    /includecheck false def  % Enable/disable checkdigit
    /includetext false def
    /includecheckintext false def
    /textfont /Courier def
    /textsize 10 def
    /textpos -7 def
    /height 1 def
    
    % Parse the input options
    options {
        token false eq {exit} if dup length string cvs (=) search
        true eq {cvlit exch pop exch def} {cvlit true def} ifelse
    } loop
    
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textpos textpos cvr def
    /height height cvr def
    
    % Create an array containing the character mappings
    /encs
    [ (1113313111) (3113111131) (1133111131) (3133111111) (1113311131)
      (3113311111) (1133311111) (1113113131) (3113113111) (1133113111)
      (3111131131) (1131131131) (3131131111) (1111331131) (3111331111)
      (1131331111) (1111133131) (3111133111) (1131133111) (1111333111)
      (3111111331) (1131111331) (3131111311) (1111311331) (3111311311)
      (1131311311) (1111113331) (3111113311) (1131113311) (1111313311)
      (3311111131) (1331111131) (3331111111) (1311311131) (3311311111)
      (1331311111) (1311113131) (3311113111) (1331113111) (1313131111)
      (1313111311) (1311131311) (1113131311) (1311313111)
    ] def

    % Create a string of the available characters
    /barchars (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%*) def

    /barlen barcode length def  % Length of the code

    includecheck {
        /sbs barlen 10 mul 30 add string def
        /txt barlen 3 add array def
    } {
        /sbs barlen 10 mul 20 add string def
        /txt barlen 2 add array def
    } ifelse

    /checksum 0 def

    % Put the start character
    sbs 0 encs 43 get putinterval
    txt 0 [(*) 0 textpos textfont textsize] put

    0 1 barlen 1 sub {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                  % Discard true leaving pre
        length /indx exch def                % indx is the length of pre
        pop pop                              % Discard seek and post
        /enc encs indx get def               % Get the indxth encoding
        sbs i 10 mul 10 add enc putinterval  % Put encoded digit into sbs
        txt i 1 add [barcode i 1 getinterval i 1 add 16 mul textpos textfont textsize] put
        /checksum checksum indx add def
    } for

    % Put the checksum and end characters
    includecheck {
        /checksum checksum 43 mod def
        sbs barlen 10 mul 10 add encs checksum get putinterval
        includecheckintext {
            txt barlen 1 add [barchars checksum 1 getinterval barlen 1 add 16 mul textpos textfont textsize] put
        } {
            txt barlen 1 add [() barlen 1 add 16 mul textpos textfont textsize] put
        } ifelse
        sbs barlen 10 mul 20 add encs 43 get putinterval
        txt barlen 2 add [(*) barlen 2 add 16 mul textpos textfont textsize] put
    } {
        sbs barlen 10 mul 10 add encs 43 get putinterval
        txt barlen 1 add [(*) barlen 1 add 16 mul textpos textfont textsize] put
    } ifelse
    
    % Return the arguments
    /retval 2 dict def
    retval (sbs) [sbs {48 sub} forall] put
    retval (bhs) [sbs length 1 add 2 idiv {height} repeat] put
    retval (bbs) [sbs length 1 add 2 idiv {0} repeat] put
    includetext {
        retval (txt) txt put
    } if
    retval (opt) useropts put
    retval

    end

} bind def
/code39 load 0 1 dict put
% --END ENCODER code39--

% --BEGIN ENCODER code93--
% --DESC: Code 93
% --EXAM: THIS IS CODE 93
/code93 {

    0 begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /useropts options def
    /barcode exch def       % We are given a barcode string

    /includecheck false def  % Enable/disable checkdigit
    /includetext false def   % Enable/disable text
    /textfont /Courier def
    /textsize 10 def
    /textpos -7 def
    /height 1 def
    
    % Parse the input options
    options {
        token false eq {exit} if dup length string cvs (=) search
        true eq {cvlit exch pop exch def} {cvlit true def} ifelse
    } loop
    
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textpos textpos cvr def
    /height height cvr def
    
    /encs
    [ (131112) (111213) (111312) (111411) (121113)
      (121212) (121311) (111114) (131211) (141111)
      (211113) (211212) (211311) (221112) (221211)
      (231111) (112113) (112212) (112311) (122112)
      (132111) (111123) (111222) (111321) (121122)
      (131121) (212112) (212211) (211122) (211221)
      (221121) (222111) (112122) (112221) (122121)
      (123111) (121131) (311112) (311211) (321111)
      (112131) (113121) (211131) (121221) (312111)
      (311121) (122211) (111141) (1111411)
    ] def

    % Create a string of the available characters
    /barchars (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%) def

    /barlen barcode length def  % Length of the code    
    barcode {
        (^) search false eq {pop exit} if
        pop pop /barlen barlen 3 sub def
    } loop

    includecheck {
        /sbs barlen 6 mul 25 add string def
    } {
        /sbs barlen 6 mul 13 add string def
    } ifelse
    /txt barlen array def
    
    % Put the start character
    sbs 0 encs 47 get putinterval
    
    /checksum1 0 def /checksum2 0 def

    /i 0 def /j 0 def
    { % loop
        j barlen eq {exit} if
        barcode i 1 getinterval (^) eq {
            % indx is given by the next three characters
            /indx barcode i 1 add 3 getinterval cvi def
            txt j [( ) j 9 mul 9 add textpos textfont textsize] put
            /i i 4 add def
        } {
            barchars barcode i 1 getinterval search
            pop                         % Discard true leaving pre
            length /indx exch def       % indx is the length of pre
            pop pop                     % Discard seek and post
            txt j [barchars indx 1 getinterval j 9 mul 9 add textpos textfont textsize] put
            /i i 1 add def
        } ifelse
        /enc encs indx get def             % Get the indxth encoding
        sbs j 6 mul 6 add enc putinterval  % Put encoded digit into sbs
        /checksum1 checksum1 barlen j sub 1 sub 20 mod 1 add indx mul add def
        /checksum2 checksum2 barlen j sub 15 mod 1 add indx mul add def
        /j j 1 add def
    } loop
    
    includecheck {
        % Put the first checksum character
        /checksum1 checksum1 47 mod def
        /checksum2 checksum2 checksum1 add 47 mod def
        sbs j 6 mul 6 add encs checksum1 get putinterval
        sbs j 6 mul 12 add encs checksum2 get putinterval
        % Put the end character
        sbs j 6 mul 18 add encs 48 get putinterval
    } {
        % Put the end character
        sbs j 6 mul 6 add encs 48 get putinterval      
    } ifelse

    % Return the arguments
    /retval 1 dict def
    retval (sbs) [sbs {48 sub} forall] put
    retval (bhs) [sbs length 1 add 2 idiv {height} repeat] put
    retval (bbs) [sbs length 1 add 2 idiv {0} repeat] put
    includetext {
        retval (txt) txt put
    } if
    retval (opt) useropts put
    retval

    end

} bind def
/code93 load 0 1 dict put
% --END ENCODER code93--

% --BEGIN ENCODER interleaved2of5--
% --DESC: Interleaved 2 of 5 (ITF)
% --EXAM: 24012345678905
/interleaved2of5 {

    0 begin         % Confine variables to local scope

    /options exch def               % We are given an option string
    /useropts options def
    /barcode exch def               % We are given a barcode string

    /includecheck false def         % Enable/disable checkdigit
    /includetext false def          % Enable/disable text
    /includecheckintext false def
    /textfont /Courier def
    /textsize 10 def
    /textpos -7 def
    /height 1 def
    
    % Parse the input options
    options {
        token false eq {exit} if dup length string cvs (=) search
        true eq {cvlit exch pop exch def} {cvlit true def} ifelse
    } loop
    
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textpos textpos cvr def
    /height height cvr def
    
    /barlen barcode length def      % Length of the code

    % Prefix 0 to barcode if length is even and including checkdigit
    % or length is odd and not including checkdigit
    barlen 2 mod 0 eq includecheck and          % even & includecheck
    barlen 2 mod 0 ne includecheck not and or { % odd  & !includecheck
        /pad barlen 1 add string def  % Create pad one bigger than barcode
        pad 0 48 put                  % Put ascii 0 at start of pad
        pad 1 barcode putinterval     % Add barcode to the end of pad
        /barcode pad def              % barcode=pad
        /barlen barlen 1 add def      % barlen++
    } if

    % Add checksum to end of barcode
    includecheck {
        /checksum 0 def
        0 1 barlen 1 sub {
            /i exch def
            i 2 mod 0 eq {
                /checksum checksum barcode i get 48 sub 3 mul add def
            } {
                /checksum checksum barcode i get 48 sub add def
            } ifelse
        } for
        /checksum 10 checksum 10 mod sub 10 mod def
        /pad barlen 1 add string def    % Create pad one bigger than barcode
        pad 0 barcode putinterval       % Add barcode to the start of pad
        pad barlen checksum 48 add put  % Add checksum to end of pad
        /barcode pad def                % barcode=pad
        /barlen barlen 1 add def        % barlen++
    } if

    % Create an array containing the character mappings
    /encs
    [ (11331) (31113) (13113) (33111) (11313)
      (31311) (13311) (11133) (31131) (13131)
      (1111)  (3111)
    ] def

    % Create a string of the available characters
    /barchars (0123456789) def
    /sbs barlen 5 mul 8 add string def
    /txt barlen array def

    % Put the start character
    sbs 0 encs 10 get putinterval

    0 2 barlen 1 sub {
    /i exch def
        % Lookup the encodings for two consecutive barcode characters
        barcode i 1 getinterval barchars exch search
        pop                           % Discard true leaving pre
        length /indx exch def         % indx is the length of pre
        pop pop                       % Discard seek and post
        /enca encs indx get def       % Get the indxth encoding

        barcode i 1 add 1 getinterval barchars exch search
        pop                           % Discard true leaving pre
        length /indx exch def         % indx is the length of pre
        pop pop                       % Discard seek and post
        /encb encs indx get def       % Get the indxth encoding

        % Interleave the two character encodings
        /intl enca length 2 mul string def
        0 1 enca length 1 sub {
            /j exch def
            /achar enca j get def
            /bchar encb j get def
            intl j 2 mul achar put
            intl j 2 mul 1 add bchar put
        } for

        sbs i 5 mul 4 add intl putinterval   % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 9 mul 4 add textpos textfont textsize] put
        includecheck includecheckintext not and barlen 2 sub i eq and {
            txt i 1 add [( ) i 1 add 9 mul 4 add textpos textfont textsize] put
        } {
            txt i 1 add [barcode i 1 add 1 getinterval i 1 add 9 mul 4 add textpos textfont textsize] put
        } ifelse
    } for

    % Put the end character
    sbs barlen 5 mul 4 add encs 11 get putinterval

    % Return the arguments
    /retval 1 dict def
    retval (sbs) [sbs {48 sub} forall] put
    retval (bhs) [sbs length 1 add 2 idiv {height} repeat] put
    retval (bbs) [sbs length 1 add 2 idiv {0} repeat] put
    includetext {
        retval (txt) txt put
    } if
    retval (opt) useropts put
    retval

    end

} bind def
/interleaved2of5 load 0 1 dict put
% --END ENCODER interleaved2of5--

% --BEGIN ENCODER rss14--
% --DESC: Reduced Space Symbology 14 (RSS-14)
% --EXAM: 24012345678905
/rss14 {

    0 begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /useropts options def
    /barcode exch def  % We are given a barcode string

    /height 1 def
    /linkage false def
    
    % Parse the input options
    options {
        token false eq {exit} if dup length string cvs (=) search
        true eq {cvlit exch pop exch def} {cvlit true def} ifelse
    } loop
    
    /height height cvr def

    /getRSSwidths {     
        /mw exch def
        /nm exch def
        /val exch def
        /j 0 def /i 0 def {
            /v () def
            mw 1 ne {/v i mw 4 string cvrs def} if          
            0 v {48 sub add} forall 4 add nm eq {               
                j val eq {exit} if
                /j j 1 add def
            } if
            /i i 1 add def
        } loop
        [4 {1} repeat v {47 sub} forall] v length 4 getinterval
    } bind def

    /binval [barcode {48 sub} forall] def
    /binval [linkage {1} {0} ifelse binval 0 13 getinterval {} forall] def
    
    0 1 12 {
        /i exch def
        binval i 1 add 2 copy get binval i get 4537077 mod 10 mul add put
        binval i binval i get 4537077 idiv put
    } for
    /right binval 13 get 4537077 mod def
    binval 13 2 copy get 4537077 idiv put

    /left 0 def
    /i true def
    0 1 13 {
        /j exch def
        binval j get
        dup 0 eq i and {
            pop
        } {
            /i false def
            /left left 3 -1 roll 10 13 j sub exp cvi mul add def
        } ifelse
    } for
    
    /d1 left 1597 idiv def
    /d2 left 1597 mod def
    /d3 right 1597 idiv def
    /d4 right 1597 mod def

    /tab164 [
        160   0     12 4   8 1  161   1
        960   161   10 6   6 3  80   10
        2014  961   8  8   4 5  31   34
        2714  2015  6  10  3 6  10   70
        2840  2715  4  12  1 8  1    126
    ] def

    /tab154 [
        335   0     5  10  2 7  4   84
        1035  336   7  8   4 5  20  35
        1515  1036  9  6   6 3  48  10
        1596  1516  11 4   8 1  81  1
    ] def

    /i 0 def {
        d1 tab164 i get le {
            tab164 i 1 add 7 getinterval {} forall
            /d1te exch def /d1to exch def
            /d1mwe exch def /d1mwo exch def
            /d1ele exch def /d1elo exch def
            /d1gs exch def
            exit
        } if
        /i i 8 add def
    } loop

    /i 0 def {
        d2 tab154 i get le {
            tab154 i 1 add 7 getinterval {} forall
            /d2te exch def /d2to exch def
            /d2mwe exch def /d2mwo exch def
            /d2ele exch def /d2elo exch def
            /d2gs exch def
            exit
        } if
        /i i 8 add def
    } loop

    /i 0 def {
        d3 tab164 i get le {
            tab164 i 1 add 7 getinterval {} forall
            /d3te exch def /d3to exch def
            /d3mwe exch def /d3mwo exch def
            /d3ele exch def /d3elo exch def
            /d3gs exch def
            exit
        } if
        /i i 8 add def
    } loop

    /i 0 def {
        d4 tab154 i get le {
            tab154 i 1 add 7 getinterval {} forall
            /d4te exch def /d4to exch def
            /d4mwe exch def /d4mwo exch def
            /d4ele exch def /d4elo exch def
            /d4gs exch def
            exit
        } if
        /i i 8 add def
    } loop
    
    /d1wo d1 d1gs sub d1te idiv d1elo d1mwo getRSSwidths def
    /d1we d1 d1gs sub d1te mod d1ele d1mwe getRSSwidths def
    /d2wo d2 d2gs sub d2to mod d2elo d2mwo getRSSwidths def
    /d2we d2 d2gs sub d2to idiv d2ele d2mwe getRSSwidths def
    /d3wo d3 d3gs sub d3te idiv d3elo d3mwo getRSSwidths def
    /d3we d3 d3gs sub d3te mod d3ele d3mwe getRSSwidths def
    /d4wo d4 d4gs sub d4to mod d4elo d4mwo getRSSwidths def
    /d4we d4 d4gs sub d4to idiv d4ele d4mwe getRSSwidths def

    /d1w 8 array def
    0 1 3 {
        /i exch def
        d1w i 2 mul d1wo i get put
        d1w i 2 mul 1 add d1we i get put
    } for

    /d2w 8 array def
    0 1 3 {
        /i exch def
        d2w 7 i 2 mul sub d2wo i get put
        d2w 6 i 2 mul sub d2we i get put
    } for
    
    /d3w 8 array def
    0 1 3 {
        /i exch def
        d3w 7 i 2 mul sub d3wo i get put
        d3w 6 i 2 mul sub d3we i get put
    } for
    
    /d4w 8 array def
    0 1 3 {
        /i exch def
        d4w i 2 mul d4wo i get put
        d4w i 2 mul 1 add d4we i get put
    } for

    /widths [
        d1w {} forall
        d2w {} forall
        d3w {} forall
        d4w {} forall
    ] def
    
    /checkweights [
        1   3   9   27  2   6   18  54
        58  72  24  8   29  36  12  4
        74  51  17  32  37  65  48  16
        64  34  23  69  49  68  46  59
    ] def

    /checkwidths [
        3 8 2 1 1   3 5 5 1 1   3 3 7 1 1
        3 1 9 1 1   2 7 4 1 1   2 5 6 1 1
        2 3 8 1 1   1 5 7 1 1   1 3 9 1 1
    ] def
    
    /checksum 0 def
    0 1 31 {
        /i exch def
        /checksum checksum widths i get checkweights i get mul add def 
    } for
    /checksum checksum 79 mod def    
    checksum 8 ge {/checksum checksum 1 add def} if
    checksum 72 ge {/checksum checksum 1 add def} if
    /checklt checkwidths checksum 9 idiv 5 mul 5 getinterval def
    /checkrtrev checkwidths checksum 9 mod 5 mul 5 getinterval def
    /checkrt 5 array def
    0 1 4 {
        /i exch def
        checkrt i checkrtrev 4 i sub get put
    } for

    /sbs [
        1 d1w {} forall checklt {} forall d2w {}
        forall d4w {} forall checkrt {} forall d3w {} forall 1 1
    ] def
    
    % Return the arguments
    /retval 1 dict def
    retval (sbs) sbs put
    retval (bhs) [sbs length 1 add 2 idiv {height} repeat] put
    retval (bbs) [sbs length 1 add 2 idiv {0} repeat] put   
    retval (opt) useropts put
    retval

    end

} bind def
/rss14 load 0 1 dict put
% --END ENCODER rss14--

% --BEGIN ENCODER rsslimited--
% --DESC: Reduced Space Symbology Limited (RSS-Limited)
% --EXAM: 00978186074271
/rsslimited {

    0 begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /useropts options def
    /barcode exch def  % We are given a barcode string

    /height 1 def
    
    % Parse the input options
    options {
        token false eq {exit} if dup length string cvs (=) search
        true eq {cvlit exch pop exch def} {cvlit true def} ifelse
    } loop
    
    /height height cvr def

    /getRSSwidths {
        /el exch def
        /mw exch def
        /nm exch def
        /val exch def
        /j 0 def /i 0 def {
            /v () def
            mw 1 ne {/v i mw el string cvrs def} if          
            0 v {48 sub add} forall el add nm eq {               
                j val eq {exit} if
                /j j 1 add def
            } if
            /i i 1 add def
        } loop
        [el {1} repeat v {47 sub} forall] v length el getinterval
    } bind def
    
    /binval [barcode {48 sub} forall] def
    /binval [binval 0 13 getinterval {} forall] def
    
    0 1 11 {
        /i exch def
        binval i 1 add 2 copy get binval i get 2013571 mod 10 mul add put
        binval i binval i get 2013571 idiv put
    } for
    /d2 binval 12 get 2013571 mod def
    binval 12 2 copy get 2013571 idiv put

    /d1 0 def
    /i true def
    0 1 12 {
        /j exch def
        binval j get
        dup 0 eq i and {
            pop
        } {
            /i false def
            /d1 d1 3 -1 roll 10 12 j sub exp cvi mul add def
        } ifelse
    } for
    
    /tab267 [
        183063   0        17 9   6 3  6538   28
        820063   183064   13 13  5 4  875    728
        1000775  820064   9  17  3 6  28     6454
        1491020  1000776  15 11  5 4  2415   203
        1979844  1491021  11 15  4 5  203    2408
        1996938  1979845  19 7   8 1  17094  1
        2013570  1996939  7  19  1 8  1      16632
    ] def

    /i 0 def {
        d1 tab267 i get le {
            tab267 i 1 add 7 getinterval {} forall
            /d1te exch def /d1to exch def
            /d1mwe exch def /d1mwo exch def
            /d1ele exch def /d1elo exch def
            /d1gs exch def
            exit
        } if
        /i i 8 add def
    } loop

    /i 0 def {
        d2 tab267 i get le {
            tab267 i 1 add 7 getinterval {} forall
            /d2te exch def /d2to exch def
            /d2mwe exch def /d2mwo exch def
            /d2ele exch def /d2elo exch def
            /d2gs exch def
            exit
        } if
        /i i 8 add def
    } loop
    
    /d1wo d1 d1gs sub d1te idiv d1elo d1mwo 7 getRSSwidths def    
    /d1we d1 d1gs sub d1te mod d1ele d1mwe 7 getRSSwidths def
    /d2wo d2 d2gs sub d2te idiv d2elo d2mwo 7 getRSSwidths def    
    /d2we d2 d2gs sub d2te mod d2ele d2mwe 7 getRSSwidths def
    
    /d1w 14 array def
    0 1 6 {
        /i exch def
        d1w i 2 mul d1wo i get put
        d1w i 2 mul 1 add d1we i get put
    } for

    /d2w 14 array def
    0 1 6 {
        /i exch def
        d2w i 2 mul d2wo i get put
        d2w i 2 mul 1 add d2we i get put
    } for

    /widths [
        d1w {} forall
        d2w {} forall
    ] def
    
    /checkweights [
        1  3  9  27 81 65 17 51 64 14 42 37 22 66
        20 60 2  6  18 54 73 41 34 13 39 28 84 74
    ] def

    /checkseq [
        0 1 43 {} for
        45 52 57
        63 1 66 {} for
        73 1 79 {} for
        82
        126 1 130 {} for
        132
        141 1 146 {} for
        210 1 217 {} for
        220
        316 1 323 {} for
        326 337
    ] def
    
    /checksum 0 def
    0 1 27 {
        /i exch def
        /checksum checksum widths i get checkweights i get mul add def
    } for
    /checksum checksum 89 mod def
    /seq checkseq checksum get def
    /swidths seq 21 idiv 8 3 6 getRSSwidths def
    /bwidths seq 21 mod 8 3 6 getRSSwidths def

    /checkwidths [0 0 0 0 0 0 0 0 0 0 0 0 1 1] def
    0 1 5 {
        /i exch def
        checkwidths i 2 mul swidths i get put
        checkwidths i 2 mul 1 add bwidths i get put
    } for
    
    /sbs [
        1 d1w {} forall checkwidths {} forall d2w {} forall 1 1
    ] def
    
    % Return the arguments
    /retval 1 dict def
    retval (sbs) sbs put
    retval (bhs) [sbs length 1 add 2 idiv {height} repeat] put
    retval (bbs) [sbs length 1 add 2 idiv {0} repeat] put   
    retval (opt) useropts put
    retval

    end

} bind def
/rsslimited load 0 1 dict put
% --END ENCODER rsslimited--

% --BEGIN ENCODER rssexpanded--
% --DESC: Reduced Space Symbology Expanded (RSS-Expanded)
% --EXAM: 000000010011001010100001000000010000
/rssexpanded {

    0 begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /useropts options def
    /barcode exch def  % We are given a barcode string

    /height 1 def
    
    % Parse the input options
    options {
        token false eq {exit} if dup length string cvs (=) search
        true eq {cvlit exch pop exch def} {cvlit true def} ifelse
    } loop
    
    /height height cvr def

    /getRSSwidths {     
        /mw exch def
        /nm exch def
        /val exch def
        /j 0 def /i 0 def {
            /v () def
            mw 1 ne {/v i mw 4 string cvrs def} if          
            0 v {48 sub add} forall 4 add nm eq {               
                j val eq {exit} if
                /j j 1 add def
            } if
            /i i 1 add def
        } loop
        [4 {1} repeat v {47 sub} forall] v length 4 getinterval
    } bind def

    /binval [barcode {48 sub} forall] def
    /datalen binval length 12 idiv def
    
    /tab174 [
        347   0     12 5   7 2  87  4
        1387  348   10 7   5 4  52  20
        2947  1388  8  9   4 5  30  52
        3987  2948  6  11  3 6  10  104
        4191  3988  4  13  1 8  1   204
    ] def

    /dxw datalen array def
    
    0 1 datalen 1 sub {

        /x exch def

        /d binval x 12 mul 12 getinterval def
        /d 0 0 1 11 {/j exch def 2 11 j sub exp cvi d j get mul add} for def

        /j 0 def {
            d tab174 j get le {
                tab174 j 1 add 7 getinterval {} forall
                /dte exch def /dto exch def
                /dmwe exch def /dmwo exch def
                /dele exch def /delo exch def
                /dgs exch def
                exit
            } if
            /j j 8 add def
        } loop

        /dwo d dgs sub dte idiv delo dmwo getRSSwidths def
        /dwe d dgs sub dte mod dele dmwe getRSSwidths def

        /dw 8 array def        
        x 2 mod 0 eq {                    
            0 1 3 {
                /j exch def
                dw 7 j 2 mul sub dwo j get put
                dw 6 j 2 mul sub dwe j get put
            } for
        } {           
            0 1 3 {
                /j exch def
                dw j 2 mul dwo j get put
                dw j 2 mul 1 add dwe j get put
            } for
        } ifelse

        dxw x dw put

    } for
    
    /widths [
        dxw {{} forall} forall
    ] def

    /checkweights [
        77   96   32   81   27   9    3    1
        20   60   180  118  143  7    21   63
        205  209  140  117  39   13   145  189
        193  157  49   147  19   57   171  91
        132  44   85   169  197  136  186  62
        185  133  188  142  4    12   36   108
        50   87   29   80   97   173  128  113
        150  28   84   41   123  158  52   156
        166  196  206  139  187  203  138  46
        76   17   51   153  37   111  122  155
        146  119  110  107  106  176  129  43
        16   48   144  10   30   90   59   177
        164  125  112  178  200  137  116  109
        70   210  208  202  184  130  179  115
        190  204  68   93   31   151  191  134
        148  22   66   198  172  94   71   2
        40   154  192  64   162  54   18   6
        120  149  25   75   14   42   126  167
        175  199  207  69   23   78   26   79
        103  98   83   38   114  131  182  124
        159  53   88   170  127  183  61   161
        55   165  73   8    24   72   5    15
        89   100  174  58   160  194  135  45
    ] def
    
    /checksum 0 def
    0 1 widths length 1 sub {
        /i exch def
        /checksum checksum widths i get checkweights i get mul add def 
    } for
    /checksum checksum 211 mod datalen 3 sub 211 mul add def

    /i 0 def {
        checksum tab174 i get le {
            tab174 i 1 add 7 getinterval {} forall
            /cte exch def /cto exch def
            /cmwe exch def /cmwo exch def
            /cele exch def /celo exch def
            /cgs exch def
            exit
        } if
        /i i 8 add def
    } loop

    /cwo checksum cgs sub cte idiv celo cmwo getRSSwidths def
    /cwe checksum cgs sub cte mod cele cmwe getRSSwidths def
    
    /cw 8 array def        
    0 1 3 {
        /i exch def
        cw i 2 mul cwo i get put
        cw i 2 mul 1 add cwe i get put
    } for
    
    /finderwidths [
        1 8 4 1 1    1 1 4 8 1
        3 6 4 1 1    1 1 4 6 3
        3 4 6 1 1    1 1 6 4 3
        3 2 8 1 1    1 1 8 2 3
        2 6 5 1 1    1 1 5 6 2
        2 2 9 1 1    1 1 9 2 2
    ] def

    /finderseq [
        [0 1]
        [0 3 2]
        [0 5 2 7]
        [0 9 2 7 4]
        [0 9 2 7 6 11]
        [0 9 2 7 8 11 10]
        [0 1 2 3 4 5 6 7]
        [0 1 2 3 4 5 6 9 8]
        [0 1 2 3 4 5 6 9 10 11]
        [0 1 2 3 4 7 6 9 8 11 10]
    ] def

    /seq finderseq datalen 2 add 2 idiv 2 sub get def
    /fxw seq length array def
    0 1 seq length 1 sub {
        /x exch def
        fxw x finderwidths seq x get 5 mul 5 getinterval put
    } for
    
    /sbs [
        1
        cw {} forall
        0 1 datalen 1 sub {
            /i exch def
            i 2 mod 0 eq {fxw i 2 idiv get {} forall} if
            dxw i get {} forall
        } for
        1 1
    ] def
    
    % Return the arguments
    /retval 1 dict def
    retval (sbs) sbs put
    retval (bhs) [sbs length 1 add 2 idiv {height} repeat] put
    retval (bbs) [sbs length 1 add 2 idiv {0} repeat] put   
    retval (opt) useropts put
    retval

    end

} bind def
/rssexpanded load 0 1 dict put
% --END ENCODER rssexpanded--

% --BEGIN ENCODER code2of5--
% --DESC: Code 25
% --EXAM: 01234567
/code2of5 {

    % Thanks to Michael Landers

    0 begin                 % Confine variable to local scope

    /options exch def       % We are given an option string
    /useropts options def
    /barcode exch def       % We are given a barcode string

    /includecheck false def
    /includetext false def   % Enable/disable text
    /includecheckintext false def
    /textfont /Courier def
    /textsize 10 def
    /textpos -7 def
    /height 1 def
    
    % Parse the input options
    options {
        token false eq {exit} if dup length string cvs (=) search
        true eq {cvlit exch pop exch def} {cvlit true def} ifelse
    } loop
    
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textpos textpos cvr def
    /height height cvr def
    
    % Create an array containing the character mappings
    /encs
    [ (1111313111) (3111111131) (1131111131) (3131111111)
      (1111311131) (3111311111) (1131311111) (1111113131)
      (3111113111) (1131113111) (313111) (311131)
    ] def

    % Create a string of the available characters
    /barchars (0123456789) def

    /barlen barcode length def            % Length of the code

    includecheck {
        /sbs barlen 10 mul 22 add string def
        /txt barlen 1 add array def
    } {
        /sbs barlen 10 mul 12 add string def
        /txt barlen array def
    } ifelse
    
    % Put the start character
    sbs 0 encs 10 get putinterval

    /checksum 0 def
    
    0 1 barlen 1 sub {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                 % Discard true leaving pre
        length /indx exch def               % indx is the length of pre
        pop pop                             % Discard seek and post
        /enc encs indx get def              % Get the indxth encoding
        sbs i 10 mul 6 add enc putinterval  % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 14 mul 10 add textpos textfont textsize] put
        barlen i sub 2 mod 0 eq {
            /checksum checksum indx add def
        } {            
            /checksum checksum indx 3 mul add def
        } ifelse        
    } for
    
    % Put the checksum and end characters
    includecheck {
        /checksum 10 checksum 10 mod sub 10 mod def
        sbs barlen 10 mul 6 add encs checksum get putinterval
        sbs barlen 10 mul 16 add encs 11 get putinterval
        includecheckintext {
            txt barlen [barchars checksum 1 getinterval barlen 14 mul 10 add textpos textfont textsize] put
        } {            
            txt barlen [( ) barlen 14 mul 10 add textpos textfont textsize] put
        } ifelse
    } {
        sbs barlen 10 mul 6 add encs 11 get putinterval
    } ifelse
    
    % Return the arguments
    /retval 1 dict def
    retval (sbs) [sbs {48 sub} forall] put
    retval (bhs) [sbs length 1 add 2 idiv {height} repeat] put
    retval (bbs) [sbs length 1 add 2 idiv {0} repeat] put
    includetext {
        retval (txt) txt put
    } if
    retval (opt) useropts put
    retval

    end

} bind def
/code2of5 load 0 1 dict put
% --END ENCODER code2of5--

% --BEGIN ENCODER code11--
% --DESC: Code 11
% --EXAM: 0123456789
/code11 {

    0 begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /useropts options def
    /barcode exch def  % We are given a barcode string

    /includecheck false def
    /includetext false def
    /includecheckintext false def
    /textfont /Courier def
    /textsize 10 def
    /textpos -7 def
    /height 1 def
    
    % Parse the input options
    options {
        token false eq {exit} if dup length string cvs (=) search
        true eq {cvlit exch pop exch def} {cvlit true def} ifelse
    } loop
    
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textpos textpos cvr def
    /height height cvr def
    
    % Create an array containing the character mappings
    /encs
    [ (111131) (311131) (131131) (331111) (113131)
      (313111) (133111) (111331) (311311) (311111)
      (113111) (113311)
    ] def

    % Create a string of the available characters
    /barchars (0123456789-) def

    /barlen barcode length def        % Length of the code

    includecheck {
        barlen 10 ge {
            /sbs barlen 6 mul 24 add string def
            /txt barlen 2 add array def
        } {
            /sbs barlen 6 mul 18 add string def
            /txt barlen 1 add array def
        } ifelse
    } {
        /sbs barlen 6 mul 12 add string def
        /txt barlen array def
    } ifelse

    % Put the start character
    sbs 0 encs 10 get putinterval

    /checksum1 0 def /checksum2 0 def
    
    /xpos 8 def
    0 1 barlen 1 sub {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                % Discard true leaving pre
        length /indx exch def              % indx is the length of pre
        pop pop                            % Discard seek and post
        /enc encs indx get def             % Get the indxth encoding
        sbs i 6 mul 6 add enc putinterval  % Put encoded digit into sbs
        txt i [barcode i 1 getinterval xpos textpos textfont textsize] put
        0 1 5 {       % xpos+=width of the character
            /xpos exch enc exch get 48 sub xpos add def
        } for
        /checksum1 checksum1 barlen i sub 1 sub 10 mod 1 add indx mul add def
        /checksum2 checksum2 barlen i sub 9 mod 1 add indx mul add def
    } for
   
    % Put the checksum and end characters
    includecheck {
        /checksum1 checksum1 11 mod def        
        barlen 10 ge {
            /checksum2 checksum2 checksum1 add 11 mod def
            sbs barlen 6 mul 6 add encs checksum1 get putinterval        
            sbs barlen 6 mul 12 add encs checksum2 get putinterval
            includecheckintext {
                txt barlen [barchars checksum1 1 getinterval xpos textpos textfont textsize] put
                /enc encs checksum1 get def   
                0 1 5 {       % xpos+=width of the character
                    /xpos exch enc exch get 48 sub xpos add def
                } for
                txt barlen 1 add [barchars checksum2 1 getinterval xpos textpos textfont textsize] put
            } {
                txt barlen [() xpos textpos textfont textsize] put
                txt barlen 1 add [() xpos textpos textfont textsize] put
            } ifelse
            sbs barlen 6 mul 18 add encs 11 get putinterval
        } {
            sbs barlen 6 mul 6 add encs checksum1 get putinterval          
            includecheckintext {
                txt barlen [barchars checksum1 1 getinterval xpos textpos textfont textsize] put
            } {
                txt barlen [() xpos textpos textfont textsize] put
            } ifelse
            sbs barlen 6 mul 12 add encs 11 get putinterval
        } ifelse
    } {
        sbs barlen 6 mul 6 add encs 11 get putinterval
    } ifelse

    % Return the arguments
    /retval 1 dict def
    retval (sbs) [sbs {48 sub} forall] put
    retval (bhs) [sbs length 1 add 2 idiv {height} repeat] put
    retval (bbs) [sbs length 1 add 2 idiv {0} repeat] put
    includetext {
        retval (txt) txt put
    } if
    retval (opt) useropts put
    retval

    end

} bind def
/code11 load 0 1 dict put
% --END ENCODER code11--

% --BEGIN ENCODER rationalizedCodabar--
% --DESC: Rationalized Codabar
% --EXAM: A0123456789B
/rationalizedCodabar {

    0 begin                    % Confine variables to local scope

    /options exch def          % We are given an option string
    /useropts options def
    /barcode exch def          % We are given a barcode string

    /includecheck false def     % Enable/disable checkdigit
    /includetext false def      % Enable/disable text
    /includecheckintext false def
    /textfont /Courier def
    /textsize 10 def
    /textpos -7 def
    /height 1 def
    
    % Parse the input options
    options {
        token false eq {exit} if dup length string cvs (=) search
        true eq {cvlit exch pop exch def} {cvlit true def} ifelse
    } loop
    
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textpos textpos cvr def
    /height height cvr def
    
    % Create an array containing the character mappings
    /encs
    [ (11111331) (11113311) (11131131) (33111111) (11311311)
      (31111311) (13111131) (13113111) (13311111) (31131111)
      (11133111) (11331111) (31113131) (31311131) (31313111)
      (11313131) (11331311) (13131131) (11131331) (11133311)
    ] def

    % Create a string of the available characters
    /barchars (0123456789-$:/.+ABCD) def

    /barlen barcode length def    % Length of the code

    includecheck {
        /sbs barlen 8 mul 8 add string def
        /txt barlen 1 add array def
    } {
        /sbs barlen 8 mul string def
        /txt barlen array def
    } ifelse

    /checksum 0 def
    /xpos 0 def
    0 1 barlen 2 sub {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                          % Discard true leaving pre
        length /indx exch def        % indx is the length of pre
        pop pop                      % Discard seek and post
        /enc encs indx get def       % Get the indxth encoding
        sbs i 8 mul enc putinterval  % Put encoded digit into sbs
        txt i [barcode i 1 getinterval xpos textpos textfont textsize] put
        0 1 7 {       % xpos+=width of the character
            /xpos exch enc exch get 48 sub xpos add def
        } for
        /checksum checksum indx add def
    } for

    % Find index of last character
    barcode barlen 1 sub 1 getinterval barchars exch search
    pop                          % Discard true leaving pre
    length /indx exch def        % indx is the length of pre
    pop pop                      % Discard seek and post

    includecheck {
        % Put the checksum character
        /checksum checksum indx add def
        /checksum 16 checksum 16 mod sub 16 mod def
        sbs barlen 8 mul 8 sub encs checksum get putinterval
        includecheckintext {
            txt barlen 1 sub [barchars checksum 1 getinterval xpos textpos textfont textsize] put
        } {
            txt barlen 1 sub [( ) xpos textpos textfont textsize] put
        } ifelse
        0 1 7 {       % xpos+=width of the character
            /xpos exch encs checksum get exch get 48 sub xpos add def
        } for
        % Put the end character
        /enc encs indx get def            % Get the indxth encoding
        sbs barlen 8 mul enc putinterval  % Put encoded digit into sbs
        txt barlen [barcode barlen 1 sub 1 getinterval xpos textpos textfont textsize] put
    } {
        % Put the end character
        /enc encs indx get def                  % Get the indxth encoding
        sbs barlen 8 mul 8 sub enc putinterval  % Put encoded digit into sbs
        txt barlen 1 sub [barcode barlen 1 sub 1 getinterval xpos textpos textfont textsize] put
    } ifelse

    % Return the arguments
    /retval 1 dict def
    retval (sbs) [sbs {48 sub} forall] put
    retval (bhs) [sbs length 1 add 2 idiv {height} repeat] put
    retval (bbs) [sbs length 1 add 2 idiv {0} repeat] put
    includetext {
        retval (txt) txt put
    } if
    retval (opt) useropts put
    retval

    end

} bind def
/rationalizedCodabar load 0 1 dict put
% --END ENCODER rationalizedCodabar--

% --BEGIN ENCODER onecode--
% --DESC: United States Postal Service OneCode
% --EXAM: 0123456709498765432101234567891
/onecode {

    0 begin

    /options exch def              % We are given an option string
    /useropts options def
    /barcode exch def              % We are given a barcode string

    /height 0.175 def
    
    % Parse the input options
    options {
        token false eq {exit} if dup length string cvs (=) search
        true eq {cvlit exch pop exch def} {cvlit true def} ifelse
    } loop
    
    /height height cvr def

    /barlen barcode length def

    /normalize {
        /base exch def
        /num exch def
        num length 1 sub -1 1 {
            /i exch def        
            num i 1 sub 2 copy get num i get base idiv add put
            num i num i get base mod put
        } for
        { %loop - extend input as necessary
            num 0 get base lt {exit} if
            /num [0 num {} forall] def        
            num 0 num 0 get num 1 get base idiv add put
            num 1 num 1 get base mod put
        } loop
        % Trim leading zeros
        /num [/i true def num {dup 0 eq i and {pop} {/i false def} ifelse} forall] def   
        num length 0 eq {/num [0] def} if
        num
    } bind def

    /bigadd {
        2 copy length exch length
        2 copy sub abs /offset exch def
        lt {exch} if
        /a exch def /b exch def    
        0 1 b length 1 sub {
            dup a exch offset add 2 copy get b 5 -1 roll get add put
        } for
        a
    } bind def

    % Conversion of data fields into binary data
    barlen 20 eq {[0]} if
    barlen 25 eq {[1]} if
    barlen 29 eq {[1 0 0 0 0 1]} if
    barlen 31 eq {[1 0 0 0 1 0 0 0 0 1]} if
    /binval exch [barcode 20 barlen 20 sub getinterval {48 sub} forall] bigadd def
    /binval [binval {} forall barcode 0 get 48 sub] def
    /binval [binval {5 mul} forall] [barcode 1 get 48 sub] bigadd 10 normalize def
    /binval [binval {} forall barcode 2 18 getinterval {48 sub} forall] def

    % Conversion of binary data into byte array
    /bytes 13 array def
    /bintmp [binval {} forall] def
    12 -1 0 {
        /i exch def
        0 1 bintmp length 2 sub {
            /j exch def
            bintmp j 1 add 2 copy get bintmp j get 256 mod 10 mul add put
            bintmp j bintmp j get 256 idiv put
        } for
        bytes i bintmp bintmp length 1 sub get 256 mod put
        bintmp bintmp length 1 sub 2 copy get 256 idiv put    
    } for

    % Generation of 11-bit CRC on byte array
    /fcs 2047 def
    /dat bytes 0 get 5 bitshift def
    6 {
        fcs dat xor 1024 and 0 ne {
            /fcs fcs 1 bitshift 3893 xor def 
        } {
            /fcs fcs 1 bitshift def
        } ifelse
        /fcs fcs 2047 and def
        /dat dat 1 bitshift def
    } repeat
    1 1 12 {
        bytes exch get 3 bitshift /dat exch def    
        8 {        
            fcs dat xor 1024 and 0 ne {
                /fcs fcs 1 bitshift 3893 xor def 
            } {
                /fcs fcs 1 bitshift def
            } ifelse
            /fcs fcs 2047 and def
            /dat dat 1 bitshift def
        } repeat
    } for

    % Conversion from binary data to codewords
    /codewords 10 array def
    9 -1 0 {
        /i exch def
        i 9 eq {
            /b 636 def
        } {
            /b 1365 def
        } ifelse
        0 1 binval length 2 sub {
            /j exch def
            binval j 1 add 2 copy get binval j get b mod 10 mul add put
            binval j binval j get b idiv put
        } for   
        codewords i binval binval length 1 sub get b mod put
        binval binval length 1 sub 2 copy get b idiv put
    } for

    % Inserting additional information into codewords
    codewords 9 codewords 9 get 2 mul put
    fcs 1024 and 0 ne {
        codewords 0 codewords 0 get 659 add put
    } if

    % Conversion from codewords to characters
    /tab513 1287 dict def
    /lo 0 def
    /hi 1286 def
    0 1 8191 {   
        { % no loop - provides common exit point
            /i exch def
            /onbits 0 def
            0 1 12 {           
                i exch 1 exch bitshift and 0 ne {
                    /onbits onbits 1 add def
                } if
            } for
            onbits 5 ne {exit} if
            /j i def
            /rev 0 def
            16 {            
                /rev rev 1 bitshift j 1 and or def
                /j j -1 bitshift def                
            } repeat          
            /rev rev -3 bitshift def            
            rev i lt {exit} if
            rev i eq {
                tab513 hi i put
                /hi hi 1 sub def
            } {
                tab513 lo i put
                tab513 lo 1 add rev put
                /lo lo 2 add def                      
            } ifelse
            exit
        } loop
    } for

    /tab213 78 dict def
    /lo 0 def
    /hi 77 def
    0 1 8191 {   
        { % no loop - provides common exit point
            /i exch def
            /onbits 0 def
            0 1 12 {           
                i exch 1 exch bitshift and 0 ne {
                    /onbits onbits 1 add def
                } if
            } for
            onbits 2 ne {exit} if
            /j i def
            /rev 0 def
            16 {            
                /rev rev 1 bitshift j 1 and or def
                /j j -1 bitshift def                
            } repeat          
            /rev rev -3 bitshift def            
            rev i lt {exit} if
            rev i eq {
                tab213 hi i put
                /hi hi 1 sub def
            } {
                tab213 lo i put
                tab213 lo 1 add rev put
                /lo lo 2 add def                      
            } ifelse
            exit
        } loop
    } for

    /chars 10 array def
    0 1 9 {
        /i exch def
        codewords i get dup 1286 le {
            tab513 exch get 
        } {
            tab213 exch 1287 sub get
        } ifelse
        chars i 3 -1 roll put
    } for

    9 -1 0 {
        /i exch def
        2 i exp cvi fcs and 0 ne {
            chars i chars i get 8191 xor put
        } if
    } for

    % Conversion from characters to the OneCode encoding
    /barmap [
        7 2 4 3    1 10 0 0   9 12 2 8   5 5 6 11   8 9 3 1
        0 1 5 12   2 5 1 8    4 4 9 11   6 3 8 10   3 9 7 6
        5 11 1 4   8 5 2 12   9 10 0 2   7 1 6 7    3 6 4 9
        0 3 8 6    6 4 2 7    1 1 9 9    7 10 5 2   4 0 3 8
        6 2 0 4    8 11 1 0   9 8 3 12   2 6 7 7    5 1 4 10
        1 12 6 9   7 3 8 0    5 8 9 7    4 6 2 10   3 4 0 5
        8 4 5 7    7 11 1 9   6 0 9 6    0 6 4 8    2 1 3 2
        5 9 8 12   4 11 6 1   9 5 7 4    3 3 1 2    0 7 2 0
        1 3 4 1    6 10 3 5   8 7 9 4    2 11 5 6   0 8 7 12
        4 2 8 1    5 10 3 0   9 3 0 9    6 5 2 4    7 8 1 7
        5 0 4 5    2 3 0 10   6 12 9 2   3 11 1 6   8 8 7 9
        5 4 0 11   1 5 2 2    9 1 4 12   8 3 6 6    7 0 3 7
        4 7 7 5    0 12 1 11  2 9 9 0    6 8 5 3    3 10 8 2
    ] def

    /bbs 65 array def    
    /bhs 65 array def
    0 1 64 {
        /i exch def
        /dec chars barmap i 4 mul get get 2 barmap i 4 mul 1 add get exp cvi and 0 ne def
        /asc chars barmap i 4 mul 2 add get get 2 barmap i 4 mul 3 add get exp cvi and 0 ne def
        dec not asc not and {
            bbs i 3 height mul 8 div put
            bhs i 2 height mul 8 div put
        } if
        dec not asc and {
            bbs i 3 height mul 8 div put
            bhs i 5 height mul 8 div put        
        } if
        dec asc not and {
            bbs i 0 height mul 8 div put
            bhs i 5 height mul 8 div put        
        } if
        dec asc and {
            bbs i 0 height mul 8 div put
            bhs i 8 height mul 8 div put        
        } if
    } for
    
    /retval 4 dict def
    retval (bbs) bbs put
    retval (bhs) bhs put
    retval (sbs) [bhs length 1 sub {1.44 1.872} repeat 1.44] put    
    retval (opt) useropts put
    retval

    end

} bind def
/onecode load 0 1 dict put
% --END ENCODER onecode--

% --BEGIN ENCODER postnet--
% --DESC: United States Postal Service Postnet
% --EXAM: 012345
/postnet {

    % Thanks to Ross McFarland

    0 begin

    /options exch def              % We are given an option string
    /useropts options def
    /barcode exch def              % We are given a barcode string

    /includetext false def          % Enable/disable text
    /includecheckintext false def
    /textfont /Courier def
    /textsize 10 def
    /textpos -7 def
    /height 0.125 def
    
    % Parse the input options
    options {
        token false eq {exit} if dup length string cvs (=) search
        true eq {cvlit exch pop exch def} {cvlit true def} ifelse
    } loop
    
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textpos textpos cvr def
    /height height cvr def
    
    /barlen barcode length def

    % Create an array containing the character mappings
    /encs
    [ (55222) (22255) (22525) (22552) (25225)
      (25252) (25522) (52225) (52252) (52522)
      (5) (5)
    ] def

    % Create a string of the available characters
    /barchars (0123456789) def

    /bhs barlen 5 mul 7 add array def
    /txt barlen 1 add array def

    % Put start character
    /enc encs 10 get def
    /heights enc length array def
    0 1 enc length 1 sub {
        /j exch def
        heights j enc j 1 getinterval cvi height mul 5 div put
    } for
    bhs 0 heights putinterval   % Put encoded digit into sbs

    /checksum 0 def
    0 1 barlen 1 sub {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                 % Discard true leaving pre
        length /indx exch def               % indx is the length of pre
        pop pop                             % Discard seek and post
        /enc encs indx get def              % Get the indxth encoding
        /heights enc length array def
        0 1 enc length 1 sub {
            /j exch def
            heights j enc j 1 getinterval cvi height mul 5 div put
        } for
        bhs i 5 mul 1 add heights putinterval   % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 5 mul 1 add 3.312 mul textpos textfont textsize] put
        /checksum checksum indx add def     % checksum+=indx
    } for

    % Put the checksum character
    /checksum 10 checksum 10 mod sub 10 mod def
    /enc encs checksum get def
    /heights enc length array def
    0 1 enc length 1 sub {
        /j exch def
        heights j enc j 1 getinterval cvi height mul 5 div put
    } for
    bhs barlen 5 mul 1 add heights putinterval  
    
    includecheckintext {
        txt barlen [barchars checksum 1 getinterval barlen 5 mul 1 add 3.312 mul textpos textfont textsize] put
    } {
        txt barlen [( ) barlen 5 mul 1 add 72 mul 25 div textpos textfont textsize] put
    } ifelse
    
    % Put end character
    /enc encs 11 get def
    /heights enc length array def
    0 1 enc length 1 sub {
        /j exch def
        heights j enc j 1 getinterval cvi height mul 5 div put
    } for
    bhs barlen 5 mul 6 add heights putinterval  

    /retval 1 dict def
    retval (bhs) bhs put
    retval (bbs) [bhs length {0} repeat] put
    retval (sbs) [bhs length 1 sub {1.44 1.872} repeat 1.44] put
    includetext {
        retval (txt) txt put
    } if
    retval (opt) useropts put
    retval

    end

} bind def
/postnet load 0 1 dict put
% --END ENCODER postnet--

% --BEGIN ENCODER royalmail--
% --DESC: Royal Mail 4 State Customer Code (RM4SCC)
% --EXAM: LE28HS9Z
/royalmail {

    0 begin

    /options exch def              % We are given an option string
    /useropts options def
    /barcode exch def              % We are given a barcode string

    /includetext false def          % Enable/disable text
    /includecheckintext false def
    /textfont /Courier def
    /textsize 10 def
    /textpos -7 def
    /height 0.175 def
    
    % Parse the input options
    options {
        token false eq {exit} if dup length string cvs (=) search
        true eq {cvlit exch pop exch def} {cvlit true def} ifelse
    } loop
    
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textpos textpos cvr def
    /height height cvr def
    
    % Create an array containing the character mappings
    /encs
    [ (3300) (2211) (2301) (2310) (3201) (3210) 
      (1122) (0033) (0123) (0132) (1023) (1032) 
      (1302) (0213) (0303) (0312) (1203) (1212) 
      (1320) (0231) (0321) (0330) (1221) (1230) 
      (3102) (2013) (2103) (2112) (3003) (3012) 
      (3120) (2031) (2121) (2130) (3021) (3030) 
      (2) (3)
    ] def

    % Create a string of the available characters
    /barchars (ZUVWXY501234B6789AHCDEFGNIJKLMTOPQRS) def

    /barlen barcode length def
    /encstr barlen 4 mul 6 add string def
    /txt barlen 1 add array def

    % Put start character
    encstr 0 encs 36 get putinterval
    
    /checksumrow 0 def
    /checksumcol 0 def
    0 1 barlen 1 sub {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                 % Discard true leaving pre
        length /indx exch def               % indx is the length of pre
        pop pop                             % Discard seek and post
        /enc encs indx get def              % Get the indxth encoding
        encstr i 4 mul 1 add enc putinterval
        txt i [barcode i 1 getinterval i 4 mul 1 add 3.312 mul textpos textfont textsize] put
        /checksumrow checksumrow indx 6 idiv add def
        /checksumcol checksumcol indx 6 mod add def 
    } for

    % Put the checksum character
    /checksum checksumrow 6 mod 6 mul checksumcol 6 mod add def
    /enc encs checksum get def
    encstr barlen 4 mul 1 add enc putinterval
    includecheckintext {
        txt barlen [barchars checksum 1 getinterval barlen 4 mul 1 add 3.312 mul textpos textfont textsize] put
    } {
        txt barlen [( ) barlen 4 mul 1 add 3.312 mul textpos textfont textsize] put
    } ifelse
    
    % Put end character
    encstr barlen 4 mul 5 add encs 37 get putinterval  

    /bbs encstr length array def    
    /bhs encstr length array def
    0 1 encstr length 1 sub {
        /i exch def
        /enc encstr i 1 getinterval def
        enc (0) eq {
            bbs i 3 height mul 8 div put
            bhs i 2 height mul 8 div put
        } if
        enc (1) eq {
            bbs i 0 height mul 8 div put
            bhs i 5 height mul 8 div put
        } if
        enc (2) eq {
            bbs i 3 height mul 8 div put
            bhs i 5 height mul 8 div put
        } if
        enc (3) eq {
            bbs i 0 height mul 8 div put
            bhs i 8 height mul 8 div put
        } if
    } for
    
    /retval 4 dict def
    retval (bbs) bbs put
    retval (bhs) bhs put
    retval (sbs) [bhs length 1 sub {1.44 1.872} repeat 1.44] put
    includetext {
        retval (txt) txt put
    } if
    retval (opt) useropts put
    retval

    end

} bind def
/royalmail load 0 1 dict put
% --END ENCODER royalmail--

% --BEGIN ENCODER auspost--
% --DESC: AusPost 4 State Customer Code
% --EXAM: 5956439111ABA 9
/auspost {

    0 begin

    /options exch def              % We are given an option string
    /useropts options def
    /barcode exch def              % We are given a barcode string

    /includetext false def         % Enable/disable text
    /textfont /Courier def
    /textsize 10 def
    /textpos -7 def
    /height 0.175 def
    /custinfoenc (character) def
    
    % Parse the input options
    options {
        token false eq {exit} if dup length string cvs (=) search
        true eq {cvlit exch pop exch def} {cvlit true def} ifelse
    } loop
    
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textpos textpos cvr def
    /height height cvr def

    % Create an array containing the character mappings
    /encs
    [ (000) (001) (002) (010) (011) (012) (020) (021)
      (022) (100) (101) (102) (110) (111) (112) (120)
      (121) (122) (200) (201) (202) (210) (211) (212)
      (220) (221) (222) (300) (301) (302) (310) (311)
      (312) (320) (321) (322) (023) (030) (031) (032)
      (033) (103) (113) (123) (130) (131) (132) (133)
      (203) (213) (223) (230) (231) (232) (233) (303)
      (313) (323) (330) (331) (332) (333) (003) (013)
      (00) (01) (02) (10) (11) (12) (20) (21) (22) (30)
      (13) (3)
    ] def

    % Create a string of the available characters
    /barchars (ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz #) def
    
    /barlen barcode length def
    barcode 0 2 getinterval (11) eq {37} if
    barcode 0 2 getinterval (59) eq {52} if
    barcode 0 2 getinterval (62) eq {67} if
    /encstr exch string def
    /txt barlen 2 sub array def

    % Put start character
    encstr 0 encs 74 get putinterval

    % Encode the FCC
    0 1 1 {
        /i exch def       
        encs barcode i 1 getinterval cvi 64 add get
        encstr i 2 mul 2 add 3 2 roll putinterval
    } for
    
    % Encode the DPID
    2 1 9 {
        /i exch def       
        encs barcode i 1 getinterval cvi 64 add get
        encstr i 2 mul 2 add 3 2 roll putinterval
        txt i 2 sub [barcode i 1 getinterval i 2 sub 2 mul 6 add 3.312 mul textpos textfont textsize] put
    } for
    
    % Encode the customer information   
    custinfoenc (numeric) eq {
        0 1 barlen 11 sub {
            /i exch def
            encs barcode i 10 add 1 getinterval cvi 64 add get
            encstr i 2 mul 22 add 3 2 roll putinterval
            txt i 8 add [barcode i 10 add 1 getinterval i 2 mul 22 add 3.312 mul textpos textfont textsize] put
        } for        
        /ciflen barlen 10 sub 2 mul def
    } {
        0 1 barlen 11 sub {
            /i exch def           
            barcode i 10 add 1 getinterval barchars exch search
            pop                                
            length /indx exch def           
            pop pop                            
            /enc encs indx get def          
            encstr i 3 mul 22 add enc putinterval
            txt i 8 add [barcode i 10 add 1 getinterval i 3 mul 22 add 3.312 mul textpos textfont textsize] put
        } for        
        /ciflen barlen 10 sub 3 mul def
    } ifelse

    % Add any filler characters
    22 ciflen add 1 encstr length 14 sub {        
        encstr exch encs 75 get putinterval
    } for
    
    % Create the 64x64 Reed-Solomon table
    /rstable 64 64 mul array def
    rstable 0 [ 64 {0} repeat ] putinterval
    rstable 64 [ 0 1 63 {} for ] putinterval
    /prev 1 def
    64 {       
        /next prev 1 bitshift def
        next 64 and 0 ne {
            /next next 67 xor def
        } if        
        0 1 63 {
            /j exch def
            /nextcell {rstable 64 next mul j add} def
            nextcell rstable 64 prev mul j add get 1 bitshift put
            nextcell get 64 and 0 ne {
                nextcell nextcell get 67 xor put
            } if
        } for
        /prev next def
    } repeat
    
    % Calculate the Reed-Solomon codes for triples
    /rscodes encstr length 16 sub 3 idiv 4 add array def
    rscodes 0 [ 4 {0} repeat ] putinterval
    2 3 encstr length 16 sub {
        /i exch def
        rscodes rscodes length i 2 sub 3 idiv sub 1 sub
        encstr i 1 getinterval cvi 16 mul
        encstr i 1 add 1 getinterval cvi 4 mul add
        encstr i 2 add 1 getinterval cvi add        
        put
    } for    
    rscodes length 5 sub -1 0 {
       /i exch def
       0 1 4 {
           /j exch def
           rscodes i j add rscodes i j add get
           rstable 64 [48 17 29 30 1] j get mul rscodes i 4 add get add get
           xor put
       } for
    } for
    /checkcode (000000000000) def
    0 1 3 {
        /i exch def
        /enc rscodes 3 i sub get 4 3 string cvrs def
        checkcode i 3 mul 3 enc length sub add enc putinterval
    } for
    
    % Put checkcode and end characters
    encstr encstr length 14 sub checkcode putinterval
    encstr encstr length 2 sub encs 74 get putinterval 

    /bbs encstr length array def    
    /bhs encstr length array def
    0 1 encstr length 1 sub {
        /i exch def
        /enc encstr i 1 getinterval def
        enc (0) eq {
            bbs i 0 height mul 8 div put
            bhs i 8 height mul 8 div put
        } if
        enc (1) eq {
            bbs i 3 height mul 8 div put
            bhs i 5 height mul 8 div put
        } if
        enc (2) eq {
            bbs i 0 height mul 8 div put
            bhs i 5 height mul 8 div put
        } if
        enc (3) eq {
            bbs i 3 height mul 8 div put
            bhs i 2 height mul 8 div put
        } if
    } for   
    
    /retval 4 dict def
    retval (bbs) bbs put
    retval (bhs) bhs put
    retval (sbs) [bhs length 1 sub {1.44 1.872} repeat 1.44] put
    includetext {
        retval (txt) txt put
    } if
    retval (opt) useropts put
    retval

    end

} bind def
/auspost load 0 1 dict put
% --END ENCODER auspost--

% --BEGIN ENCODER kix--
% --DESC: Royal Dutch TPG Post KIX 4-State Barcode
% --EXAM: 1231FZ13XHS
/kix {

    0 begin

    /options exch def              % We are given an option string
    /useropts options def
    /barcode exch def              % We are given a barcode string

    /includetext false def          % Enable/disable text
    /includecheckintext false def
    /textfont /Courier def
    /textsize 10 def
    /textpos -7 def
    /height 0.175 def
    
    % Parse the input options
    options {
        token false eq {exit} if dup length string cvs (=) search
        true eq {cvlit exch pop exch def} {cvlit true def} ifelse
    } loop
    
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textpos textpos cvr def
    /height height cvr def
    
    % Create an array containing the character mappings
    /encs
    [ (0033) (0123) (0132) (1023) (1032) (1122)
      (0213) (0303) (0312) (1203) (1212) (1302) 
      (0231) (0321) (0330) (1221) (1230) (1320)
      (2013) (2103) (2112) (3003) (3012) (3102)
      (2031) (2121) (2130) (3021) (3030) (3120) 
      (2211) (2301) (2310) (3201) (3210) (3300) 
    ] def

    % Create a string of the available characters
    /barchars (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ) def

    /barlen barcode length def
    /encstr barlen 4 mul string def
    /txt barlen array def
    
    0 1 barlen 1 sub {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                 % Discard true leaving pre
        length /indx exch def               % indx is the length of pre
        pop pop                             % Discard seek and post
        /enc encs indx get def              % Get the indxth encoding
        encstr i 4 mul enc putinterval
        txt i [barcode i 1 getinterval i 4 mul 3.312 mul textpos textfont textsize] put
    } for

    /bbs encstr length array def    
    /bhs encstr length array def
    0 1 encstr length 1 sub {
        /i exch def
        /enc encstr i 1 getinterval def
        enc (0) eq {
            bbs i 3 height mul 8 div put
            bhs i 2 height mul 8 div put
        } if
        enc (1) eq {
            bbs i 0 height mul 8 div put
            bhs i 5 height mul 8 div put
        } if
        enc (2) eq {
            bbs i 3 height mul 8 div put
            bhs i 5 height mul 8 div put
        } if
        enc (3) eq {
            bbs i 0 height mul 8 div put
            bhs i 8 height mul 8 div put
        } if
    } for
    
    /retval 4 dict def
    retval (bbs) bbs put
    retval (bhs) bhs put
    retval (sbs) [bhs length 1 sub {1.44 1.872} repeat 1.44] put
    includetext {
        retval (txt) txt put
    } if
    retval (opt) useropts put
    retval

    end

} bind def
/kix load 0 1 dict put
% --END ENCODER kix--

% --BEGIN ENCODER msi--
% --DESC: MSI Modified Plessey
% --EXAM: 0123456789
/msi {

    0 begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /useropts options def
    /barcode exch def       % We are given a barcode string

    /includecheck false def  % Enable/disable checkdigit
    /includetext false def   % Enable/disable text
    /includecheckintext false def
    /textfont /Courier def
    /textsize 10 def
    /textpos -7 def
    /height 1 def
    
    % Parse the input options
    options {
        token false eq {exit} if dup length string cvs (=) search
        true eq {cvlit exch pop exch def} {cvlit true def} ifelse
    } loop
    
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textpos textpos cvr def
    /height height cvr def
    
    % Create an array containing the character mappings
    /encs
    [ (13131313) (13131331) (13133113) (13133131) (13311313)
      (13311331) (13313113) (13313131) (31131313) (31131331)
      (31) (131)
    ] def

    % Create a string of the available characters
    /barchars (0123456789) def

    /barlen barcode length def     % Length of the code

    includecheck {
        /sbs barlen 8 mul 13 add string def
        /txt barlen 1 add array def
    } {
        /sbs barlen 8 mul 5 add string def
        /txt barlen array def
    } ifelse


    % Put start character
    sbs 0 encs 10 get putinterval
    /checksum 0 def

    0 1 barlen 1 sub {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                % Discard true leaving pre
        length /indx exch def              % indx is the length of pre
        pop pop                            % Discard seek and post
        /enc encs indx get def             % Get the indxth encoding
        sbs i 8 mul 2 add enc putinterval  % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 16 mul 4 add textpos textfont textsize] put
        barlen i sub 2 mod 0 eq {
            /checksum indx checksum add def
        } {
            /checksum indx 2 mul dup 10 idiv add checksum add def
        } ifelse
    } for

    % Put the checksum and end characters
    includecheck {
        /checksum 10 checksum 10 mod sub 10 mod def
        sbs barlen 8 mul 2 add encs checksum get putinterval
        includecheckintext {
            txt barlen [barchars checksum 1 getinterval barlen 16 mul 4 add textpos textfont textsize] put
        } {
            txt barlen [( ) barlen 16 mul 4 add textpos textfont textsize] put
        } ifelse
        sbs barlen 8 mul 10 add encs 11 get putinterval
    } {
        sbs barlen 8 mul 2 add encs 11 get putinterval
    } ifelse

    % Return the arguments
    /retval 1 dict def
    retval (sbs) [sbs {48 sub} forall] put
    retval (bhs) [sbs length 1 add 2 idiv {height} repeat] put
    retval (bbs) [sbs length 1 add 2 idiv {0} repeat] put
    includetext {
        retval (txt) txt put
    } if
    retval (opt) useropts put
    retval

    end

} bind def
/msi load 0 1 dict put
% --END ENCODER msi--

% --BEGIN ENCODER plessey--
% --DESC: Plessey
% --EXAM: 01234ABCD
/plessey {

    0 begin                  % Confine variables to local scope

    /options exch def        % We are given an option string
    /useropts options def
    /barcode exch def        % We are given a barcode string

    /includetext false def    % Enable/disable text
    /includecheckintext false def
    /textfont /Courier def
    /textsize 10 def
    /textpos -7 def
    /height 1 def
    
    % Parse the input options
    options {
        token false eq {exit} if dup length string cvs (=) search
        true eq {cvlit exch pop exch def} {cvlit true def} ifelse
    } loop
    
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textpos textpos cvr def
    /height height cvr def
    
    % Create an array containing the character mappings
    /encs
    [ (13131313) (31131313) (13311313) (31311313)
      (13133113) (31133113) (13313113) (31313113)
      (13131331) (31131331) (13311331) (31311331)
      (13133131) (31133131) (13313131) (31313131)
      (31311331) (331311313)
    ] def

    % Create a string of the available characters
    /barchars (0123456789ABCDEF) def

    /barlen barcode length def     % Length of the code
    /sbs barlen 8 mul 33 add string def
    /txt barlen 2 add array def
    /checkbits barlen 4 mul 8 add array def
    checkbits barlen 4 mul [ 0 0 0 0 0 0 0 0 ] putinterval

    % Put start character
    sbs 0 encs 16 get putinterval

    0 1 barlen 1 sub {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                % Discard true leaving pre
        length /indx exch def              % indx is the length of pre
        pop pop                            % Discard seek and post
        /enc encs indx get def             % Get the indxth encoding
        sbs i 8 mul 8 add enc putinterval  % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 16 mul 16 add textpos textfont textsize] put
        checkbits i 4 mul [
                indx 1 and
                indx -1 bitshift 1 and
                indx -2 bitshift 1 and
                indx -3 bitshift
        ] putinterval
    } for

    % Checksum is last 8 bits of a CRC using a salt
    /checksalt [ 1 1 1 1 0 1 0 0 1 ] def
    0 1 barlen 4 mul 1 sub {
        /i exch def
        checkbits i get 1 eq {
            0 1 8 {
                /j exch def
                checkbits i j add checkbits i j add get checksalt j get xor put
            } for
        } if
    } for

    % Calculate the value of the checksum digits
    /checkval 0 def
    0 1 7 {
        /i exch def
        /checkval checkval 2 7 i sub exp cvi checkbits barlen 4 mul i add get mul add def
    } for

    % Put the checksum characters
    /checksum1 checkval -4 bitshift def
    /checksum2 checkval 15 and def
    sbs barlen 8 mul 8 add encs checksum1 get putinterval
    sbs barlen 8 mul 16 add encs checksum2 get putinterval
    includecheckintext {
        txt barlen [barchars checksum1 1 getinterval barlen 16 mul 16 add textpos textfont textsize] put
        txt barlen 1 add [barchars checksum2 1 getinterval barlen 1 add 16 mul 16 add textpos textfont textsize] put
    } {
        txt barlen [( ) barlen 16 mul 16 add textpos textfont textsize] put
        txt barlen 1 add [( ) barlen 1 add 16 mul 16 add textpos textfont textsize] put
    } ifelse

    % Put end character
    sbs barlen 8 mul 24 add encs 17 get putinterval

    % Return the arguments
    /retval 1 dict def
    retval (sbs) [sbs {48 sub} forall] put
    retval (bhs) [sbs length 1 add 2 idiv {height} repeat] put
    retval (bbs) [sbs length 1 add 2 idiv {0} repeat] put
    includetext {
        retval (txt) txt put
    } if
    retval (opt) useropts put
    retval

    end

} bind def
/plessey load 0 1 dict put
% --END ENCODER plessey--

% --BEGIN ENCODER raw--
% --DESC: Raw bar space succession for custom symbologies 
% --EXAM: 331132131313411122131311333213114131131221323
/raw {

    0 begin                  % Confine variables to local scope

    /options exch def        % We are given an option string
    /useropts options def
    /sbs exch def        % We are given a barcode string

    /height 1 def

    % Parse the input options
    options {
        token false eq {exit} if dup length string cvs (=) search
        true eq {cvlit exch pop exch def} {cvlit true def} ifelse
    } loop
    /height height cvr def

    % Return the arguments
    /retval 1 dict def
    retval (sbs) [sbs {48 sub} forall] put
    retval (bhs) [sbs length 1 add 2 idiv {height} repeat] put
    retval (bbs) [sbs length 1 add 2 idiv {0} repeat] put 
    retval (opt) useropts put
    retval

    end

} bind def
/raw load 0 1 dict put
% --END ENCODER raw--

% --BEGIN ENCODER symbol--
% --DESC: Miscellaneous symbols
% --EXAM: fima
/symbol {

    0 begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    barcode (fima) eq {
        /sbs [2.25 2.25 2.25 11.25 2.25 11.25 2.25 2.25 2.25] def
        /bhs [.625 .625 .625 .625 .625] def
        /bbs [0 0 0 0 0] def
    } if

    barcode (fimb) eq {
        /sbs [2.25 6.75 2.25 2.25 2.25 6.25 2.25 2.25 2.25 6.75 2.25] def
        /bhs [.625 .625 .625 .625 .625 .625] def
        /bbs [0 0 0 0 0 0] def
    } if

    barcode (fimc) eq {
        /sbs [2.25 2.25 2.25 6.75 2.25 6.75 2.25 6.75 2.25 2.25 2.25] def
        /bhs [.625 .625 .625 .625 .625 .625] def
        /bbs [0 0 0 0 0 0] def
    } if
    
    barcode (fimd) eq {
        /sbs [2.25 2.25 2.25 2.25 2.25 6.75 2.25 6.75 2.25 2.25 2.25 2.25 2.25] def
        /bhs [.625 .625 .625 .625 .625 .625 .625] def
        /bbs [0 0 0 0 0 0 0] def
    } if
    
    % Return the arguments
    /retval 4 dict def
    retval (sbs) sbs put
    retval (bhs) bhs put
    retval (bbs) bbs put
    retval (opt) options put
    retval

    end

} bind def
/symbol load 0 1 dict put
% --END ENCODER symbol--

% --BEGIN RENDERER--
/barcode {

    0 begin          % Confine variables to local scope

    /args exch def   % We are given some arguments

    % Default options
    /sbs [] def
    /bhs [] def
    /bbs [] def
    /txt [] def
    /barcolor (unset) def
    /textcolor (unset) def
    /bordercolor (unset) def
    /backgroundcolor (unset) def
    /inkspread 0.15 def
    /width 0 def
    /barratio 1 def
    /spaceratio 1 def
    /showborder false def
    /borderleft 10 def
    /borderright 10 def
    /bordertop 1 def
    /borderbottom 1 def
    /borderwidth 0.5 def
    /guardwhitespace false def
    /guardleftpos 0 def
    /guardleftypos 0 def
    /guardrightpos 0 def
    /guardrightypos 0 def
    /guardwidth 6 def
    /guardheight 7 def
    
    % Apply the renderer options
    args {exch cvlit exch def} forall
       
    % Parse the user options   
    opt {
        token false eq {exit} if dup length string cvs (=) search
        true eq {cvlit exch pop exch def} {cvlit true def} ifelse
    } loop

    /barcolor barcolor cvlit def
    /textcolor textcolor cvlit def
    /bordercolor bordercolor cvlit def
    /backgroundcolor backgroundcolor cvlit def
    /inkspread inkspread cvr def
    /width width cvr def
    /barratio barratio cvr def
    /spaceratio spaceratio cvr def
    /borderleft borderleft cvr def
    /borderright borderright cvr def
    /bordertop bordertop cvr def
    /borderbottom borderbottom cvr def
    /borderwidth borderwidth cvr def
    /guardleftpos guardleftpos cvr def
    /guardleftypos guardleftypos cvr def
    /guardrightpos guardrightpos cvr def
    /guardrightypos guardrightypos cvr def
    /guardwidth guardwidth cvr def
    /guardheight guardheight cvr def
    
    % Create bar elements and put them into the bars array
    /bars sbs length 1 add 2 idiv array def
    /x 0.00 def /maxh 0 def
    0 1 sbs length 1 add 2 idiv 2 mul 2 sub {
        /i exch def
        i 2 mod 0 eq {           % i is even
            /d sbs i get barratio mul barratio sub 1 add def  % d=digit*r-r+1 
            /h bhs i 2 idiv get 72 mul def  % Height from bhs
            /c d 2 div x add def            % Centre of the bar = x + d/2
            /y bbs i 2 idiv get 72 mul def  % Baseline from bbs
            /w d inkspread sub def          % bar width = digit - inkspread
            bars i 2 idiv [h c y w] put     % Add the bar entry
            h maxh gt {/maxh h def} if
        } {
            /d sbs i get spaceratio mul spaceratio sub 1 add def  % d=digit*r-r+1 
        } ifelse
        /x x d add def  % x+=d
    } for

    gsave

    currentpoint translate

    % Force symbol to given width
    width 0 ne {
        width 72 mul x div 1 scale
    } if

    % Display the border and background
    newpath
    borderleft neg borderbottom neg moveto
    x borderleft add borderright add 0 rlineto
    0 maxh borderbottom add bordertop add rlineto
    x borderleft add borderright add neg 0 rlineto
    0 maxh borderbottom add bordertop add neg rlineto    
    closepath
    backgroundcolor (unset) ne {
        gsave
        (<      >) dup 1 backgroundcolor putinterval cvx exec {255 div} forall setrgbcolor
        fill
        grestore  
    } if     
    showborder {
        gsave
        bordercolor (unset) ne {
            (<      >) dup 1 bordercolor putinterval cvx exec {255 div} forall setrgbcolor
        } if
        borderwidth setlinewidth stroke
        grestore
    } if    
   
    % Display the bars for elements in the bars array
    gsave
    barcolor (unset) ne {
        (<      >) dup 1 barcolor putinterval cvx exec {255 div} forall setrgbcolor
    } if
    bars {
        {} forall
        newpath setlinewidth moveto 0 exch rlineto stroke
    } forall
    grestore
    
    % Display the text for elements in the text array
    textcolor (unset) ne {
        (<      >) dup 1 textcolor putinterval cvx exec {255 div} forall setrgbcolor
    } if
    /s 0 def /f () def
    txt {
        {} forall
        2 copy s ne exch f ne or {
            2 copy /s exch def /f exch def            
            exch findfont exch scalefont setfont          
        } {
            pop pop
        } ifelse
        moveto show
    } forall

    % Display the guard elements
    guardwhitespace {
        0.75 setlinewidth
        guardleftpos 0 ne {
            newpath
            guardleftpos neg guardwidth add guardleftypos guardwidth 2 div add moveto
            guardwidth neg guardheight -2 div rlineto
            guardwidth guardheight -2 div rlineto
            stroke            
        } if
        guardrightpos 0 ne {
            newpath
            guardrightpos x add guardwidth sub guardrightypos guardheight 2 div add moveto
            guardwidth guardheight -2 div rlineto
            guardwidth neg guardheight -2 div rlineto
            stroke            
        } if
    } if
    
    grestore
    
    end

} bind def
/barcode load 0 1 dict put
% --END RENDERER--

% --END TEMPLATE--

%%EndProcSet
%%BeginProcSet: 8r.enc
% File  8r.enc as of 2002-03-12 for PSNFSS 9
%
% This is the encoding vector for Type1 and TrueType fonts to be used
% with TeX.  This file is part of the PSNFSS bundle, version 9
% 
% Authors: S. Rahtz, P. MacKay, Alan Jeffrey, B. Horn, K. Berry, W. Schmidt
%
% Idea is to have all the characters normally included in Type 1 fonts
% available for typesetting. This is effectively the characters in Adobe
% Standard Encoding + ISO Latin 1 + extra characters from Lucida + Euro.
% 
% Character code assignments were made as follows:
% 
% (1) the Windows ANSI characters are almost all in their Windows ANSI
% positions, because some Windows users cannot easily reencode the
% fonts, and it makes no difference on other systems. The only Windows
% ANSI characters not available are those that make no sense for
% typesetting -- rubout (127 decimal), nobreakspace (160), softhyphen
% (173). quotesingle and grave are moved just because it's such an
% irritation not having them in TeX positions.
% 
% (2) Remaining characters are assigned arbitrarily to the lower part
% of the range, avoiding 0, 10 and 13 in case we meet dumb software.
% 
% (3) Y&Y Lucida Bright includes some extra text characters; in the
% hopes that other PostScript fonts, perhaps created for public
% consumption, will include them, they are included starting at 0x12.
% 
% (4) Remaining positions left undefined are for use in (hopefully)
% upward-compatible revisions, if someday more characters are generally
% available.
% 
% (5) hyphen appears twice for compatibility with both ASCII and Windows.
%
% (6) /Euro is assigned to 128, as in Windows ANSI
% 
/TeXBase1Encoding [
% 0x00 (encoded characters from Adobe Standard not in Windows 3.1)
  /.notdef /dotaccent /fi /fl
  /fraction /hungarumlaut /Lslash /lslash
  /ogonek /ring /.notdef
  /breve /minus /.notdef 
% These are the only two remaining unencoded characters, so may as
% well include them.
  /Zcaron /zcaron 
% 0x10
 /caron /dotlessi 
% (unusual TeX characters available in, e.g., Lucida Bright)
 /dotlessj /ff /ffi /ffl 
 /.notdef /.notdef /.notdef /.notdef
 /.notdef /.notdef /.notdef /.notdef
 % very contentious; it's so painful not having quoteleft and quoteright
 % at 96 and 145 that we move the things normally found there down to here.
 /grave /quotesingle 
% 0x20 (ASCII begins)
 /space /exclam /quotedbl /numbersign
 /dollar /percent /ampersand /quoteright
 /parenleft /parenright /asterisk /plus /comma /hyphen /period /slash
% 0x30
 /zero /one /two /three /four /five /six /seven
 /eight /nine /colon /semicolon /less /equal /greater /question
% 0x40
 /at /A /B /C /D /E /F /G /H /I /J /K /L /M /N /O
% 0x50
 /P /Q /R /S /T /U /V /W
 /X /Y /Z /bracketleft /backslash /bracketright /asciicircum /underscore
% 0x60
 /quoteleft /a /b /c /d /e /f /g /h /i /j /k /l /m /n /o
% 0x70
 /p /q /r /s /t /u /v /w
 /x /y /z /braceleft /bar /braceright /asciitilde
 /.notdef % rubout; ASCII ends
% 0x80
 /Euro /.notdef /quotesinglbase /florin
 /quotedblbase /ellipsis /dagger /daggerdbl
 /circumflex /perthousand /Scaron /guilsinglleft
 /OE /.notdef /.notdef /.notdef
% 0x90
 /.notdef /.notdef /.notdef /quotedblleft
 /quotedblright /bullet /endash /emdash
 /tilde /trademark /scaron /guilsinglright
 /oe /.notdef /.notdef /Ydieresis
% 0xA0
 /.notdef % nobreakspace
 /exclamdown /cent /sterling
 /currency /yen /brokenbar /section
 /dieresis /copyright /ordfeminine /guillemotleft
 /logicalnot
 /hyphen % Y&Y (also at 45); Windows' softhyphen
 /registered
 /macron
% 0xD0
 /degree /plusminus /twosuperior /threesuperior
 /acute /mu /paragraph /periodcentered
 /cedilla /onesuperior /ordmasculine /guillemotright
 /onequarter /onehalf /threequarters /questiondown
% 0xC0
 /Agrave /Aacute /Acircumflex /Atilde /Adieresis /Aring /AE /Ccedilla
 /Egrave /Eacute /Ecircumflex /Edieresis
 /Igrave /Iacute /Icircumflex /Idieresis
% 0xD0
 /Eth /Ntilde /Ograve /Oacute
 /Ocircumflex /Otilde /Odieresis /multiply
 /Oslash /Ugrave /Uacute /Ucircumflex
 /Udieresis /Yacute /Thorn /germandbls
% 0xE0
 /agrave /aacute /acircumflex /atilde
 /adieresis /aring /ae /ccedilla
 /egrave /eacute /ecircumflex /edieresis
 /igrave /iacute /icircumflex /idieresis
% 0xF0
 /eth /ntilde /ograve /oacute
 /ocircumflex /otilde /odieresis /divide
 /oslash /ugrave /uacute /ucircumflex
 /udieresis /yacute /thorn /ydieresis
] def

%%EndProcSet
%%BeginProcSet: aae443f0.enc
% Thomas Esser, Dec 2002. public domain
%
% Encoding for:
%     cmmi10 cmmi12 cmmi5 cmmi6 cmmi7 cmmi8 cmmi9 cmmib10
%
/TeXaae443f0Encoding [
/Gamma /Delta /Theta /Lambda /Xi /Pi /Sigma /Upsilon /Phi /Psi /Omega
/alpha /beta /gamma /delta /epsilon1 /zeta /eta /theta /iota /kappa
/lambda /mu /nu /xi /pi /rho /sigma /tau /upsilon /phi /chi /psi
/omega /epsilon /theta1 /pi1 /rho1 /sigma1 /phi1 /arrowlefttophalf
/arrowleftbothalf /arrowrighttophalf /arrowrightbothalf /arrowhookleft
/arrowhookright /triangleright /triangleleft /zerooldstyle /oneoldstyle
/twooldstyle /threeoldstyle /fouroldstyle /fiveoldstyle /sixoldstyle
/sevenoldstyle /eightoldstyle /nineoldstyle /period /comma /less /slash
/greater /star /partialdiff /A /B /C /D /E /F /G /H /I /J /K /L /M /N
/O /P /Q /R /S /T /U /V /W /X /Y /Z /flat /natural /sharp /slurbelow
/slurabove /lscript /a /b /c /d /e /f /g /h /i /j /k /l /m /n /o /p
/q /r /s /t /u /v /w /x /y /z /dotlessi /dotlessj /weierstrass /vector
/tie /psi /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/space /Gamma /Delta /Theta /Lambda /Xi /Pi /Sigma /Upsilon /Phi /Psi
/.notdef /.notdef /Omega /alpha /beta /gamma /delta /epsilon1 /zeta /eta
/theta /iota /kappa /lambda /mu /nu /xi /pi /rho /sigma /tau /upsilon
/phi /chi /psi /tie /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef
] def

%%EndProcSet
%%BeginProcSet: bbad153f.enc
% Thomas Esser, Dec 2002. public domain
%
% Encoding for:
%     cmsy10 cmsy5 cmsy6 cmsy7 cmsy8 cmsy9
%
/TeXbbad153fEncoding [
/minus /periodcentered /multiply /asteriskmath /divide /diamondmath
/plusminus /minusplus /circleplus /circleminus /circlemultiply
/circledivide /circledot /circlecopyrt /openbullet /bullet
/equivasymptotic /equivalence /reflexsubset /reflexsuperset /lessequal
/greaterequal /precedesequal /followsequal /similar /approxequal
/propersubset /propersuperset /lessmuch /greatermuch /precedes /follows
/arrowleft /arrowright /arrowup /arrowdown /arrowboth /arrownortheast
/arrowsoutheast /similarequal /arrowdblleft /arrowdblright /arrowdblup
/arrowdbldown /arrowdblboth /arrownorthwest /arrowsouthwest /proportional
/prime /infinity /element /owner /triangle /triangleinv /negationslash
/mapsto /universal /existential /logicalnot /emptyset /Rfractur /Ifractur
/latticetop /perpendicular /aleph /A /B /C /D /E /F /G /H /I /J /K
/L /M /N /O /P /Q /R /S /T /U /V /W /X /Y /Z /union /intersection
/unionmulti /logicaland /logicalor /turnstileleft /turnstileright
/floorleft /floorright /ceilingleft /ceilingright /braceleft /braceright
/angbracketleft /angbracketright /bar /bardbl /arrowbothv /arrowdblbothv
/backslash /wreathproduct /radical /coproduct /nabla /integral
/unionsq /intersectionsq /subsetsqequal /supersetsqequal /section
/dagger /daggerdbl /paragraph /club /diamond /heart /spade /arrowleft
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/minus /periodcentered /multiply /asteriskmath /divide /diamondmath
/plusminus /minusplus /circleplus /circleminus /.notdef /.notdef
/circlemultiply /circledivide /circledot /circlecopyrt /openbullet
/bullet /equivasymptotic /equivalence /reflexsubset /reflexsuperset
/lessequal /greaterequal /precedesequal /followsequal /similar
/approxequal /propersubset /propersuperset /lessmuch /greatermuch
/precedes /follows /arrowleft /spade /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
] def

%%EndProcSet
%%BeginProcSet: texps.pro
%!
TeXDict begin/rf{findfont dup length 1 add dict begin{1 index/FID ne 2
index/UniqueID ne and{def}{pop pop}ifelse}forall[1 index 0 6 -1 roll
exec 0 exch 5 -1 roll VResolution Resolution div mul neg 0 0]FontType 0
ne{/Metrics exch def dict begin Encoding{exch dup type/integertype ne{
pop pop 1 sub dup 0 le{pop}{[}ifelse}{FontMatrix 0 get div Metrics 0 get
div def}ifelse}forall Metrics/Metrics currentdict end def}{{1 index type
/nametype eq{exit}if exch pop}loop}ifelse[2 index currentdict end
definefont 3 -1 roll makefont/setfont cvx]cvx def}def/ObliqueSlant{dup
sin S cos div neg}B/SlantFont{4 index mul add}def/ExtendFont{3 -1 roll
mul exch}def/ReEncodeFont{CharStrings rcheck{/Encoding false def dup[
exch{dup CharStrings exch known not{pop/.notdef/Encoding true def}if}
forall Encoding{]exch pop}{cleartomark}ifelse}if/Encoding exch def}def
end

%%EndProcSet
%%BeginProcSet: special.pro
%!
TeXDict begin/SDict 200 dict N SDict begin/@SpecialDefaults{/hs 612 N
/vs 792 N/ho 0 N/vo 0 N/hsc 1 N/vsc 1 N/ang 0 N/CLIP 0 N/rwiSeen false N
/rhiSeen false N/letter{}N/note{}N/a4{}N/legal{}N}B/@scaleunit 100 N
/@hscale{@scaleunit div/hsc X}B/@vscale{@scaleunit div/vsc X}B/@hsize{
/hs X/CLIP 1 N}B/@vsize{/vs X/CLIP 1 N}B/@clip{/CLIP 2 N}B/@hoffset{/ho
X}B/@voffset{/vo X}B/@angle{/ang X}B/@rwi{10 div/rwi X/rwiSeen true N}B
/@rhi{10 div/rhi X/rhiSeen true N}B/@llx{/llx X}B/@lly{/lly X}B/@urx{
/urx X}B/@ury{/ury X}B/magscale true def end/@MacSetUp{userdict/md known
{userdict/md get type/dicttype eq{userdict begin md length 10 add md
maxlength ge{/md md dup length 20 add dict copy def}if end md begin
/letter{}N/note{}N/legal{}N/od{txpose 1 0 mtx defaultmatrix dtransform S
atan/pa X newpath clippath mark{transform{itransform moveto}}{transform{
itransform lineto}}{6 -2 roll transform 6 -2 roll transform 6 -2 roll
transform{itransform 6 2 roll itransform 6 2 roll itransform 6 2 roll
curveto}}{{closepath}}pathforall newpath counttomark array astore/gc xdf
pop ct 39 0 put 10 fz 0 fs 2 F/|______Courier fnt invertflag{PaintBlack}
if}N/txpose{pxs pys scale ppr aload pop por{noflips{pop S neg S TR pop 1
-1 scale}if xflip yflip and{pop S neg S TR 180 rotate 1 -1 scale ppr 3
get ppr 1 get neg sub neg ppr 2 get ppr 0 get neg sub neg TR}if xflip
yflip not and{pop S neg S TR pop 180 rotate ppr 3 get ppr 1 get neg sub
neg 0 TR}if yflip xflip not and{ppr 1 get neg ppr 0 get neg TR}if}{
noflips{TR pop pop 270 rotate 1 -1 scale}if xflip yflip and{TR pop pop
90 rotate 1 -1 scale ppr 3 get ppr 1 get neg sub neg ppr 2 get ppr 0 get
neg sub neg TR}if xflip yflip not and{TR pop pop 90 rotate ppr 3 get ppr
1 get neg sub neg 0 TR}if yflip xflip not and{TR pop pop 270 rotate ppr
2 get ppr 0 get neg sub neg 0 S TR}if}ifelse scaleby96{ppr aload pop 4
-1 roll add 2 div 3 1 roll add 2 div 2 copy TR .96 dup scale neg S neg S
TR}if}N/cp{pop pop showpage pm restore}N end}if}if}N/normalscale{
Resolution 72 div VResolution 72 div neg scale magscale{DVImag dup scale
}if 0 setgray}N/psfts{S 65781.76 div N}N/startTexFig{/psf$SavedState
save N userdict maxlength dict begin/magscale true def normalscale
currentpoint TR/psf$ury psfts/psf$urx psfts/psf$lly psfts/psf$llx psfts
/psf$y psfts/psf$x psfts currentpoint/psf$cy X/psf$cx X/psf$sx psf$x
psf$urx psf$llx sub div N/psf$sy psf$y psf$ury psf$lly sub div N psf$sx
psf$sy scale psf$cx psf$sx div psf$llx sub psf$cy psf$sy div psf$ury sub
TR/showpage{}N/erasepage{}N/setpagedevice{pop}N/copypage{}N/p 3 def
@MacSetUp}N/doclip{psf$llx psf$lly psf$urx psf$ury currentpoint 6 2 roll
newpath 4 copy 4 2 roll moveto 6 -1 roll S lineto S lineto S lineto
closepath clip newpath moveto}N/endTexFig{end psf$SavedState restore}N
/@beginspecial{SDict begin/SpecialSave save N gsave normalscale
currentpoint TR @SpecialDefaults count/ocount X/dcount countdictstack N}
N/@setspecial{CLIP 1 eq{newpath 0 0 moveto hs 0 rlineto 0 vs rlineto hs
neg 0 rlineto closepath clip}if ho vo TR hsc vsc scale ang rotate
rwiSeen{rwi urx llx sub div rhiSeen{rhi ury lly sub div}{dup}ifelse
scale llx neg lly neg TR}{rhiSeen{rhi ury lly sub div dup scale llx neg
lly neg TR}if}ifelse CLIP 2 eq{newpath llx lly moveto urx lly lineto urx
ury lineto llx ury lineto closepath clip}if/showpage{}N/erasepage{}N
/setpagedevice{pop}N/copypage{}N newpath}N/@endspecial{count ocount sub{
pop}repeat countdictstack dcount sub{end}repeat grestore SpecialSave
restore end}N/@defspecial{SDict begin}N/@fedspecial{end}B/li{lineto}B
/rl{rlineto}B/rc{rcurveto}B/np{/SaveX currentpoint/SaveY X N 1
setlinecap newpath}N/st{stroke SaveX SaveY moveto}N/fil{fill SaveX SaveY
moveto}N/ellipse{/endangle X/startangle X/yrad X/xrad X/savematrix
matrix currentmatrix N TR xrad yrad scale 0 0 1 startangle endangle arc
savematrix setmatrix}N end

%%EndProcSet
%%BeginFont: CMSY10
%!PS-AdobeFont-1.1: CMSY10 1.0
%%CreationDate: 1991 Aug 15 07:20:57
% Copyright (C) 1997 American Mathematical Society. All Rights Reserved.
11 dict begin
/FontInfo 7 dict dup begin
/version (1.0) readonly def
/Notice (Copyright (C) 1997 American Mathematical Society. All Rights Reserved) readonly def
/FullName (CMSY10) readonly def
/FamilyName (Computer Modern) readonly def
/Weight (Medium) readonly def
/ItalicAngle -14.035 def
/isFixedPitch false def
end readonly def
/FontName /CMSY10 def
/PaintType 0 def
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0] readonly def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 0 /.notdef put
readonly def
/FontBBox{-29 -960 1116 775}readonly def
/UniqueID 5000820 def
currentdict end
currentfile eexec
D9D66F633B846A97B686A97E45A3D0AA052F09F9C8ADE9D907C058B87E9B6964
7D53359E51216774A4EAA1E2B58EC3176BD1184A633B951372B4198D4E8C5EF4
A213ACB58AA0A658908035BF2ED8531779838A960DFE2B27EA49C37156989C85
E21B3ABF72E39A89232CD9F4237FC80C9E64E8425AA3BEF7DED60B122A52922A
221A37D9A807DD01161779DDE7D31FF2B87F97C73D63EECDDA4C49501773468A
27D1663E0B62F461F6E40A5D6676D1D12B51E641C1D4E8E2771864FC104F8CBF
5B78EC1D88228725F1C453A678F58A7E1B7BD7CA700717D288EB8DA1F57C4F09
0ABF1D42C5DDD0C384C7E22F8F8047BE1D4C1CC8E33368FB1AC82B4E96146730
DE3302B2E6B819CB6AE455B1AF3187FFE8071AA57EF8A6616B9CB7941D44EC7A
71A7BB3DF755178D7D2E4BB69859EFA4BBC30BD6BB1531133FD4D9438FF99F09
4ECC068A324D75B5F696B8688EEB2F17E5ED34CCD6D047A4E3806D000C199D7C
515DB70A8D4F6146FE068DC1E5DE8BC5703711DA090312BA3FC00A08C453C609
C627A8BFEF75B4DEFAF34B44B356A516B765AFCDD3F5475B1F928731D09D2170
B97E40F12CCEDF4F6BB3756C4734F6E98D74B7E942A954B1BAAB83D4AD727FF6
DF6DC50B2223BCB5568A73A112E4860AD490554E64E780073FF3399CB4688D33
9E8829667CD6EAEF25E0C7D2D44F2BBFA40E999325F9561514844221B50BC8FC
4C7AD68CA7220D69125C2AF06849A3E068D18733276F0C0A6A2936D3C2C87CDE
59CD1AF148C44F85784A5DAD569F5FF53C061056C067CE29AEF1E3BD1FD8B0B8
71A0A638CDAC6AEEDBD5337D4683C084BB60B1859E600F59CB4E19C5FC5C6327
EC544A68134496A9BD0B87D83AF6FDA3CB62FBF0B54FACE1F0E6A2D84B467AFF
0F62DB
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
%%BeginFont: CMMI10
%!PS-AdobeFont-1.1: CMMI10 1.100
%%CreationDate: 1996 Jul 23 07:53:57
% Copyright (C) 1997 American Mathematical Society. All Rights Reserved.
11 dict begin
/FontInfo 7 dict dup begin
/version (1.100) readonly def
/Notice (Copyright (C) 1997 American Mathematical Society. All Rights Reserved) readonly def
/FullName (CMMI10) readonly def
/FamilyName (Computer Modern) readonly def
/Weight (Medium) readonly def
/ItalicAngle -14.04 def
/isFixedPitch false def
end readonly def
/FontName /CMMI10 def
/PaintType 0 def
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0] readonly def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 0 /.notdef put
readonly def
/FontBBox{-32 -250 1048 750}readonly def
/UniqueID 5087385 def
currentdict end
currentfile eexec
D9D66F633B846A97B686A97E45A3D0AA0529731C99A784CCBE85B4993B2EEBDE
3B12D472B7CF54651EF21185116A69AB1096ED4BAD2F646635E019B6417CC77B
532F85D811C70D1429A19A5307EF63EB5C5E02C89FC6C20F6D9D89E7D91FE470
B72BEFDA23F5DF76BE05AF4CE93137A219ED8A04A9D7D6FDF37E6B7FCDE0D90B
986423E5960A5D9FBB4C956556E8DF90CBFAEC476FA36FD9A5C8175C9AF513FE
D919C2DDD26BDC0D99398B9F4D03D5993DFC0930297866E1CD0A319B6B1FD958
9E394A533A081C36D456A09920001A3D2199583EB9B84B4DEE08E3D12939E321
990CD249827D9648574955F61BAAA11263A91B6C3D47A5190165B0C25ABF6D3E
6EC187E4B05182126BB0D0323D943170B795255260F9FD25F2248D04F45DFBFB
DEF7FF8B19BFEF637B210018AE02572B389B3F76282BEB29CC301905D388C721
59616893E774413F48DE0B408BC66DCE3FE17CB9F84D205839D58014D6A88823
D9320AE93AF96D97A02C4D5A2BB2B8C7925C4578003959C46E3CE1A2F0EAC4BF
8B9B325E46435BDE60BC54D72BC8ACB5C0A34413AC87045DC7B84646A324B808
6FD8E34217213E131C3B1510415CE45420688ED9C1D27890EC68BD7C1235FAF9
1DAB3A369DD2FC3BE5CF9655C7B7EDA7361D7E05E5831B6B8E2EEC542A7B38EE
03BE4BAC6079D038ACB3C7C916279764547C2D51976BABA94BA9866D79F13909
95AA39B0F03103A07CBDF441B8C5669F729020AF284B7FF52A29C6255FCAACF1
74109050FBA2602E72593FBCBFC26E726EE4AEF97B7632BC4F5F353B5C67FED2
3EA752A4A57B8F7FEFF1D7341D895F0A3A0BE1D8E3391970457A967EFF84F6D8
47750B1145B8CC5BD96EE7AA99DDC9E06939E383BDA41175233D58AD263EBF19
AFC0E2F840512D321166547B306C592B8A01E1FA2564B9A26DAC14256414E4C8
42616728D918C74D13C349F4186EC7B9708B86467425A6FDB3A396562F7EE4D8
40B43621744CF8A23A6E532649B66C2A0002DD04F8F39618E4F572819DD34837
B5A08E643FDCA1505AF6A1FA3DDFD1FA758013CAED8ACDDBBB334D664DFF5B53
95601766777978D01677B8D19E1B10A078432D2884BB4F7B8C3293B68BB78100
16724E495064BA0168CC86D413CB48560D6D318357397832F7A858CD82030C7D
8A4A1919716E8B26AFF8789AAF489EE4E0A88DC477551A87C7DF2856189E4596
FE015956AFE5CC019F5CA6323A12B763B7B08B92C1A2940D3C566C43729E5482
63C6DC5E834AEB4DAFB5AE8F0B8931A4687C94D11587B9071C8D81DA14F12776
53A1985A3EBE37827656BD4635E03F09C3231F906874645E7DB3E59045A59D67
E745D8487CF73FC50F64060544F624F357BC998A87FBE468DEBB38A09449EBCA
D041D7C29225ACD16CB8A59E87924D15A9125F064710A6CCCA3AD3103D8FCC94
CC3571C6F9192774FCFE5BB42A14B27960903144D28BF047BF4C77646EA7BF6F
440D4EDEB712C63F2E8080419E42D1D58EED685EB5CDD49F80DB6E5553B519FA
C6A39A093155802F3EC607721F390307E91ECB597ABA60A537E3F8C045BF5DD3
D88CF6518D37FCD95D2F295D902D617440D23516D962F47750A682A319ACE1
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
TeXDict begin 39158280 55380996 1000 600 600 (barcodewriter.dvi)
@start /Fa 242[83 13[{ TeXbbad153fEncoding ReEncodeFont }1
83.022 /CMSY10 rf /Fb 136[55 2[23 4[42 1[60 23 2[23 42
42 23 37 42 1[42 52[28 45[{ TeXBase1Encoding ReEncodeFont }13
83.022 /Times-Italic rf /Fc 134[33 1[48 33 33 18 26 22
1[33 33 33 52 18 33 1[18 33 33 22 29 33 29 33 29 12[41
37 2[37 3[41 8[44 44 19[17 1[17 2[22 22 40[{
 TeXBase1Encoding ReEncodeFont }32 66.4176 /Times-Roman
rf /Fd 205[25 25 49[{ TeXBase1Encoding ReEncodeFont }2
49.8132 /Times-Roman rf /Fe 133[44 50 2[50 55 33 39 44
55 55 50 55 83 28 2[28 55 50 33 44 55 44 55 50 10[72
72 66 55 72 1[61 1[72 94 66 2[39 78 78 61 66 72 72 66
72 7[50 50 50 50 50 50 50 50 50 50 28 25 33 5[33 36[55
2[{ TeXBase1Encoding ReEncodeFont }55 99.6264 /Times-Bold
rf /Ff 119[42 10[42 42 42 42 42 42 42 42 42 42 42 42
42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 1[42
1[42 42 42 42 3[42 42 42 42 42 1[42 42 42 42 42 42 1[42
42 42 42 42 42 42 42 42 42 1[42 42 42 42 42 42 42 42
42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 42 1[42
42 42 42 42 33[{ .85 ExtendFont TeXBase1Encoding ReEncodeFont }85
83.022 /Courier rf /Fh 190[44 14[31 31 49[{
 TeXBase1Encoding ReEncodeFont }3 61.4362 /Times-Roman
rf /Fi 134[42 42 2[46 28 32 37 1[46 42 46 69 23 2[23
46 42 1[37 46 37 46 42 9[83 2[55 46 60 2[65 60 1[55 65
1[32 3[55 60 60 55 8[42 3[42 42 42 42 42 3[28 45[{
 TeXBase1Encoding ReEncodeFont }39 83.022 /Times-Bold
rf /Fj 134[60 60 86 1[66 40 47 53 1[66 60 66 100 33 66
1[33 1[60 1[53 66 53 66 60 13[66 86 5[80 2[47 3[80 1[86
1[86 11[60 60 60 60 60 49[{ TeXBase1Encoding ReEncodeFont }32
119.552 /Times-Bold rf /Fk 32[42 74[37 25[37 42 42 60
42 42 23 32 28 42 42 42 42 65 23 42 23 23 42 42 28 37
42 37 42 37 7[60 60 78 60 60 51 46 55 1[46 60 60 74 51
60 32 28 60 60 46 51 60 55 55 60 6[23 42 42 42 42 42
42 42 42 42 42 23 21 28 21 2[28 28 28 22[28 12[46 46
2[{ TeXBase1Encoding ReEncodeFont }73 83.022 /Times-Roman
rf /Fl 134[37 37 54 37 37 21 29 25 1[37 37 37 58 21 1[21
21 37 37 25 33 37 33 37 33 9[71 2[46 3[42 13[50 19[19
25 19 44[{ TeXBase1Encoding ReEncodeFont }30 74.7198
/Times-Roman rf /Fm 139[25 29 33 14[33 42 37 31[54 65[{
 TeXBase1Encoding ReEncodeFont }7 74.7198 /Times-Bold
rf /Fn 193[77 1[77 60[{ TeXaae443f0Encoding ReEncodeFont }2
99.6264 /CMMI10 rf /Fp 133[44 50 3[50 28 1[33 1[50 50
50 78 1[50 5[44 1[44 50 13[61 55 16[66 1[92 9[50 3[50
1[50 1[25 1[25 44[{ TeXBase1Encoding ReEncodeFont }22
99.6264 /Times-Roman rf /Fq 138[72 40 56 48 1[72 72 72
4[40 3[64 72 64 1[64 9[135 6[80 13[96 66[{
 TeXBase1Encoding ReEncodeFont }15 143.462 /Times-Roman
rf end
%%EndProlog
%%BeginSetup
%%Feature: *Resolution 600dpi
TeXDict begin
%%PaperSize: A4
 end
%%EndSetup
%%Page: 1 1
TeXDict begin 1 0 bop 979 872 a Fq(Barcode)34 b(Writer)h(in)g(Pure)g
(Postscript)1150 1160 y Fp(T)-7 b(erry)25 b(Burton)g
Fn(<)p Fp(tez@terryb)n(urton.co.uk)p Fn(>)1547 1401 y
Fp(September)g(26,)f(2006)1808 1706 y Fm(Abstract)834
1857 y Fl(This)k(document)i(describes)e(the)h(implementation)g(of)f
(the)g(Barcode)h(Writer)d(in)i(Pure)722 1948 y(Postscript)21
b(project,)g(e)o(xplains)g(by)g(e)o(xample)h(ho)n(w)f(to)g(use)g(this)g
(to)f(generate)i(your)f(o)n(wn)h(bar)o(-)722 2039 y(codes,)e(and)f(pro)
o(vides)h(a)f(simple)g(reference)h(to)e(using)i(the)f(symbologies)h
(that)f(it)f(supports.)515 2236 y Fk(Note:)24 b(Despite)17
b(the)g(date)h(on)e(this)i(document,)e(the)h(information)e(contained)h
(herein)g(is)i(some)n(what)515 2336 y(out)25 b(of)h(date.)43
b(A)26 b(much)f(more)h(thorough)d(and)i(up-to-date)f(reference)h(to)h
(this)h(project)e(is)i(a)n(v)n(ail-)515 2435 y(able)19
b(in)h(the)g(wiki,)f(http://www)-5 b(.terryb)n(urton.co.uk/b)o(arco)o
(de)m(writer/wik)o(i/)f(.)26 b(This)20 b(wiki)f(pro)o(vides)515
2535 y(a)29 b(collaborati)n(v)o(e)d(approach)h(to)i(documentation)d
(that)i(allo)n(ws)i(users)e(to)h(add)g(and)f(edit)h(content)515
2635 y(collecti)n(v)o(ely)-5 b(.)1935 5255 y(i)p eop
end
%%Page: 2 2
TeXDict begin 2 1 bop 515 523 a Fj(Contents)515 756 y
Fi(1)82 b(Intr)o(oduction)2246 b(1)515 986 y(2)82 b(Code)20
b(Commentary)2021 b(2)639 1133 y Fk(2.1)86 b(The)20 b(Barcode)f(Data)i
(Structure)f(.)41 b(.)g(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)h
(.)f(.)g(.)g(.)h(.)f(.)g(.)g(.)h(.)165 b(2)639 1279 y(2.2)86
b(An)20 b(Encoder)52 b(.)41 b(.)g(.)g(.)h(.)f(.)g(.)h(.)f(.)g(.)g(.)h
(.)f(.)g(.)g(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)
g(.)h(.)165 b(3)639 1426 y(2.3)86 b(The)20 b(Renderer)59
b(.)41 b(.)g(.)h(.)f(.)g(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)
g(.)h(.)f(.)g(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)g(.)h(.)165
b(5)639 1573 y(2.4)86 b(Notes)21 b(Re)o(garding)d(Coding)h(Style)59
b(.)42 b(.)f(.)g(.)g(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)h(.)f(.)g(.)g(.)h(.)
f(.)g(.)g(.)h(.)165 b(8)515 1803 y Fi(3)82 b(Resour)o(ces)20
b(and)h(Examples)1818 b(9)639 1950 y Fk(3.1)86 b(Language)18
b(Speci\002c)j(APIs)i(.)42 b(.)f(.)g(.)g(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)
g(.)h(.)f(.)g(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)g(.)h(.)165
b(9)639 2097 y(3.2)86 b(Front)20 b(Ends)i(.)42 b(.)f(.)g(.)g(.)h(.)f(.)
g(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)h(.)f
(.)g(.)g(.)h(.)f(.)g(.)g(.)h(.)165 b(9)639 2244 y(3.3)86
b(Installing)30 b(the)i(Barcode)e(Generation)f(Capability)i(into)g(a)g
(Printer')-5 b(s)31 b(V)-5 b(irtual)830 2343 y(Machine)36
b(.)41 b(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)g(.)
h(.)f(.)g(.)g(.)h(.)f(.)g(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)g(.)h(.)124
b(10)639 2490 y(3.4)86 b(Hints)21 b(for)e(Generating)g(Precisely)h(the)
g(Required)f(Symbol)h(.)42 b(.)f(.)g(.)g(.)h(.)f(.)g(.)g(.)h(.)124
b(11)639 2637 y(3.5)86 b(Printing)20 b(in)g(Perl)69 b(.)41
b(.)h(.)f(.)g(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)g(.)h(.)f
(.)g(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)g(.)h(.)124 b(12)515
2867 y Fi(4)82 b(Supported)21 b(Symbologies)1818 b(13)639
3014 y Fk(4.1)86 b(EAN-13)45 b(.)c(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)h(.)f
(.)g(.)g(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)h(.)f(.)g(.)g(.)
h(.)f(.)g(.)g(.)h(.)124 b(13)639 3161 y(4.2)86 b(EAN-8)25
b(.)41 b(.)g(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)
g(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)g(.)h(.)124
b(13)639 3308 y(4.3)86 b(UPC-A)79 b(.)41 b(.)h(.)f(.)g(.)g(.)h(.)f(.)g
(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)h(.)f(.)
g(.)g(.)h(.)f(.)g(.)g(.)h(.)124 b(14)639 3454 y(4.4)86
b(UPC-E)26 b(.)41 b(.)g(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)h(.)f(.)g(.)g(.)h
(.)f(.)g(.)g(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)
g(.)h(.)124 b(14)639 3601 y(4.5)86 b(EAN-5)25 b(.)41
b(.)g(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)g(.)h
(.)f(.)g(.)g(.)h(.)f(.)g(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)g(.)h(.)124
b(15)639 3748 y(4.6)86 b(EAN-2)25 b(.)41 b(.)g(.)h(.)f(.)g(.)g(.)h(.)f
(.)g(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)h(.)
f(.)g(.)g(.)h(.)f(.)g(.)g(.)h(.)124 b(15)639 3895 y(4.7)86
b(ISBN)77 b(.)41 b(.)g(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)h(.)f(.)g(.)g(.)h
(.)f(.)g(.)g(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)
g(.)h(.)124 b(16)639 4042 y(4.8)86 b(Code-39)40 b(.)h(.)h(.)f(.)g(.)g
(.)h(.)f(.)g(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)g(.)h(.)f(.)
g(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)g(.)h(.)124 b(16)639
4189 y(4.9)86 b(Code-128)18 b(and)i(UCC/EAN-128)68 b(.)42
b(.)f(.)g(.)g(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)h(.)f(.)g(.)g(.)h(.)f(.)g
(.)g(.)h(.)124 b(17)639 4336 y(4.10)44 b(Rationalized)20
b(Codabar)40 b(.)h(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)g(.)h
(.)f(.)g(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)g(.)h(.)124 b(17)639
4483 y(4.11)44 b(Interlea)n(v)o(ed)18 b(2)j(of)f(5)g(and)g(ITF-14)29
b(.)41 b(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)h(.)f(.)g(.)g(.)
h(.)f(.)g(.)g(.)h(.)124 b(18)639 4629 y(4.12)44 b(Code)20
b(2)h(of)e(5)63 b(.)41 b(.)g(.)g(.)h(.)f(.)g(.)h(.)f(.)g(.)g(.)h(.)f(.)
g(.)g(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)g(.)h
(.)124 b(18)639 4776 y(4.13)44 b(Postnet)21 b(.)41 b(.)g(.)h(.)f(.)g(.)
g(.)h(.)f(.)g(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)g(.)h(.)f
(.)g(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)g(.)h(.)124 b(19)639
4923 y(4.14)44 b(Ro)o(yal)20 b(Mail)78 b(.)41 b(.)g(.)g(.)h(.)f(.)g(.)h
(.)f(.)g(.)g(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)h(.)f(.)g(.)
g(.)h(.)f(.)g(.)g(.)h(.)124 b(19)1924 5255 y(ii)p eop
end
%%Page: 3 3
TeXDict begin 3 2 bop 639 523 a Fk(4.15)44 b(MSI)56 b(.)41
b(.)g(.)g(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)g
(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)g(.)h(.)124
b(20)639 670 y(4.16)44 b(Plesse)o(y)80 b(.)41 b(.)h(.)f(.)g(.)g(.)h(.)f
(.)g(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)g(.)h(.)f(.)g(.)h(.)
f(.)g(.)g(.)h(.)f(.)g(.)g(.)h(.)124 b(20)515 900 y Fi(5)82
b(License)2390 b(21)1912 5255 y Fk(iii)p eop end
%%Page: 1 4
TeXDict begin 1 3 bop 515 523 a Fj(1)119 b(Intr)n(oduction)515
756 y Fk(Barcode)20 b(Writer)h(in)g(Pure)g(Postscript)g(is)h(an)f(a)o
(w)o(ard-winning)d(open)i(source)g(barcode)f(mak)o(er)m(,)h(as)515
855 y(used)j(by)h(N)m(ASA,)g(that)g(f)o(acilitates)g(the)g(printing)e
(of)i(all)g(major)f(barcode)f(symbologies)g(entirely)515
955 y(within)29 b(le)n(v)o(el)h(2)g(PostScript,)i(ideal)e(for)f(v)n
(ariable)g(data)h(printing.)53 b(The)29 b(complete)g(process)h(of)515
1055 y(generating)15 b(printed)g(barcodes)g(is)j(performed)c(entirely)i
(within)h(the)g(printer)e(\(or)h(print)h(system\))f(so)515
1154 y(that)22 b(it)g(is)h(no)f(longer)e(the)i(responsibility)f(of)g
(your)g(application)f(or)i(a)g(library)-5 b(.)29 b(There)21
b(is)i(no)e(need)515 1254 y(for)27 b(an)o(y)h(barcode)e(fonts)i(and)g
(the)g(\003e)o(xibility)f(of)n(fered)g(by)h(direct)f(PostScript)i
(means)e(you)h(can)515 1354 y(a)n(v)n(oid)16 b(re-implementing)d
(barcode)i(generator)f(code,)j(or)f(migrating)e(to)j(ne)n(w)f
(libraries,)h(whene)n(v)o(er)515 1453 y(your)i(project)g(language)f
(needs)i(change.)515 1600 y(T)-7 b(o)35 b(mak)o(e)f(it)i(as)f(easy)g
(as)h(possible)f(to)g(incorporate)d(this)k(project)e(into)g(your)g(o)n
(wn)g(systems,)515 1700 y(whether)e(the)o(y)h(be)h(freely)e(a)n(v)n
(ailable)i(or)f(proprietary)-5 b(,)34 b(it)g(is)h(licensed)e(under)f
(the)i(permissi)n(v)o(e)515 1799 y(MIT/X-Consortium)17
b(License)j(gi)n(v)o(en)f(in)i(section)f(5.)515 1946
y(The)g(project)f(homepage)f(is)j(at)g(http://www)-5
b(.terryb)n(urton.co.uk)o(/bar)o(cod)o(e)n(wr)o(iter)g(.)515
2093 y(This)27 b(is)g(the)g(main)f(resource)g(for)g(the)h(project)f
(pro)o(viding)d(the)k(latest)h(do)n(wnloads)d(of)h(code)g(and)515
2193 y(documentation,)17 b(as)k(well)f(as)h(access)g(to)f(the)h
(support)d(and)i(de)n(v)o(elopment)d(mailing)j(list.)515
2520 y Fj(Ackno)o(wledgements)515 2753 y Fk(The)28 b(author)g(wishes)h
(to)g(tak)o(e)g(this)h(opportunity)c(to)j(thank)f(the)h(gro)n(wing)e
(community)f(of)j(v)n(ol-)515 2853 y(unteers)d(that)g(ha)n(v)o(e)g
(helped)f(to)i(de)n(v)o(elop,)f(test)h(and)f(document)e(this)j
(project.)43 b(Most)27 b(especially)515 2952 y(Michael)e(Landers)g(and)
h(Ross)g(McF)o(arland)f(for)g(freely)g(donating)f(their)i(encoder)e
(implementa-)515 3052 y(tions)c(early)g(in)g(the)g(life)h(of)f(the)g
(project.)515 3199 y(Also,)d(special)g(appreciation)e(is)j(e)o(xtended)
c(to)j(the)g(de)n(v)o(elopers)e(that)i(ha)n(v)o(e)f(created)g(the)h
(front-ends)515 3298 y(necessary)f(to)i(mak)o(e)f(the)g(code)g(v)n
(aluable)f(to)i(ordinary)d(computer)g(users,)j(especially)f(Petr)h(V)-9
b(an)5 b(\020)-33 b(ek,)515 3398 y(Dominik)19 b(Seichter)h(and)f
(Herbert)g(V)-11 b(o\337.)1926 5255 y(1)p eop end
%%Page: 2 5
TeXDict begin 2 4 bop 515 523 a Fj(2)119 b(Code)31 b(Commentary)515
756 y Fk(This)20 b(commentary)e(assumes)i(f)o(amiliarity)g(with)g(the)g
(PostScript)g(language)2741 726 y Fh(1)2774 756 y Fk(.)515
903 y(The)g(code)f(is)i(split)g(cleanly)f(into)f(tw)o(o)i(types)f(of)g
(procedure:)515 1133 y Fi(The)h(encoders)41 b Fk(Each)19
b(of)h(these)g(represents)f(a)i(barcode)d(symbology)2566
1102 y Fh(2)2598 1133 y Fk(,)i(e.g.)25 b(EAN-13)18 b(or)i(Code-)722
1232 y(128.)k(It)c(tak)o(es)g(a)g(string)f(containing)f(the)i(barcode)e
(data)h(and)g(a)h(string)f(containing)f(a)i(list)h(of)722
1332 y(options)e(that)g(modify)e(the)j(output)e(of)h(the)g(encoder)-5
b(.)23 b(It)d(generates)e(a)h(structured)f(represen-)722
1431 y(tation)j(of)g(the)g(barcode)e(and)i(its)h(te)o(xt)f(for)f(the)h
(symbology)-5 b(,)19 b(including)g(the)i(calculation)f(of)722
1531 y(check)g(digits)g(where)g(necessary)-5 b(.)515
1697 y Fi(The)21 b(r)o(ender)o(er)40 b Fk(This)24 b(tak)o(es)h(the)g
(output)e(of)h(an)g(encoder)f(and)h(generates)f(a)i(visual)f
(representa-)722 1797 y(tion)c(of)g(the)g(barcode.)515
2027 y(This)g(means)g(that)g(all)h(barcodes)e(can)h(be)g(generated)e
(simply)i(in)h(a)f(similar)h(manner:)515 2257 y Ff(\(78858101497\))47
b(\(includetext)f(height=0.6\))g(upca)e(barcode)515 2356
y(\(0123456789\))i(\(includecheck\))h(interleaved2of5)h(barcode)515
2641 y Fe(2.1)99 b(The)26 b(Bar)n(code)g(Data)f(Structur)n(e)515
2844 y Fk(The)c(follo)n(wing)g(table)h(describes)f(the)h(structured)f
(representation)e(of)j(a)g(barcode)f(that)h(is)h(passed)515
2944 y(by)d(an)g(encoder)e(to)j(the)f(renderer)e(as)j(a)g(dictionary)d
(when)i(the)g(PostScript)g(is)h(e)o(x)o(ecuted.)650 3170
y(Element)p 1422 3200 4 100 v 546 w(K)n(e)o(y)p 1657
3200 V 98 w(V)-9 b(alue)p 600 3203 2694 4 v 650 3273
a(Space)20 b(bar)g(succession)p 1422 3402 4 200 v 126
w Ff(sbs)p 1657 3402 V 104 w Fk(Array)f(containing)e(the)i(widths,)g
(in)g(points,)g(of)g(each)1708 3372 y(bar)h(and)g(space,)g(starting)f
(with)i(the)f(leftmost)g(bar)-5 b(.)650 3472 y(Bar)21
b(height)e(succession)p 1422 3602 V 103 w Ff(bhs)p 1657
3602 V 104 w Fk(Array)40 b(containing)f(the)i(height)f(of)h(each)g(bar)
f(in)1708 3572 y(inches,)20 b(starting)g(with)g(the)g(leftmost)g(bar)-5
b(.)650 3671 y(Bar)21 b(base)f(succession)p 1422 3801
V 163 w Ff(bbs)p 1657 3801 V 104 w Fk(Array)f(containing)f(the)i(of)n
(fset)g(of)f(the)h(base)g(of)g(each)1708 3771 y(bar)g(in)g(inches,)g
(starting)g(with)g(the)g(leftmost)g(bar)-5 b(.)650 3871
y(Human)19 b(readable)g(te)o(xt)p 1422 4199 4 399 v 137
w Ff(txt)p 1657 4199 V 104 w Fk(Array)k(of)g(arrays)f(that)h(contain)g
(the)g(character)m(,)f(po-)1708 3970 y(sition,)f(height,)f(font)g(and)h
(scale)g(f)o(actor)f(\(font)g(size\),)1708 4070 y(in)29
b(points,)i(for)d(each)h(of)g(the)g(visible)g(te)o(xt)f(charac-)1708
4169 y(ters.)650 4269 y(Renderer)19 b(options)p 1422
4399 4 200 v 257 w Ff(opt)p 1657 4399 V 104 w Fk(String)d(containing)f
(the)h(user)n(-de\002ned)f(renderer)f(op-)1708 4369 y(tions.)515
4594 y(Other)24 b(k)o(e)o(ys)h(and)f(v)n(alues)h(may)g(be)g(contained)e
(in)i(this)h(structure)e(that)h(o)o(v)o(erride)d(the)j(render)f(de-)515
4693 y(f)o(aults)c(with)g(encoder)f(speci\002c)h(def)o(aults.)p
515 4765 1146 4 v 605 4820 a Fd(1)634 4844 y Fc(The)14
b(PostScript)h(Language)f(T)m(utorial)h(and)f(Cookbook)h(\(a.k.a.)k
(the)c(Blue)f(Book\),)g(which)h(is)e(freely)i(a)o(v)n(ailable)h
(online,)515 4923 y(serv)o(es)h(as)g(both)h(a)f(useful)h(tutorial)h
(and)f(reference)i(manual)e(to)f(the)h(language.)605
4981 y Fd(2)634 5005 y Fc(By)f(symbology)h(we)f(mean)h(an)f(accepted)j
(standard)f(for)e(representation)k(of)16 b(data)j(as)e(a)g(barcode)1926
5255 y Fk(2)p eop end
%%Page: 3 6
TeXDict begin 3 5 bop 515 523 a Fe(2.2)99 b(An)25 b(Encoder)515
726 y Fk(The)j(procedure)e(labelled)i(code2of5)e(is)k(a)f(simple)f(e)o
(xample)f(of)i(an)f(encoder)m(,)h(which)f(we)h(will)515
826 y(no)n(w)19 b(consider)-5 b(.)24 b(Its)d(purpose)d(is)j(to)f
(accept)f(as)i(input)e(a)h(string)f(containing)f(the)i(barcode)e
(contents)515 925 y(and)23 b(a)i(string)e(containing)f(a)j(list)g(of)f
(options,)f(and)h(to)g(process)g(these)g(in)g(a)g(w)o(ay)g(that)g(is)h
(speci\002c)515 1025 y(to)k(this)h(encoder)m(,)f(and)g(\002nally)g(to)g
(output)f(an)h(instance)g(of)g(the)g(dictionary-based)d(data)j(struc-)
515 1124 y(ture)e(described)f(in)h(section)g(2.1)g(that)g(represents)g
(the)g(barcode)f(contents)g(in)i(the)f(Code)g(2)g(of)g(5)515
1224 y(symbology)-5 b(.)515 1371 y(As)17 b(with)g(all)g(of)f(the)g
(encoders,)g(the)g(input)g(string)g(is)h(assumed)f(to)h(be)f(v)n(alid)g
(for)g(the)g(corresponding)515 1471 y(symbology)-5 b(,)17
b(otherwise)i(the)i(beha)n(viour)d(is)j(unde\002ned.)515
1617 y(The)d(v)n(ariables)h(that)g(we)g(use)g(in)g(this)h(procedure)c
(are)j(con\002ned)f(to)h(local)g(scope)f(by)h(declaring)f(the)515
1717 y(procedure)f(as)k(follo)n(ws:)515 1933 y Ff(/code2of5)45
b({)726 2132 y(0)e(begin)515 2332 y(...)726 2531 y(end)515
2730 y(})f(bind)i(def)515 2830 y(/code2of5)h(load)f(0)f(1)f(dict)i(put)
515 3046 y Fk(W)-7 b(e)27 b(start)f(by)f(immediately)f(reading)g(the)i
(contents)f(strings)h(that)f(are)h(passed)f(as)i(ar)o(guments)c(to)515
3146 y(this)j(procedure)e(by)i(the)g(user)-5 b(.)44 b(W)-7
b(e)27 b(duplicate)e(the)h(options)g(string)g(because)f(it)i(is)g
(later)g(passed)515 3245 y(unamended)17 b(to)k(the)f(renderer)-5
b(.)726 3461 y Ff(/options)46 b(exch)d(def)726 3561 y(/useropts)j
(options)f(def)726 3661 y(/barcode)h(exch)d(def)515 3877
y Fk(W)-7 b(e)20 b(initialise)f(a)g(fe)n(w)g(def)o(ault)f(v)n
(ariables.)24 b(Those)18 b(v)n(ariables)g(corresponding)d(to)k(options)
f(that)h(can)515 3976 y(be)h(enabled)f(with)h(the)g(options)g(ar)o
(gument)d(are)k(initially)f(set)h(to)f(f)o(alse.)726
4192 y Ff(/includetext)47 b(false)d(def)726 4292 y(/textfont)i
(/Courier)f(def)726 4392 y(/textsize)h(10)d(def)726 4491
y(/textpos)j(-7)d(def)726 4591 y(/height)i(1)e(def)515
4807 y Fk(The)18 b(options)f(string)g(is)j(tok)o(enised)d(with)h(each)g
(successi)n(v)o(e)f(tok)o(en)h(de\002ning)f(either)g(a)i(name)e(v)n
(alue)515 4907 y(pair)j(which)g(we)h(instantiate)f(or)h(a)g(lone)f(v)n
(ariable)f(that)i(we)g(de\002ne)f(as)h(true,)g(allo)n(wing)e(us)i(to)g
(o)o(v)o(er)n(-)515 5006 y(ride)f(the)g(gi)n(v)o(en)f(def)o(ault)g(v)n
(ariables)h(gi)n(v)o(en)e(abo)o(v)o(e.)1926 5255 y(3)p
eop end
%%Page: 4 7
TeXDict begin 4 6 bop 515 523 a Ff(options)44 b({)684
623 y(token)g(false)g(eq)f({exit})i(if)e(dup)g(length)h(string)h(cvs)e
(\(=\))g(search)684 722 y(true)h(eq)f({cvlit)h(exch)g(pop)f(exch)h
(def})g({cvlit)g(true)g(def})f(ifelse)515 822 y(})f(loop)515
1049 y Fk(Since)22 b(an)o(y)g(user)h(gi)n(v)o(en)e(options)h(create)g
(v)n(ariables)g(that)h(are)g(strings)f(we)h(need)f(to)h(con)m(v)o(ert)e
(them)515 1149 y(back)e(to)i(their)f(intended)e(types.)515
1376 y Ff(/textfont)45 b(textfont)g(cvlit)f(def)515 1476
y(/textsize)h(textsize)g(cvr)f(def)515 1575 y(/textpos)h(textpos)g(cvr)
e(def)515 1675 y(/height)h(height)h(cvr)e(def)515 1902
y Fk(W)-7 b(e)23 b(then)e(create)h(an)g(array)f(of)h(string)g
(encodings)e(for)h(each)h(of)g(the)g(a)n(v)n(ailable)f(characters)g
(which)515 2002 y(we)d(then)f(declare)f(in)i(another)e(string.)24
b(This)17 b(information)f(can)h(be)g(deri)n(v)o(ed)f(from)g(careful)h
(reading)515 2101 y(of)j(the)g(rele)n(v)n(ant)f(speci\002cation,)g
(although)f(this)j(is)g(often)f(surprisingly)e(dif)n(\002cult)i(to)g
(obtain.)726 2329 y Ff(/encs)726 2428 y([)43 b(\(1111313111\))k
(\(3111111131\))f(\(1131111131\))g(\(3131111111\))811
2528 y(\(1111311131\))h(\(3111311111\))f(\(1131311111\))g
(\(1111113131\))811 2627 y(\(3111113111\))h(\(1131113111\))f
(\(313111\))f(\(311131\))726 2727 y(])e(def)726 2926
y(/barchars)j(\(0123456789\))g(def)515 3153 y Fk(W)-7
b(e)19 b(no)n(w)e(store)h(the)g(length)f(of)g(the)h(content)f(string)h
(and)f(calculate)h(the)g(total)g(number)e(of)h(bars)h(and)515
3253 y(spaces)23 b(in)g(the)f(resulting)g(barcode.)31
b(W)-7 b(e)24 b(initialise)g(a)f(string)f(of)h(size)g(dependant)e(on)h
(this)h(length)515 3353 y(into)h(which)h(we)g(will)h(b)n(uild)e(the)h
(space)g(bar)f(succession.)39 b(Similarly)-5 b(,)25 b(we)g(create)g(an)
g(array)f(into)515 3452 y(which)19 b(we)i(will)g(add)f(the)g(human)e
(readable)h(te)o(xt)h(information.)726 3680 y Ff(/barlen)45
b(barcode)g(length)f(def)726 3779 y(/sbs)g(barlen)h(10)e(mul)g(12)g
(add)g(string)i(def)726 3879 y(/txt)f(barlen)h(array)f(def)515
4106 y Fk(W)-7 b(e)21 b(no)n(w)e(be)o(gin)g(to)h(populate)e(the)i
(space)f(bar)h(succession)f(by)h(adding)e(the)i(encoding)e(of)h(the)h
(start)515 4206 y(character)f(to)h(the)g(be)o(ginning.)726
4433 y Ff(sbs)44 b(0)e(encs)i(10)f(get)h(putinterval)515
4660 y Fk(W)-7 b(e)23 b(no)n(w)e(enter)h(the)f(main)h(loop)f(which)g
(iterates)i(o)o(v)o(er)d(the)i(content)f(string)g(from)g(start)i(to)f
(\002nish,)515 4760 y(looking)c(up)i(the)g(encoding)e(for)i(each)g
(character)m(,)e(adding)h(this)i(to)f(the)g(space)g(bar)g(succession.)
515 4907 y(It)g(is)g(important)e(to)i(understand)d(ho)n(w)i(the)h
(encoding)d(for)i(a)h(gi)n(v)o(en)e(character)g(is)j(deri)n(v)o(ed.)i
(Firstly)-5 b(,)515 5006 y(gi)n(v)o(en)20 b(a)i(character)m(,)e(we)i
(\002nd)f(its)i(position)e(in)h(the)f(string)g(of)h(all)g(a)n(v)n
(ailable)f(characters.)28 b(W)-7 b(e)23 b(then)1926 5255
y(4)p eop end
%%Page: 5 8
TeXDict begin 5 7 bop 515 523 a Fk(use)17 b(this)g(position)f(to)h
(inde)o(x)e(the)i(array)f(of)h(character)e(encodings)g(to)i(obtain)f
(the)h(encoding)d(for)j(the)515 623 y(gi)n(v)o(en)i(character)m(,)h
(which)g(is)i(added)e(to)h(the)h(space/bar)e(succession.)27
b(Lik)o(e)n(wise,)21 b(the)g(character)f(is)515 722 y(added)e(to)h(the)
g(array)g(of)g(human)f(readable)g(te)o(xt)h(along)f(with)h(positioning)
f(and)h(font)f(information.)684 945 y Ff(0)43 b(1)f(barlen)j(1)e(sub)g
({)853 1044 y(/i)g(exch)h(def)853 1144 y(barcode)h(i)e(1)g(getinterval)
j(barchars)f(exch)e(search)853 1244 y(pop)853 1343 y(length)i(/indx)f
(exch)g(def)853 1443 y(pop)g(pop)853 1543 y(/enc)g(encs)g(indx)g(get)f
(def)853 1642 y(sbs)h(i)f(10)g(mul)g(6)g(add)g(enc)g(putinterval)853
1742 y(txt)h(i)f([barcode)i(i)d(1)h(getinterval)j(i)d(14)g(mul)g(10)g
(add)g(-7)1150 1841 y(textfont)i(textsize])g(put)684
1941 y(})e(for)515 2164 y Fk(The)24 b(encoding)e(for)i(the)h(end)f
(character)f(is)j(obtained)d(and)h(added)f(to)i(the)g(end)f(of)g(the)g
(space)h(bar)515 2263 y(succession.)684 2486 y Ff(sbs)43
b(barlen)i(10)e(mul)g(6)g(add)g(encs)h(11)f(get)g(putinterval)515
2708 y Fk(Finally)24 b(we)h(prepare)e(to)h(push)g(a)h(dictionary)d
(containing)h(the)h(space)h(bar)f(succession)g(\(and)f(an)o(y)515
2808 y(additional)c(information)e(de\002ned)j(in)g(section)g(2.1\))f
(that)h(will)h(be)f(passed)g(to)h(the)f(renderer)-5 b(.)726
3030 y Ff(/retval)45 b(1)e(dict)h(def)726 3130 y(retval)h(\(sbs\))f
([sbs)g({48)f(sub})h(forall])g(put)726 3230 y(retval)h(\(bhs\))f([sbs)g
(length)g(1)f(add)g(2)g(idiv)g({height})i(repeat])g(put)726
3329 y(retval)g(\(bbs\))f([sbs)g(length)g(1)f(add)g(2)g(idiv)g({0})h
(repeat])g(put)726 3429 y(includetext)j({)896 3529 y(retval)d(\(txt\))g
(txt)g(put)726 3628 y(})f(if)726 3728 y(retval)i(\(opt\))f(useropts)h
(put)726 3828 y(retval)515 4111 y Fe(2.3)99 b(The)26
b(Render)n(er)515 4314 y Fk(This)20 b(description)f(is)i(out)f(of)g
(date.)515 4461 y(The)i(procedure)e(labelled)i(barcode)f(is)j(kno)n(wn)
d(as)i(the)g(renderer)m(,)e(which)h(we)h(no)n(w)f(consider)-5
b(.)32 b(Its)515 4560 y(purpose)14 b(is)i(to)g(accept)f(as)h(input)f
(an)g(instance)g(of)g(the)h(dictionary-based)c(data)j(structure)g
(described)515 4660 y(in)29 b(section)f(2.1)g(that)h(represents)f(a)h
(barcode)e(in)i(some)g(arbitrary)e(symbology)f(and)i(produce)f(a)515
4760 y(visual)20 b(rendering)e(of)i(this)g(at)h(the)f(current)f(point.)
515 4907 y(The)f(v)n(ariables)h(that)g(we)g(use)g(in)g(this)h
(procedure)c(are)j(con\002ned)f(to)h(local)g(scope)f(by)h(declaring)f
(the)515 5006 y(procedure)f(as)k(follo)n(ws:)1926 5255
y(5)p eop end
%%Page: 6 9
TeXDict begin 6 8 bop 515 523 a Ff(/barcode)45 b({)726
722 y(0)e(begin)515 922 y(...)726 1121 y(end)515 1320
y(})f(bind)i(def)515 1420 y(/barcode)h(load)f(0)e(1)h(dict)h(put)515
1633 y Fk(W)-7 b(e)32 b(then)g(immediately)e(read)h(the)g
(dictionary-based)e(data)i(structure)g(which)g(is)h(passed)g(as)g(a)515
1733 y(single)22 b(ar)o(gument)e(to)i(this)g(procedure)e(by)i(an)g
(encoder)m(,)e(from)h(which)h(we)g(e)o(xtract)g(the)g(space)g(bar)515
1832 y(succession,)d(bar)h(height)f(succession)h(and)g(bar)g(base)g
(succession.)684 2046 y Ff(/args)44 b(exch)g(def)684
2146 y(/sbs)g(args)g(\(sbs\))g(get)f(def)684 2245 y(/bhs)h(args)g
(\(bhs\))g(get)f(def)684 2345 y(/bbs)h(args)g(\(bbs\))g(get)f(def)684
2444 y(/renderopts)j(args)e(\(opt\))g(get)f(def)515 2658
y Fk(W)-7 b(e)27 b(attempt)e(to)h(e)o(xtract)f(from)g(the)h(dictionary)
e(the)i(array)f(containing)f(the)i(information)e(about)515
2758 y(human)f(readable)g(te)o(xt.)37 b(Ho)n(we)n(v)o(er)m(,)23
b(this)i(may)f(not)g(e)o(xist)g(in)g(the)h(dictionary)d(in)j(which)e
(case)i(we)515 2857 y(create)20 b(a)g(def)o(ault)g(empty)f(array)-5
b(.)684 3071 y Ff(args)44 b(\(txt\))g(known)g({)853 3170
y(/txt)g(args)g(\(txt\))g(get)f(def)684 3270 y(})g({)853
3370 y(/txt)h([])f(def)684 3469 y(})g(ifelse)515 3683
y Fk(Just)23 b(as)g(with)f(the)g(encoders,)f(we)i(read)e(and)h(tok)o
(enise)g(the)g(supplied)f(options)g(allo)n(wing)g(speci\002c)515
3782 y(rendering)d(options)h(to)h(be)g(o)o(v)o(erridden.)684
3996 y Ff(/inkspread)46 b(0.15)e(def)684 4095 y(renderopts)i({)853
4195 y(token)f(false)f(eq)f({exit})h(if)f(dup)g(length)i(string)f(cvs)f
(\(=\))h(search)853 4295 y(true)g(eq)f({cvlit)i(exch)e(pop)h(exch)f
(def})h({cvlit)g(true)g(def})g(ifelse)684 4394 y(})f(loop)684
4494 y(/inkspread)j(inkspread)f(cvr)f(def)515 4707 y
Fk(W)-7 b(e)22 b(ha)n(v)o(e)e(e)o(xtracted)g(or)g(deri)n(v)o(ed)f(all)j
(of)e(the)h(necessary)f(information)f(from)h(the)h(input,)f(and)g(no)n
(w)515 4807 y(use)k(the)g(space)g(bar)g(succession,)g(bar)g(height)f
(succession)h(and)f(bar)h(base)g(succession)g(in)g(calcu-)515
4907 y(lations)f(that)f(create)h(a)g(single)g(array)f(containing)f
(elements)h(that)h(gi)n(v)o(e)f(coordinates)f(for)h(each)h(of)515
5006 y(the)d(bars)g(in)g(the)h(barcode.)1926 5255 y(6)p
eop end
%%Page: 7 10
TeXDict begin 7 9 bop 515 523 a Fk(W)-7 b(e)21 b(start)f(by)g(creating)
f(a)h(bars)g(array)f(that)h(is)h(half)e(the)h(length)f(of)h(the)g
(space)f(bar)h(succession.)k(W)-7 b(e)515 623 y(b)n(uild)27
b(this)i(by)e(repeatedly)g(adding)f(array)h(elements)h(that)g(contain)f
(the)h(height,)h(x-coordinate,)515 722 y(y-coordinate)18
b(and)j(width)g(of)h(single)f(bars.)28 b(The)22 b(height)e(and)h
(y-coordinates)e(are)i(read)g(from)g(the)515 822 y(bar)d(height)f
(succession)h(and)g(the)g(bar)g(base)g(succession,)g(respecti)n(v)o
(ely)-5 b(,)16 b(whilst)j(the)f(x-coordinate)515 922
y(and)24 b(the)g(width)g(are)g(made)g(from)f(a)i(calculation)e(of)h
(the)h(total)f(indent,)g(based)g(on)g(the)h(space)f(bar)515
1021 y(succession)c(and)f(a)i(compensating)d(f)o(actor)h(that)i
(accounts)e(for)g(ink)h(spread.)684 1249 y Ff(/bars)44
b(sbs)g(length)g(1)f(add)g(2)g(idiv)g(array)h(def)684
1349 y(/x)f(0.00)h(def)684 1449 y(0)f(1)f(sbs)i(length)g(1)f(sub)g({)
853 1548 y(/i)g(exch)h(def)853 1648 y(/d)f(sbs)h(i)f(get)g(48)g(sub)g
(def)853 1748 y(i)g(2)g(mod)g(0)g(eq)g({)1023 1847 y(/h)g(bhs)g(i)g(2)g
(idiv)g(get)h(72)f(mul)g(def)1023 1947 y(/c)g(d)g(2)f(div)i(x)e(add)i
(def)1023 2046 y(/y)f(bbs)g(i)g(2)g(idiv)g(get)h(72)f(mul)g(def)1023
2146 y(/w)g(d)g(inkspread)i(sub)e(def)1023 2246 y(bars)h(i)e(2)h(idiv)h
([h)f(c)f(y)h(w])g(put)853 2345 y(})g(if)853 2445 y(/x)g(x)g(d)g(add)g
(def)684 2545 y(})g(for)515 2773 y Fk(Finally)-5 b(,)22
b(we)g(perform)f(the)h(actual)g(rendering)e(in)i(tw)o(o)h(phases.)31
b(Firstly)23 b(we)f(use)h(the)f(contents)g(of)515 2872
y(the)27 b(bars)h(array)e(that)i(we)g(just)g(b)n(uilt)g(to)f(render)g
(each)g(of)g(the)h(bars,)h(and)e(secondly)f(we)i(use)g(the)515
2972 y(contents)g(of)i(the)f(te)o(xt)g(array)g(e)o(xtracted)f(from)g
(the)i(input)f(ar)o(gument)e(to)i(render)f(the)i(te)o(xt.)52
b(W)-7 b(e)515 3072 y(mak)o(e)19 b(an)g(ef)n(\002cienc)o(y)f(sa)n(ving)
i(here)f(by)g(not)g(performing)e(loading)h(and)h(rescaling)g(of)g(a)h
(font)f(if)h(the)515 3171 y(scale)26 b(f)o(actor)g(for)f(the)h(font)g
(size)g(is)i(0.)42 b(The)26 b(graphics)f(state)i(is)g(preserv)o(ed)d
(across)i(calls)h(to)f(this)515 3271 y(procedure)17 b(to)k(pre)n(v)o
(ent)d(une)o(xpected)g(interference)g(with)i(the)h(users)f(en)m
(vironment.)684 3499 y Ff(gsave)684 3698 y(bars)44 b({)853
3798 y({})f(forall)853 3898 y(setlinewidth)k(moveto)d(0)f(exch)h
(rlineto)g(stroke)684 3997 y(})f(forall)684 4196 y(txt)g({)853
4296 y({})g(forall)853 4396 y(dup)h(0)f(ne)g({exch)h(findfont)h(exch)e
(scalefont)j(setfont})853 4495 y({pop)e(pop})853 4595
y(ifelse)853 4695 y(moveto)h(show)684 4794 y(})e(forall)684
4993 y(grestore)1926 5255 y Fk(7)p eop end
%%Page: 8 11
TeXDict begin 8 10 bop 515 523 a Fe(2.4)99 b(Notes)25
b(Regarding)g(Coding)g(Style)515 726 y Fk(PostScript)16
b(programming)d(v)o(eterans)i(are)i(encouraged)c(to)k(remember)d(that)j
(the)f(majority)f(of)h(peo-)515 826 y(ple)k(who)g(read)f(the)i(code)e
(are)h(lik)o(ely)g(to)h(ha)n(v)o(e)e(little,)i(if)f(an)o(y)-5
b(,)19 b(prior)g(kno)n(wledge)f(of)i(the)g(language.)515
972 y(T)-7 b(o)20 b(encourage)e(de)n(v)o(elopment,)f(the)j(code)g(has)g
(been)g(written)g(with)g(these)g(goals)g(in)h(mind:)653
1202 y(-)41 b(That)20 b(it)h(be)f(easy)h(to)f(use)g(and)g(to)g
(comprehend)653 1368 y(-)41 b(That)20 b(it)h(be)f(easy)h(to)f(modify)f
(and)g(enhance)515 1598 y(T)-7 b(o)20 b(this)h(end)e(the)i(follo)n
(wing)d(points)i(should)f(be)h(observ)o(ed)e(for)i(all)h(ne)n(w)f(code)
f(submissions:)653 1828 y(-)41 b(Ne)n(w)21 b(encoders)e(should)g(be)h
(based)g(on)f(the)i(code)e(of)h(a)h(similar)f(e)o(xisting)f(encoder)653
1994 y(-)41 b(Include)21 b(comments)g(where)g(these)h(clarify)f(the)h
(operations)e(in)m(v)n(olv)o(ed,)h(particular)f(where)722
2094 y(something)f(une)o(xpected)f(happens)653 2260 y(-)41
b(Prefer)25 b(simplicity)g(to)g(ef)n(\002cenc)o(y)f(and)g(clarity)h(to)
g(obfuscation,)f(e)o(xcept)h(where)f(this)i(will)722
2360 y(be)20 b(a)h(problem)1926 5255 y(8)p eop end
%%Page: 9 12
TeXDict begin 9 11 bop 515 523 a Fj(3)119 b(Resour)n(ces)30
b(and)g(Examples)515 756 y Fk(There)19 b(are)h(se)n(v)o(eral)g(w)o(ays)
g(of)g(using)g(the)g(PostScript)g(within)g(your)f(o)n(wn)h(projects.)
515 903 y(Man)o(y)15 b(e)o(xample)f(uses)j(of)e(the)h(code)g(for)f(v)n
(arious)g(languages)f(and)i(platforms)f(can)g(be)h(do)n(wnloaded)515
1002 y(from)e(the)h(code)g(repository)e(at)j(http://www)-5
b(.terryb)n(urton.co.uk)o(/bar)o(cod)o(e)n(writer)o(/\002les/repo)o
(sitory)o(/)515 1287 y Fe(3.1)99 b(Language)26 b(Speci\002c)g(APIs)515
1490 y Fk(No)19 b(language)f(speci\002c)i(APIs)g(e)o(xist)g(yet.)25
b(If)20 b(you)e(ha)n(v)o(e)h(e)o(xperience)f(writing)h(API)h
(speci\002cations)515 1590 y(and)f(w)o(ould)h(lik)o(e)g(to)h(help)e
(create)h(an)g(API)h(design)e(for)h(the)g(project)g(then)f(contact)h
(the)g(author)-5 b(.)515 1875 y Fe(3.2)99 b(Fr)n(ont)25
b(Ends)515 2078 y Fk(The)20 b(follo)n(wing)e(is)j(a)g(list)g(of)f(the)g
(front)f(ends)h(a)n(v)n(ailable)g(for)g(the)g(project.)515
2307 y Fi(W)-5 b(eb)20 b(based)h(generator)39 b Fk(http://www)-5
b(.terryb)n(urton.co.uk/b)o(arc)o(ode)m(writer/g)o(ene)o(rato)o(r/)515
2473 y Fi(Scrib)n(us)42 b Fk(Scrib)n(us)26 b(v)o(ersions)g(1.3)f(and)h
(later)g(come)g(with)g(a)h(Barcode)e(Mak)o(er)h(plugin)f(based)h(on)722
2573 y(this)21 b(project.)722 2673 y(http://www)-5 b(.scrib)n(us.or)o
(g.uk)515 2839 y Fi(KBar)o(code)39 b Fk(KBarcode)20 b(v)o(ersions)f(2)h
(and)g(later)g(mak)o(e)g(use)g(of)g(this)h(project.)722
2938 y(http://www)-5 b(.kbarcode.net)515 3104 y Fi(pst-bar)o(code)39
b Fk(pst-barcode)18 b(is)k(a)e(PST)m(ricks)h(package)d(for)i(L)2270
3090 y Fh(A)2302 3104 y Fk(T)2339 3123 y(E)2379 3104
y(X.)722 3204 y(http://www)-5 b(.ctan.or)o(g/te)o(x-archi)n(v)n(e/gr)o
(aph)o(ics/pstrick)o(s/contr)o(ib/pst-b)o(arco)o(de)o(/)1926
5255 y(9)p eop end
%%Page: 10 13
TeXDict begin 10 12 bop 515 523 a Fe(3.3)99 b(Installing)31
b(the)j(Bar)n(code)f(Generation)g(Capability)f(into)h(a)f(Printer')l(s)
739 639 y(V)l(irtual)25 b(Machine)515 842 y Fk(Most)d(genuine)e
(PostScript)h(printers)g(allo)n(w)h(procedures)d(to)j(be)g(de\002ned)e
(such)i(that)f(the)o(y)g(persist)515 942 y(across)30
b(dif)n(ferent)e(jobs)i(through)e(the)j(use)f(of)g(the)g
Ff(exitserver)k Fk(command.)53 b(If)30 b(your)f(printer)515
1041 y(supports)22 b(this)h(then)g(you)f(will)i(be)f(able)g(to)g(print)
g(the)g(main)g(code)f(containing)f(the)j(de\002nitons)e(of)515
1141 y(all)e(the)f(encoders)f(and)h(the)h(renderer)d(once,)i(e.g.)24
b(soon)19 b(after)g(the)h(de)n(vice)e(is)j(turned)d(on,)h(and)f(later)
515 1241 y(omit)i(these)g(de\002nitons)f(from)h(each)f(of)h(the)h
(barcode)d(documents)h(that)h(you)f(print.)515 1388 y(T)-7
b(o)25 b(install)g(the)g(barcode)f(generation)f(capabilities)i(into)f
(the)h(virtual)g(machine)e(of)i(a)h(PostScript)515 1487
y(printer)19 b(you)g(need)h(to)g(uncomment)e(a)i(line)h(near)e(the)h
(top)g(of)g(the)g(code)g(so)h(that)f(it)h(reads:)515
1717 y Ff(serverdict)45 b(begin)g(0)d(exitserver)515
1947 y Fk(Once)24 b(this)h(code)e(is)j(printed)d(the)h(procedural)e
(de\002nitions)h(for)h(the)g(encoders)f(and)h(the)g(renderer)515
2047 y(will)g(remain)e(de\002ned)h(across)g(all)h(jobs)f(until)h(the)f
(de)n(vice)f(is)j(reset)e(either)g(by)g(po)n(wer)n(-c)o(ycling)e(or)515
2146 y(with)f(the)g(follo)n(wing)f(code:)515 2376 y Ff(serverdict)45
b(begin)g(0)d(exitserver)k(systemdict)g(/quit)e(get)f(exec)1905
5255 y Fk(10)p eop end
%%Page: 11 14
TeXDict begin 11 13 bop 515 523 a Fe(3.4)99 b(Hints)24
b(f)n(or)h(Generating)g(Pr)n(ecisely)g(the)h(Requir)n(ed)h(Symbol)515
726 y Fk(T)-7 b(o)20 b(create)f(a)i(barcode)d(to)i(a)g(required)e
(width)i(and)f(height,)g(without)g(stretching)g(the)h(human)e(read-)515
826 y(able)i(te)o(xt,)g(perform)e(the)i(follo)n(wing)f(steps.)515
972 y(Create)30 b(a)g(basic)g(symbol)f(by)g(choosing)g(the)g(rele)n(v)n
(ant)g(data)h(and)f(te)o(xt)h(options)f(for)g(the)h(corre-)515
1072 y(sponding)20 b(encoder)m(,)h(and)h(position)g(this)h(using)f
Ff(translate)k Fk(such)d(that)f(the)h Fb(bottom-left)g
Fk(corner)515 1172 y(of)d(the)g(bars)g(is)h(in)f(the)h(required)d
(location:)515 1402 y Ff(gsave)515 1501 y(430)43 b(750)g(translate)515
1601 y(\(977147396801\))k(\(includetext\))g(ean13)d(barcode)515
1700 y(grestore)515 1930 y Fk(Find)25 b(the)g(uniform)e(scale)i(f)o
(actor)g(\(same)g(v)n(alue)f(for)h(x)g(and)f(y\))h(that)g(mak)o(es)g
(your)f(output)g(of)h(the)515 2030 y(required)18 b Fb(width)p
Fk(:)515 2260 y Ff(gsave)515 2360 y(430)43 b(750)g(translate)515
2459 y(1.3)g(1.3)g(scale)256 b(\045)85 b(<--)44 b(Add)f(a)g(line)g
(like)h(this)515 2559 y(\(977147396801\))j(\(includetext\))g(ean13)d
(barcode)515 2658 y(grestore)515 2888 y Fk(Add)26 b(a)g(height)g
(option)f(that)h(adjusts)h(the)f(bar)g Fb(height)h Fk(appropriately)c
(\(taking)i(the)i(scaling)f(into)515 2988 y(account\):)515
3218 y Ff(gsave)515 3317 y(430)43 b(750)g(translate)515
3417 y(1.3)g(1.3)g(scale)515 3517 y(\045)f(Added)i(height=0.8)i(option)
f(to)e(adjust)h(height)515 3616 y(\(977147396801\))j(\(includetext)f
(height=0.8\))g(ean13)e(barcode)515 3716 y(grestore)515
3946 y Fk(The)19 b(result)g(should)g(no)n(w)f(be)i(of)f(the)g(intended)
f(dimensions)g(at)i(the)f(desired)g(location)g(with)g(prop-)515
4045 y(erly)h(scaled)g(te)o(xt.)25 b(Y)-9 b(ou)19 b(can)h(no)n(w)g(add)
f(an)o(y)h(additional)f(options)g(to)h(customise)g(the)g(symbol.)1905
5255 y(11)p eop end
%%Page: 12 15
TeXDict begin 12 14 bop 515 523 a Fe(3.5)99 b(Printing)25
b(in)g(P)n(erl)515 726 y Fk(This)h(e)o(xample)f(will)i(print)f(a)h
(page)e(of)h(EAN-13s)g(ranging)e(between)i(tw)o(o)g(gi)n(v)o(en)f(v)n
(alues)h(when)515 826 y(called)20 b(from)f(a)i(shell)f(lik)o(e)h(this:)
515 1055 y Ff($)42 b(./ean13s.pl)47 b(978186074271)f(978186074292)g(|)d
(lpr)515 1285 y Fk(The)20 b(contents)f(of)h(the)g(script)g
Ff(ean13s.pl)k Fk(is)d(as)g(follo)n(ws:)515 1515 y Ff(#!/usr/bin/perl)
47 b(-w)515 1615 y(use)c(strict;)515 1814 y(die)g('Requires)j(two)d
(arguments')j(if)d(\(@ARGV!=2\);)515 2013 y(open\(PS,'barcode.ps')q(\))
48 b(||)43 b(die)h('File)g(not)f(found';)515 2113 y
($_=join\('',<PS>\);)515 2213 y(close\(PS\);)515 2412
y(print)h("\045!PS-Adobe-2.0\\n";)515 2611 y(m/)684 2711
y(\045\\)f(--BEGIN\\)i(TEMPLATE--)684 2810 y(\(.*\))684
2910 y(\045\\)e(--END\\)i(TEMPLATE--)684 3010 y(/sx)e(||)g(die)h
('Unable)h(to)e(parse)h(out)f(the)g(template';)515 3109
y(print)h($1;)515 3309 y(for)f(\(my)g($i=$ARGV[0],)k(my)c($j=0;)h
($i<$ARGV[1];)i($i++,)e($j++\))g({)684 3408 y(my)f
($x=100+150*\(int\($j/)q(7\)\))q(;)684 3508 y(my)g
($y=100+100*\($j\0457\);)684 3607 y(print)h("gsave\\n";)684
3707 y(print)g("$x)g($y)f(translate\\n";)684 3807 y(print)h("\($i\))g
(\(includetext\))j(ean13)d(barcode\\n";)684 3906 y(print)g
("grestore\\n";)515 4006 y(})515 4205 y(print)g("showpage\\n";)1905
5255 y Fk(12)p eop end
%%Page: 13 16
TeXDict begin 13 15 bop 515 523 a Fj(4)119 b(Supported)32
b(Symbologies)515 756 y Fk(The)24 b(follo)n(wing)g(section)g(sho)n(ws)h
(the)g(symbologies)e(that)i(are)g(supported)e(by)h(the)h(encoders,)g
(in-)515 855 y(cluding)d(the)i(a)n(v)n(ailable)f(features)g(for)g
(each.)35 b(This)24 b(list)g(may)g(not)f(be)h(up-to-date.)33
b(If)23 b(it)h(does)g(not)515 955 y(contain)h(an)o(y)g(of)h(the)h
(formats)e(or)h(features)g(that)g(you)f(require)g(then)h(check)g(the)g
(project)f(source)515 1055 y(code)19 b(or)h(try)g(the)g(support)f
(mailing)h(list.)515 1340 y Fe(4.1)99 b(EAN-13)515 1528
y Fi(Data)40 b Fk(12)20 b(or)g(13)f(digits)515 1743 y
Fi(Options)888 1691 y Fk(Option)p 1401 1721 4 100 v 333
w(Feature)p 838 1724 1589 4 v 888 1794 a Ff(includetext)p
1401 1824 4 100 v 103 w Fk(Enable)g(human)g(readable)g(te)o(xt)515
1955 y Fi(Notes)41 b Fk(If)20 b(just)g(12)g(digits)g(are)g(entered)g
(then)f(the)h(check)g(digit)g(is)h(calculated)e(automatically)1603
2756 y @beginspecial @setspecial
 tx@Dict begin STP newpath 0.8 SLW 0. setgray   0 0 moveto (9781860742712)
(includetext guardwhitespace) ean13 barcode  end
 
@endspecial 534 2938
a(Figure)g(1:)26 b Ff(\(9781860742712\))47 b(\(includetext)g
(guardwhitespace\))g(ean13)d(barcode)515 3276 y Fe(4.2)99
b(EAN-8)515 3465 y Fi(Data)40 b Fk(8)20 b(digits)515
3679 y Fi(Options)888 3627 y Fk(Option)p 1401 3657 V
333 w(Feature)p 838 3660 1589 4 v 888 3730 a Ff(includetext)p
1401 3760 4 100 v 103 w Fk(Enable)f(human)g(readable)g(te)o(xt)1721
4302 y @beginspecial @setspecial
 tx@Dict begin STP newpath 0.8 SLW 0. setgray   0 0 moveto (12345678)
(includetext guardwhitespace height=0.6) ean8 barcode  end
 
@endspecial 515 4485
a(Figure)74 b(2:)136 b Ff(\(12345678\))46 b(\(includetext)g
(guardwhitespace)i(height=0.6\))e(ean8)515 4585 y(barcode)1905
5255 y Fk(13)p eop end
%%Page: 14 17
TeXDict begin 14 16 bop 515 523 a Fe(4.3)99 b(UPC-A)515
712 y Fi(Data)40 b Fk(11)20 b(or)g(12)f(digits)515 927
y Fi(Options)888 874 y Fk(Option)p 1401 904 4 100 v 333
w(Feature)p 838 908 1589 4 v 888 977 a Ff(includetext)p
1401 1007 4 100 v 103 w Fk(Enable)g(human)g(readable)g(te)o(xt)515
1139 y Fi(Notes)41 b Fk(If)20 b(just)g(11)g(digits)g(are)g(entered)g
(then)f(the)h(check)g(digit)g(is)h(calculated)e(automatically)1603
1939 y @beginspecial @setspecial
 tx@Dict begin STP newpath 0.8 SLW 0. setgray   0 0 moveto (78858101497)
(includetext) upca barcode  end
 
@endspecial 936 2122
a(Figure)h(3:)25 b Ff(\(78858101497\))47 b(\(includetext\))g(upca)c
(barcode)515 2459 y Fe(4.4)99 b(UPC-E)515 2648 y Fi(Data)40
b Fk(7)20 b(or)g(8)g(digits)515 2863 y Fi(Options)888
2810 y Fk(Option)p 1401 2840 V 333 w(Feature)p 838 2844
1589 4 v 888 2913 a Ff(includetext)p 1401 2943 4 100
v 103 w Fk(Enable)f(human)g(readable)g(te)o(xt)515 3075
y Fi(Notes)41 b Fk(If)20 b(just)g(7)h(digits)f(are)g(entered)f(then)h
(the)g(check)f(digit)h(is)h(calculated)f(automatically)1721
3875 y @beginspecial @setspecial
 tx@Dict begin STP newpath 0.8 SLW 0. setgray   0 0 moveto (0123456)
(includetext) upce barcode  end
 
@endspecial 1021 4058
a(Figure)f(4:)26 b Ff(\(0123456\))45 b(\(includetext\))i(upce)d
(barcode)1905 5255 y Fk(14)p eop end
%%Page: 15 18
TeXDict begin 15 17 bop 515 523 a Fe(4.5)99 b(EAN-5)515
712 y Fi(Data)40 b Fk(5)20 b(digits)515 927 y Fi(Options)888
874 y Fk(Option)p 1401 904 4 100 v 333 w(Feature)p 838
908 1589 4 v 888 977 a Ff(includetext)p 1401 1007 4 100
v 103 w Fk(Enable)f(human)g(readable)g(te)o(xt)1721 1790
y @beginspecial @setspecial
 tx@Dict begin STP newpath 0.8 SLW 0. setgray   0 0 moveto (90200)
(includetext guardwhitespace) ean5 barcode  end
 
@endspecial 724 1972 a(Figure)h(5:)25
b Ff(\(90200\))45 b(\(includetext)h(guardwhitespace\))i(ean5)c(barcode)
515 2288 y Fe(4.6)99 b(EAN-2)515 2477 y Fi(Data)40 b
Fk(2)20 b(digits)515 2692 y Fi(Options)888 2640 y Fk(Option)p
1401 2670 V 333 w(Feature)p 838 2673 1589 4 v 888 2743
a Ff(includetext)p 1401 2773 4 100 v 103 w Fk(Enable)f(human)g
(readable)g(te)o(xt)1839 3555 y @beginspecial @setspecial
 tx@Dict begin STP newpath 0.8 SLW 0. setgray   0 0 moveto (38) (includetext guardwhitespace)
ean2 barcode  end


@endspecial 788 3738 a(Figure)g(6:)26 b Ff(\(38\))43
b(\(includetext)k(guardwhitespace\))h(ean2)43 b(barcode)1905
5255 y Fk(15)p eop end
%%Page: 16 19
TeXDict begin 16 18 bop 515 523 a Fe(4.7)99 b(ISBN)515
712 y Fi(Data)40 b Fk(9)20 b(or)g(10)g(digits)g(seperated)f
(appropriately)f(with)i(dashes)515 927 y Fi(Options)888
874 y Fk(Option)p 1401 904 4 100 v 333 w(Feature)p 838
908 1589 4 v 888 977 a Ff(includetext)p 1401 1007 4 100
v 103 w Fk(Enable)f(human)g(readable)g(te)o(xt)515 1139
y Fi(Notes)41 b Fk(If)23 b(just)g(9)h(digits)f(are)g(entered)f(then)h
(the)g(human)f(readable)g(ISBN)i(check)e(digit)h(is)h(calcu-)722
1238 y(lated)c(automatically)1603 2039 y @beginspecial
@setspecial
 tx@Dict begin STP newpath 0.8 SLW 0. setgray   0 0 moveto (1-58880-149)
(includetext guardwhitespace) isbn barcode  end
 
@endspecial 936 2221 a(Figure)g(7:)25 b
Ff(\(1-58880-149\))47 b(\(includetext\))g(isbn)c(barcode)515
2559 y Fe(4.8)99 b(Code-39)515 2748 y Fi(Data)40 b Fk(V)-9
b(ariable)19 b(number)g(of)h(characters,)f(digits)h(and)f(an)o(y)h(of)g
(the)g(symbols)g Ff(-.)43 b(*$/+\045)p Fk(.)515 3062
y Fi(Options)888 2910 y Fk(Option)p 1698 2940 V 629 w(Feature)p
838 2943 2009 4 v 888 3013 a Ff(includecheck)p 1698 3043
4 100 v 357 w Fk(Enable)20 b(check)f(digit)888 3113 y
Ff(includetext)p 1698 3142 V 399 w Fk(Enable)h(human)e(readable)h(te)o
(xt)888 3212 y Ff(includecheckintext)p 1698 3242 V 105
w Fk(Mak)o(e)h(check)g(digit)g(visible)g(in)g(te)o(xt)1367
4025 y @beginspecial @setspecial
 tx@Dict begin STP newpath 0.8 SLW 0. setgray   0 0 moveto (CODE-39)
(includecheck includetext) code39 barcode  end
 
@endspecial 703 4207
a(Figure)g(8:)25 b Ff(\(CODE-39\))46 b(\(includecheck)g(includetext\))h
(code39)d(barcode)1905 5255 y Fk(16)p eop end
%%Page: 17 20
TeXDict begin 17 19 bop 515 523 a Fe(4.9)99 b(Code-128)25
b(and)g(UCC/EAN-128)515 712 y Fi(Data)40 b Fk(V)-9 b(ariable)20
b(number)f(of)i(ASCII)g(characters)f(and)g(special)h(funtion)f
(symbols,)g(starting)g(with)722 812 y(the)k(approriate)d(start)j
(character)f(for)f(the)i(initial)g(character)e(set.)36
b(UCC/EAN-128s)23 b(must)722 911 y(ha)n(v)o(e)d(a)h(manditory)d
Ff(FNC)43 b(1)21 b Fk(symbol)e(immediately)g(follo)n(wing)g(the)h
(start)h(character)-5 b(.)515 1176 y Fi(Options)888 1074
y Fk(Option)p 1698 1103 4 100 v 629 w(Feature)p 838 1107
2009 4 v 888 1177 a Ff(includetext)p 1698 1206 4 100
v 399 w Fk(Enable)20 b(human)e(readable)h(te)o(xt)888
1276 y Ff(includecheckintext)p 1698 1306 V 105 w Fk(Mak)o(e)h(check)g
(digit)g(visible)g(in)g(te)o(xt)515 1437 y Fi(Notes)41
b Fk(An)o(y)27 b(non-printable)e(character)i(can)i(be)f(entered)f(via)i
(its)g(escaped)f(ordinal)f(v)n(alue,)i(for)722 1537 y(e)o(xample)c
Ff(\210070)i Fk(for)e Ff(ACK)j Fk(and)d Ff(\210102)i
Fk(for)f Ff(FNC)43 b(1)p Fk(.)f(Since)26 b(a)g(caret)g(symbol)f(serv)o
(es)g(as)i(an)722 1637 y(escape)33 b(character)e(it)i(must)g(be)f
(escaped)g(as)h Ff(\210062)i Fk(if)e(used)f(in)h(the)f(data.)62
b(The)32 b(check)722 1736 y(character)19 b(is)i(al)o(w)o(ays)g(added)e
(automatically)-5 b(.)1367 2537 y @beginspecial @setspecial
 tx@Dict begin STP newpath 0.8 SLW 0. setgray   0 0 moveto (^104^102Count^0991234^101!)
(includetext) code128 barcode  end


@endspecial 555 2720 a(Figure)20 b(9:)25 b Ff
(\(\210104\210102Count\21009912)q(34\210)q(101)q(!\))49
b(\(includetext\))e(code128)d(barcode)515 3057 y Fe(4.10)99
b(Rationalized)24 b(Codabar)515 3246 y Fi(Data)40 b Fk(V)-9
b(ariable)19 b(number)g(of)h(digits)g(and)f(an)o(y)h(of)g(the)g
(symbols)g Ff(-$:/.+ABCD)p Fk(.)515 3560 y Fi(Options)888
3408 y Fk(Option)p 1698 3438 V 629 w(Feature)p 838 3441
2009 4 v 888 3511 a Ff(includecheck)p 1698 3541 4 100
v 357 w Fk(Enable)g(check)f(digit)888 3611 y Ff(includetext)p
1698 3641 V 399 w Fk(Enable)h(human)e(readable)h(te)o(xt)888
3710 y Ff(includecheckintext)p 1698 3740 V 105 w Fk(Mak)o(e)h(check)g
(digit)g(visible)g(in)g(te)o(xt)1485 4523 y @beginspecial
@setspecial
 tx@Dict begin STP newpath 0.8 SLW 0. setgray   0 0 moveto (0123456789)
(includetext) rationalizedCodabar barcode  end
 
@endspecial 619 4706 a(Figure)g(10:)k Ff(\(0123456789\))47
b(\(includetext\))g(rationalizedCodabar)h(barcode)1905
5255 y Fk(17)p eop end
%%Page: 18 21
TeXDict begin 18 20 bop 515 523 a Fe(4.11)99 b(Interlea)n(v)o(ed)25
b(2)g(of)g(5)f(and)i(ITF-14)515 712 y Fi(Data)40 b Fk(V)-9
b(ariable)18 b(number)e(of)j(digits.)24 b(An)19 b(ITF-14)e(is)i(14)f
(characters)g(and)g(does)g(not)g(ha)n(v)o(e)g(a)h(check)722
812 y(digit.)515 1126 y Fi(Options)888 974 y Fk(Option)p
1698 1004 4 100 v 629 w(Feature)p 838 1007 2009 4 v 888
1077 a Ff(includecheck)p 1698 1107 4 100 v 357 w Fk(Enable)h(check)f
(digit)888 1177 y Ff(includetext)p 1698 1206 V 399 w
Fk(Enable)h(human)e(readable)h(te)o(xt)888 1276 y Ff
(includecheckintext)p 1698 1306 V 105 w Fk(Mak)o(e)h(check)g(digit)g
(visible)g(in)g(te)o(xt)515 1437 y Fi(Notes)41 b Fk(The)21
b(data)h(may)g(be)g(automatically)f(pre\002x)o(ed)f(with)i(0)h(to)f
(mak)o(e)g(the)g(data,)g(including)e(op-)722 1537 y(tional)g(check)g
(digit,)f(of)h(e)n(v)o(en)f(length.)1367 2158 y @beginspecial
@setspecial
 tx@Dict begin STP newpath 0.8 SLW 0. setgray   0 0 moveto (05012345678900)
(includecheck height=0.7) interleaved2of5 barcode  end
 
@endspecial 515 2340 a(Figure)32 b(11:)51
b Ff(\(05012345678900\))d(\(includecheck)f(height=0.7\))f
(interleaved2of5)515 2440 y(barcode)515 2760 y Fe(4.12)99
b(Code)25 b(2)g(of)g(5)515 2949 y Fi(Data)40 b Fk(V)-9
b(ariable)19 b(number)g(of)h(digits)515 3164 y Fi(Options)888
3112 y Fk(Option)p 1401 3141 V 333 w(Feature)p 838 3145
1589 4 v 888 3215 a Ff(includetext)p 1401 3244 4 100
v 103 w Fk(Enable)f(human)g(readable)g(te)o(xt)1367 4147
y @beginspecial @setspecial
 tx@Dict begin STP newpath 0.8 SLW 0. setgray   0 0 moveto (0123456789)
(includetext textpos=75 textfont=Helvetica textsize=16) code2of5 barcode
 end
 
@endspecial 515 4330 a(Figure)75
b(12:)135 b Ff(\(0123456789\))47 b(\(includetext)f(textpos=75)g
(textfont=Helvetica)515 4429 y(textsize=16\))g(code2of5)f(barcode)1905
5255 y Fk(18)p eop end
%%Page: 19 22
TeXDict begin 19 21 bop 515 523 a Fe(4.13)99 b(P)n(ostnet)515
712 y Fi(Data)40 b Fk(V)-9 b(ariable)19 b(number)g(digits)515
976 y Fi(Options)888 874 y Fk(Option)p 1698 904 4 100
v 629 w(Feature)p 838 908 2253 4 v 888 977 a Ff(includetext)p
1698 1007 4 100 v 399 w Fk(Enable)h(human)e(readable)h(te)o(xt)888
1077 y Ff(includecheckintext)p 1698 1107 V 105 w Fk(Mak)o(e)h(the)g
(check)g(digit)g(visible)g(in)g(the)h(te)o(xt)515 1238
y Fi(Notes)41 b Fk(Check)19 b(digit)h(is)i(al)o(w)o(ays)e(added)f
(automatically)1130 1619 y @beginspecial @setspecial
 tx@Dict begin STP newpath 0.8 SLW 0. setgray   0 0 moveto (01234567)
(includetext textpos=-10 textfont=Arial textsize=10) postnet barcode
 end


@endspecial 515 1801 a(Figure)145 b(13:)277 b Ff(\(01234567\))46
b(\(includetext)g(textpos=-10)g(textfont=Arial)515 1901
y(textsize=10\))g(postnet)f(barcode)515 2233 y Fe(4.14)99
b(Royal)24 b(Mail)515 2422 y Fi(Data)40 b Fk(V)-9 b(ariable)19
b(number)g(digits)h(and)g(capital)g(letters)515 2687
y Fi(Options)888 2584 y Fk(Option)p 1698 2614 V 629 w(Feature)p
838 2618 2253 4 v 888 2687 a Ff(includetext)p 1698 2717
4 100 v 399 w Fk(Enable)g(human)e(readable)h(te)o(xt)888
2787 y Ff(includecheckintext)p 1698 2817 V 105 w Fk(Mak)o(e)h(the)g
(check)g(digit)g(visible)g(in)g(the)h(te)o(xt)515 2948
y Fi(Notes)41 b Fk(Check)19 b(digit)h(is)i(al)o(w)o(ays)e(added)f
(automatically)1367 3449 y @beginspecial @setspecial
 tx@Dict begin STP newpath 0.8 SLW 0. setgray   0 0 moveto (LE28HS9Z)
(includetext) royalmail barcode  end


@endspecial 873 3632 a(Figure)h(14:)k Ff(\(LE28HS9Z\))46
b(\(includetext\))h(royalmail)e(barcode)1905 5255 y Fk(19)p
eop end
%%Page: 20 23
TeXDict begin 20 22 bop 515 523 a Fe(4.15)99 b(MSI)515
712 y Fi(Data)40 b Fk(V)-9 b(ariable)19 b(number)g(digits)515
1026 y Fi(Options)888 874 y Fk(Option)p 1698 904 4 100
v 629 w(Feature)p 838 908 2131 4 v 888 977 a Ff(includecheck)p
1698 1007 4 100 v 357 w Fk(Enable)h(check)f(digit)888
1077 y Ff(includetext)p 1698 1107 V 399 w Fk(Enable)h(human)e(readable)
h(te)o(xt)888 1177 y Ff(includecheckintext)p 1698 1206
V 105 w Fk(Mak)o(e)h(check)g(digit)g(visible)g(in)g(the)g(te)o(xt)1249
1989 y @beginspecial @setspecial
 tx@Dict begin STP newpath 0.8 SLW 0. setgray   0 0 moveto (0123456789)
(includecheck includetext) msi barcode  end
 
@endspecial 682 2172
a(Figure)g(15:)25 b Ff(\(0123456789\))46 b(\(includecheck)h
(includetext\))f(msi)e(barcode)515 2488 y Fe(4.16)99
b(Plessey)515 2677 y Fi(Data)40 b Fk(V)-9 b(ariable)19
b(number)g(of)h(he)o(xadecimal)e(characters)515 2924
y Fi(Options)888 2822 y Fk(Option)p 1698 2852 V 629 w(Feature)p
838 2855 2286 4 v 888 2925 a Ff(includetext)p 1698 2955
4 100 v 399 w Fk(Enable)i(human)e(readable)h(te)o(xt)888
3025 y Ff(includecheckintext)p 1698 3055 V 105 w Fk(Mak)o(e)h(the)g
(check)g(digits)g(visible)g(in)h(the)f(te)o(xt)515 3186
y Fi(Notes)41 b Fk(Check)19 b(digits)i(are)f(al)o(w)o(ays)g(added)f
(automatically)-5 b(.)540 3987 y @beginspecial @setspecial
 tx@Dict begin STP newpath 0.8 SLW 0. setgray   0 0 moveto (0123456789ABCDEF)
(includetext) plessey barcode  end


@endspecial 831 4169 a(Figure)19 b(16:)25 b Ff(\(012345ABCDEF\))47
b(\(includetext\))g(plessey)e(barcode)1905 5255 y Fk(20)p
eop end
%%Page: 21 24
TeXDict begin 21 23 bop 515 523 a Fj(5)119 b(License)515
756 y Fk(Cop)o(yright)894 753 y(c)871 756 y Fa(\015)p
Fk(2004)19 b(T)-6 b(erry)20 b(Burton)515 903 y(Permission)27
b(is)i(hereby)d(granted,)i(free)f(of)h(char)o(ge,)g(to)g(an)o(y)f
(person)f(obtaining)g(a)j(cop)o(y)e(of)g(this)515 1002
y(softw)o(are)c(and)g(associated)h(documentation)d(\002les)j(\(the)g
(\224Softw)o(are\224\),)f(to)h(deal)f(in)h(the)g(Softw)o(are)515
1102 y(without)18 b(restriction,)h(including)e(without)i(limitation)f
(the)i(rights)e(to)i(use,)f(cop)o(y)-5 b(,)18 b(modify)-5
b(,)17 b(mer)o(ge,)515 1202 y(publish,)f(distrib)n(ute,)h(sublicense,)g
(and/or)f(sell)i(copies)f(of)g(the)g(Softw)o(are,)g(and)g(to)g(permit)f
(persons)515 1301 y(to)k(whom)f(the)i(Softw)o(are)e(is)i(furnished)e
(to)h(do)g(so,)g(subject)g(to)g(the)h(follo)n(wing)d(conditions:)515
1448 y(The)24 b(abo)o(v)o(e)g(cop)o(yright)e(notice)j(and)f(this)i
(permission)d(notice)i(shall)g(be)g(included)e(in)i(all)h(copies)515
1548 y(or)20 b(substantial)g(portions)e(of)i(the)h(Softw)o(are.)515
1695 y(The)28 b(softw)o(are)h(is)g(pro)o(vided)e(\224as)i(is\224,)j
(without)c(w)o(arranty)f(of)i(an)o(y)f(kind,)i(e)o(xpress)e(or)h
(implied,)515 1794 y(including)24 b(b)n(ut)j(not)f(limited)g(to)g(the)h
(w)o(arranties)e(of)h(merchantability)-5 b(,)25 b(\002tness)i(for)f(a)h
(particular)515 1894 y(purpose)f(and)i(noninfringement.)45
b(In)28 b(no)g(e)n(v)o(ent)f(shall)i(the)f(authors)f(or)h(cop)o(yright)
e(holders)i(be)515 1993 y(liable)19 b(for)g(an)o(y)g(claim,)g(damages)f
(or)i(other)e(liability)-5 b(,)19 b(whether)f(in)i(an)f(action)g(of)g
(contract,)g(tort)g(or)515 2093 y(otherwise,)25 b(arising)f(from,)h
(out)g(of)f(or)h(in)g(connection)e(with)i(the)g(softw)o(are)f(or)h(the)
g(use)g(or)f(other)515 2193 y(dealings)19 b(in)i(the)f(softw)o(are.)
1905 5255 y(21)p eop end
%%Trailer

userdict /end-hook known{end-hook}if
%%EOF
