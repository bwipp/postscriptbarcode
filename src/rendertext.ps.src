% Barcode Writer in Pure PostScript
% https://bwipp.terryburton.co.uk
%
% vim: set sw=4 sts=4 et:
%
% Copyright (c) 2004-2025 Terry Burton
%
% $Id$
%
% Permission is hereby granted, free of charge, to any
% person obtaining a copy of this software and associated
% documentation files (the "Software"), to deal in the
% Software without restriction, including without
% limitation the rights to use, copy, modify, merge,
% publish, distribute, sublicense, and/or sell copies of
% the Software, and to permit persons to whom the Software
% is furnished to do so, subject to the following
% conditions:
%
% The above copyright notice and this permission notice
% shall be included in all copies or substantial portions
% of the Software.
%
% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY
% KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
% THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
% PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
% THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
% DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
% CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
% CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
% IN THE SOFTWARE.

% --BEGIN RESOURCE rendertext--
% --REQUIRES preamble raiseerror setuphooks setanycolor--
currentglobal
true setglobal
/setpacking where {pop currentpacking true setpacking} if
2 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /setanycolor dup /uk.co.terryburton.bwipp findresource put
begin

/rendertext.positions <<
%   direction
%       x-align                                     y-align
    (forward) <<
        (offleft)  {      tw neg nudge sub } bind   (below)   {      th neg nudge sub } bind
        (left)     {      0                } bind   (bottom)  {      0                } bind
        (xcenter)  { pixx tw sub 2 div     } bind   (ycenter) { pixy th sub 2 div     } bind
        (right)    { pixx tw sub           } bind   (top)     { pixy th sub           } bind
        (offright) { pixx        nudge add } bind   (above)   { pixy        nudge add } bind
    >>
    (backward) <<
        (offleft)  {      0      nudge sub } bind   (below)   {      0      nudge sub } bind
        (left)     {      tw               } bind   (bottom)  {      th               } bind
        (xcenter)  { pixx tw add 2 div     } bind   (ycenter) { pixy th add 2 div     } bind
        (right)    { pixx                  } bind   (top)     { pixy                  } bind
        (offright) { pixx tw add nudge add } bind   (above)   { pixy th add nudge add } bind
    >>
    (upward) <<
        (offleft)  {      0      nudge sub } bind   (below)   {      tw neg nudge sub } bind
        (left)     {      th               } bind   (bottom)  {      0                } bind
        (xcenter)  { pixx th add 2 div     } bind   (ycenter) { pixy tw sub 2 div     } bind
        (right)    { pixx                  } bind   (top)     { pixy tw sub           } bind
        (offright) { pixx th add nudge add } bind   (above)   { pixy        nudge add } bind
    >>
    (downward) <<
        (offleft)  {      th neg nudge sub } bind   (below)   {      0      nudge sub } bind
        (left)     {      0                } bind   (bottom)  {      tw               } bind
        (xcenter)  { pixx th sub 2 div     } bind   (ycenter) { pixy tw add 2 div     } bind
        (right)    { pixx th sub           } bind   (top)     { pixy                  } bind
        (offright) { pixx        nudge add } bind   (above)   { pixy tw add nudge add } bind
    >>
>> readonly def

/rendertext {

    % x-align y-align direction text-width text-height
    /positiontext {
        /th exch def
        /tw exch def
        /nudge 1 def
        //rendertext.positions exch get dup
        4 -1 roll dup (center) eq {pop (xcenter)} if get exec exch
        3 -1 roll dup (center) eq {pop (ycenter)} if get exec
    } def

    % Display the text for elements in the text array
    includetext {

        textcolor (unset) ne { textcolor //setanycolor exec } if

        textxalign (unset) eq textyalign (unset) eq and alttext () eq and {
            /s 0 def /fn () def
            txt {
                aload pop
                2 copy s ne exch fn ne or {
                    dup 0 le {
                        pop pop pop pop pop
                        /bwipp.fontTooSmall (The font size is too small) //raiseerror exec
                    } if
                    2 copy /s exch def /fn exch def
                    selectfont
                } {
                    pop pop
                } ifelse
                moveto show
            } forall
        } {

            alttext () eq {
                /txt [ txt { 0 get {} forall } forall ] def
                /tstr txt length string def
                0 1 txt length 1 sub { dup txt exch get tstr 3 1 roll put } for
            } {
                /tstr alttext def
                0 1 alttext length 1 sub {
                    dup
                    alttext exch 1 getinterval alttextsubspace exch search {
                        alttext 4 index 32 put pop pop
                    } if
                    pop pop
                } for
            } ifelse

            alttext () ne alttextsplit () ne and {
                alttextsplit length 1 ne {
                    /bwipp.alttextsplitBad (The alttextsplit option must be a single character) //raiseerror exec
                } if
                /textlines [
                    tstr { alttextsplit search { exch pop exch } { exit } ifelse } loop
                ] def
            } {
                /textlines [ tstr ] def
            } ifelse

            textfont textsize selectfont

            % Find true ascent of font
            tstr length 0 eq {
                0
            } {
                gsave
                newpath 0 0 moveto (0) false charpath pathbbox
                4 1 roll pop pop pop
                grestore
                currentfont /PaintType known {currentfont /PaintType get 2 eq} {false} ifelse
                currentfont /StrokeWidth known and {
                    currentfont /StrokeWidth get 2 div 0 exch
                    currentfont /FontMatrix get dtransform
                    dup mul exch dup mul add sqrt
                    add
                } if
            } ifelse
            /textascent exch def

            /textwidth 0 textlines { stringwidth pop 2 copy lt {exch} if pop } forall tstr length 1 sub textgaps mul add def
            /textheight textlines length dup textascent mul exch 1 sub textlinegaps mul add def

            textxalign (unset) eq { /textxalign (center) def } if
            textyalign (unset) eq { /textyalign (below)  def } if

            textxalign (justify) eq {
                textdirection (forward) ne textdirection (backward) ne and {
                    /bwipp.textxjustify (textxalign=justify requires forward or backward text) //raiseerror exec
                } if
                textwidth pixx lt {
                    /textgaps pixx textwidth sub tstr length 1 sub div def
                    /textxalign textdirection (forward) eq { (left) } { (right) } ifelse def
                } {
                    /textgaps 0.0 def
                    /textxalign (center) def
                } ifelse
            } if

            textyalign (justify) eq {
                textdirection (upward) ne textdirection (downward) ne and {
                    /bwipp.textyjustify (textyalign=justify requires upward or downward text) //raiseerror exec
                } if
                textwidth pixy lt {
                    /textgaps pixy textwidth sub tstr length 1 sub div def
                    /textyalign textdirection (upward) eq { (bottom) } { (top) } ifelse def
                } {
                    /textgaps 0.0 def
                    /textyalign (center) def
                } ifelse
            } if

            textxalign textyalign textdirection textwidth textheight positiontext exec moveto
            textxoffset textyoffset rmoveto
            gsave
            << (forward) 0  (upward) 90  (backward) 180  (downward) 270 >> textdirection get rotate
            currentpoint translate
            0 1 textlines length 1 sub {
                /i exch def
                0 0 textascent textlinegaps add i mul add moveto
                textgaps 0 textlines dup length i sub 1 sub get ashow
            } for
            grestore

        } ifelse

    } if

    % Render any extratext
    extratext () ne {

        0 1 extratext length 1 sub {
            dup
            extratext exch 1 getinterval extratextsubspace exch search {
                extratext 4 index 32 put pop pop
            } if
            pop pop
        } for

        extratextsplit () ne {
            extratextsplit length 1 ne {
                /bwipp.extratextsplitBad (The extratextsplit option must be a single character) //raiseerror exec
            } if
            /textlines [
                extratext { extratextsplit search { exch pop exch } { exit } ifelse } loop
            ] def
        } {
            /textlines [ extratext ] def
        } ifelse

        extratextcolor (unset) ne { extratextcolor //setanycolor exec } if
        extratextfont extratextsize selectfont

        % Find true ascent of font
        gsave
        newpath 0 0 moveto (0) false charpath pathbbox
        4 1 roll pop pop pop
        grestore
        currentfont /PaintType known {currentfont /PaintType get 2 eq} {false} ifelse
        currentfont /StrokeWidth known and {
            currentfont /StrokeWidth get 2 div 0 exch
            currentfont /FontMatrix get dtransform
            dup mul exch dup mul add sqrt
            add
        } if
        /textascent exch def

        /textwidth 0 textlines { stringwidth pop 2 copy lt {exch} if pop } forall extratext length 1 sub extratextgaps mul add def
        /textheight textlines length dup textascent mul exch 1 sub extratextlinegaps mul add def

        extratextxalign (justify) eq {
            extratextdirection (forward) ne extratextdirection (backward) ne and {
                /bwipp.extratextxjustify (extratextxalign=justify requires forward or backward text) //raiseerror exec
            } if
            textwidth pixx lt {
                /extratextgaps pixx textwidth sub extratext length 1 sub div def
                /extratextxalign extratextdirection (forward) eq { (left) } { (right) } ifelse def
            } {
                /extratextgaps 0.0 def
                /extratextxalign (center) def
            } ifelse
        } if

        extratextyalign (justify) eq {
            extratextdirection (upward) ne extratextdirection (downward) ne and {
                /bwipp.extratextyjustify (extratextyalign=justify requires upward or downward text) //raiseerror exec
            } if
            textwidth pixy lt {
                /extratextgaps pixy textwidth sub extratext length 1 sub div def
                /extratextyalign extratextdirection (upward) eq { (bottom) } { (top) } ifelse def
            } {
                /extratextgaps 0.0 def
                /extratextyalign (center) def
            } ifelse
        } if

        extratextxalign extratextyalign extratextdirection textwidth textheight positiontext exec moveto
        extratextxoffset extratextyoffset rmoveto
        gsave
        << (forward) 0  (upward) 90  (backward) 180  (downward) 270 >> extratextdirection get rotate
        currentpoint translate
        0 1 textlines length 1 sub {
            /i exch def
            0 0 textascent extratextlinegaps add i mul add moveto
            extratextgaps 0 textlines dup length i sub 1 sub get ashow
        } for
        grestore

    } if

}
[/barcode] {null def} forall
bind def
/rendertext dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
setglobal
% --END RESOURCE rendertext--
