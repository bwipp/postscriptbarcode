% Barcode Writer in Pure PostScript
% https://bwipp.terryburton.co.uk
%
% Copyright (c) 2004-2025 Terry Burton
%
% $Id$
%
% Permission is hereby granted, free of charge, to any
% person obtaining a copy of this software and associated
% documentation files (the "Software"), to deal in the
% Software without restriction, including without
% limitation the rights to use, copy, modify, merge,
% publish, distribute, sublicense, and/or sell copies of
% the Software, and to permit persons to whom the Software
% is furnished to do so, subject to the following
% conditions:
%
% The above copyright notice and this permission notice
% shall be included in all copies or substantial portions
% of the Software.
%
% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY
% KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
% THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
% PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
% THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
% DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
% CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
% CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
% IN THE SOFTWARE.

% --BEGIN RENDERER renmatrix--
% --REQUIRES preamble raiseerror processoptions rendertext--
currentglobal
true setglobal
/setpacking where {pop currentpacking true setpacking} if
8 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /processoptions dup /uk.co.terryburton.bwipp findresource put
dup /rendertext dup /uk.co.terryburton.bwipp findresource put
begin

/renmatrix.xalignopts <<
    /offleft dup  /left dup  /center dup  /right dup  /offright dup
>> readonly def

/renmatrix.yalignopts <<
    /above dup  /top dup  /center dup  /bottom dup  /below dup
>> readonly def

/renmatrix.directionoptions <<
    /forward dup  /backward dup  /upward dup  /downward dup
>> readonly def

/renmatrix.left  1 def
/renmatrix.right 2 def
/renmatrix.up    4 def
/renmatrix.down  8 def

%
% Direction lookup table indexed by 2x2 neighbourhood:
%
%   +---+---+
%   |A=8|B=4|
%   +---*---+
%   |C=2|D=1|
%   +---+---+
%
/renmatrix.tracestep [

                                                           %  0 0
    null                                                   %   ?
                                                           %  0 0

                                                           %  0 0
    {right}                                                %   +>
                                                           %  0|1

                                                           %  0 0
    {down}                                                 %  -+
                                                           %  1v0

                                                           %  0 0
    {right}                                                %  -->
                                                           %  1 1

                                                           %  0^1
    {up}                                                   %   +-
                                                           %  0 0

                                                           %  0^1
    {up}                                                   %   |
                                                           %  0|1

                                                           %  0 1      0^1
    {dup //renmatrix.right eq {down} {up} ifelse} bind     %  -+   or   +-
                                                           %  1v0      1 0

                                                           %  0^1
    {up}                                                   %  -+
                                                           %  1 1

                                                           %  1|0
    {left}                                                 %  <+
                                                           %  0 0

                                                           %  1|0      1 0
    {dup //renmatrix.down eq {left} {right} ifelse} bind   %  <+   or   +>
                                                           %  0 1      0|1

                                                           %  1|0
    {down}                                                 %   |
                                                           %  1v0

                                                           %  1|0
    {right}                                                %   +>
                                                           %  1 1

                                                           %  1 1
    {left}                                                 %  <--
                                                           %  0 0

                                                           %  1 1
    {left}                                                 %  <+
                                                           %  0|1

                                                           %  1 1
    {down}                                                 %   +-
                                                           %  1v0

                                                           %  1 1
    null                                                   %   ?
                                                           %  1 1

] readonly def

/renmatrix {

    128 dict begin

    % Default options
    /width 1.0 def
    /height 1.0 def
    /barcolor (unset) def
    /backgroundcolor (unset) def
    /bordercolor (unset) def
    /colormap (unset) def
    /dotty false def
    /inkspread null def    % real sentinal
    /inkspreadh null def   % real sentinal
    /inkspreadv null def   % real sentinal
    /txt [] def
    /includetext false def
    /textcolor (unset) def
    /textxalign (unset) def
    /textyalign (unset) def
    /textdirection (forward) def
    /textfont (Courier) def
    /textsize 10.0 def
    /textxoffset 0.0 def
    /textyoffset 0.0 def
    /textgaps 0.0 def
    /textlinegaps 1.2 def
    /alttext () def
    /alttextsplit () def
    /alttextsubspace () def
    /extratext () def
    /extratextsubspace () def
    /extratextsplit () def
    /extratextlinegaps 1.2 def
    /extratextcolor (unset) def
    /extratextxalign (left) def
    /extratextyalign (above) def
    /extratextdirection (forward) def
    /extratextfont (Courier) def
    /extratextsize 10.0 def
    /extratextxoffset 0.0 def
    /extratextyoffset 0.0 def
    /extratextgaps 0.0 def
    /showborder false def
    /borderleft 0.0 def
    /borderright 0.0 def
    /bordertop 0.0 def
    /borderbottom 0.0 def
    /borderwidth 0.25 def

    {def} forall
    opt currentdict /opt undef //processoptions exec pop

    inkspread null eq {/inkspread 0.15 def} if
    inkspreadh null eq {/inkspreadh inkspread def} if
    inkspreadv null eq {/inkspreadv inkspread def} if

    /uk.co.terryburton.bwipp.global_ctx dup where {
        exch get /ctx exch def
        barcolor        (unset) eq { ctx /default_barcolor        2 copy known {get /barcolor        exch def} {pop pop} ifelse } if
        backgroundcolor (unset) eq { ctx /default_backgroundcolor 2 copy known {get /backgroundcolor exch def} {pop pop} ifelse } if
        bordercolor     (unset) eq { ctx /default_bordercolor     2 copy known {get /bordercolor     exch def} {pop pop} ifelse } if
    } { pop } ifelse

    %
    % Input validation
    %
    textxalign (unset) ne {
        //renmatrix.xalignopts textxalign known not {
            /bwipp.renmatrixBadTextxalign (textxalign must be offleft, left, center, right or offright) //raiseerror exec
        } if
    } if

    textyalign (unset) ne {
        //renmatrix.yalignopts textyalign known not {
            /bwipp.renmatrixBadTextyalign (textyalign must be above, top, center, bottom or below) //raiseerror exec
        } if
    } if

    //renmatrix.directionoptions textdirection known not {
        /bwipp.renmatrixBadTextdirection (textdirection must be forward, backward, upward or downward) //raiseerror exec
    } if

    textsize 0 le textsize 25 ge or {
        /bwipp.renmatrixBadTextsize (textsize must be greater than zero and less that 25) //raiseerror exec
    } if

    //renmatrix.xalignopts extratextxalign known not {
        /bwipp.renmatrixBadExtratextxalign (extratextxalign must be offleft, left, center, right or offright) //raiseerror exec
    } if

    //renmatrix.yalignopts extratextyalign known not {
        /bwipp.renmatrixBadExtratextyalign (extratextyalign must be above, top, center, bottom or below) //raiseerror exec
    } if

    //renmatrix.directionoptions extratextdirection known not {
        /bwipp.renmatrixBadExtratextdirection (extratextdirection must be forward, backward, upward or downward) //raiseerror exec
    } if

    extratextsize 0 le extratextsize 25 ge or {
        /bwipp.renmatrixBadTextsize (extratextsize must be greater than zero and less that 25) //raiseerror exec
    } if

    /xyget { pixx mul add pixs exch get } def
    /cget { pixx mul add cache exch get and } def
    /cput {  % Optimise by only storing "stem" corners
        dup dup //renmatrix.up eq exch //renmatrix.left eq or {  % dir is up or left
            3 1 roll pixx mul add cache exch 2 copy get 4 -1 roll or put
        } {
            pop pop pop
        } ifelse
    } def

    /abcd {
        pixx mul add      dup 1 add  % A B
        1 index pixx add  dup 1 add  % C D
             pixs exch get
        exch pixs exch get 2 mul add
        exch pixs exch get 4 mul add
        exch pixs exch get 8 mul add
    } def

    /pack   { pixxpad mul add } def                    % x y -> y*pixxpad+x
    /unpack { dup pixxpad mod exch pixxpad idiv } def  % packed -> x y

    %
    % Stack: x y dir -> (packed vertex?) x' y' dir'
    %
    /left {
        dup //renmatrix.left ne {
            3 copy cput
            2 index 2 index pack 4 1 roll
        } if
        pop
        exch 1 sub exch  % x--
        //renmatrix.left
    } def

    /right {
        dup //renmatrix.right ne {
            3 copy cput
            2 index 2 index pack 4 1 roll
        } if
        pop
        exch 1 add exch  % x++
        //renmatrix.right
    } def

    /up {
        dup //renmatrix.up ne {
            3 copy cput
            2 index 2 index pack 4 1 roll
        } if
        pop
        1 sub  % y--
        //renmatrix.up
    } def

    /down {
        dup //renmatrix.down ne {
            3 copy cput
            2 index 2 index pack 4 1 roll
        } if
        pop
        1 add  % y++
        //renmatrix.down
    } def

    %
    % Walk the outline of a region emitting edge coordinates of the path
    %
    /trace {
        /y exch def  /x exch def
        /dir x 1 add y 1 add xyget 1 eq {//renmatrix.up} {//renmatrix.left} ifelse def
        /sx x def  /sy y def  /sdir dir def

        mark x y dir
        {  % [vertex...] x y dir
            //renmatrix.tracestep 3 index 3 index abcdget get exec
            dup sdir eq { 1 index sy eq { 2 index sx eq {
                pop pop pop exit
            } if } if } if
        } loop
        counttomark array astore exch pop

    } def

    %
    % Set RGB or CMYK color, or some other color by name
    %
    /setanycolor {
        /anycolor exch def
        anycolor length 1 lt {
            /bwipp.colorEnpty (Colors must not be empty) //raiseerror exec
        } if
        anycolor 0 get 95 ne {  % RGB or CMYK
            anycolor length dup 6 ne exch 8 ne and {
                /bwipp.colorBadLength (Colors must be 6 or 8 hexadecimal characters or a defined name beginning with underscore) //raiseerror exec
            } if
            mark
            0 2 anycolor length 1 sub {
                anycolor exch 2 getinterval 0 exch {
                    dup dup 48 ge exch  57 le and {48 sub} {  % 0-9
                    dup dup 65 ge exch  70 le and {55 sub} {  % A-F
                    dup dup 97 ge exch 102 le and {87 sub} {  % a-f
                        cleartomark /bwipp.colorBadCharacter (RGB and CMYK Colors must be in hexadecimal notation) //raiseerror exec
                    } ifelse } ifelse } ifelse
                    exch 16 mul add
                } forall
                255 div
            } for
            counttomark
            dup 3 eq { /DeviceRGB } { /DeviceCMYK } ifelse
            exch 2 add -1 roll pop  % clear mark
        } {  % Named color beginning "_..."
            /uk.co.terryburton.bwipp.global_ctx dup where {exch get} {0 dict} ifelse
            /named_colors 2 copy known {get} {pop pop 0 dict} ifelse
            anycolor 2 copy known not {
                pop pop /bwipp.colorUnknown (Color is not defined) //raiseerror exec
            } if
            get mark exch aload pop counttomark 1 add -2 roll exch pop
        } ifelse
        { setcolorspace setcolor } stopped {
            /bwipp.colorFailedToSet (Failed to set color) //raiseerror exec
        } if
    } def

    %
    % Plot a layer of single colour
    %
    /drawlayer {

        /pixsorig pixs def
        /pixs exch def

        % Pad the bitmap on all sides
        /pixs [
            pixx 2 add {0} repeat
            0 pixx pixs length 1 sub {
                0 exch
                pixs exch pixx getinterval aload pop
                0
            } for
            pixx 2 add {0} repeat
        ] def
        /pixx pixx 2 add def
        /pixy pixy 2 add def
        /pixxpad pixx def

        %
        % Cache of visited corners for each direction
        %
        /cache [ pixs length {0} repeat ] def

        %
        % Pre-compute abcd values (printed neighbours) for all cells
        %
        /abcdcache [
            0 1 pixy 2 sub {
                0 1 pixx 2 sub {
                    1 index abcd exch % result j
                } for
                pop
            } for
        ] def

        /abcdget { pixx 1 sub mul add abcdcache exch get } def

        %
        % Construct paths by tracing regions avoiding duplication by using the cache
        %
        /paths [
            0 1 pixy 2 sub {
                /j exch def
                0 1 pixx 2 sub {
                    /i exch def
                    /k i j abcdget def
                    k 2#0001 eq                           % Black region stem corners:
                    k 2#1001 eq or {                      %
                        //renmatrix.up i j cget 0 eq {    %   0 0       1 0
                            i j trace                     %    *   and   *
                        } if                              %   0 1       0 1
                    } if
                    k 2#1110 eq {                         % White region stem corner:
                        //renmatrix.left i j cget 0 eq {  %
                            i j trace                     %   1 1
                        } if                              %    *
                    } if                                  %   1 0
                } for
            } for
        ] def

        %
        % Revert the bitmap size
        %
        /pixx pixx 2 sub def
        /pixy pixy 2 sub def

        %
        % Draw the image
        %
        newpath
        paths {
            /p exch def
            /len p length def
            p len 1 sub get unpack
            p 0 get unpack
            0 1 len 1 sub {                                % x1 y1 x2 y2
                /i exch def
                p i 1 add len mod get unpack 6 -2 roll     % x3 y3 x1 y1 x2 y2
                5 index inkspreadh
                4 index 4 -1 roll lt {add} {sub} ifelse    % y3<y1 ? x2+i : x2-i
                4 1 roll
                4 index inkspreadv
                4 index 4 -1 roll gt {add} {sub} ifelse    % x3>x1 ? y2+i : y2-i
                4 -1 roll exch pixy exch sub
                i 0 eq {moveto} {lineto} ifelse
            } for                                          % x2 y2 x3 y3
            closepath
            pop pop pop pop
        } forall
        fill

        /pixs pixsorig def

    } def

    /drawlayerdots {

        /pixsorig pixs def
        /pixs exch def

        newpath
        0 1 pixs length 1 sub {
            dup pixx mod /x exch def
            pixx idiv /y exch def
            x y xyget 1 eq {
               x 0.5 add pixy y sub 0.5 sub moveto
               x 0.5 add pixy y sub 0.5 sub 0.5 inkspread sub 0 360 arc
            } if
        } for
        fill

        /pixs pixsorig def

    } def

    gsave

    currentpoint translate

    /inkspread  inkspread  2 div def
    /inkspreadh inkspreadh 2 div def
    /inkspreadv inkspreadv 2 div def

    %
    % Force symbol to given width
    %
    width pixx div 72 mul height pixy div 72 mul scale

    %
    % Display the border and background
    %
    showborder {
        /tl [ borderleft borderwidth 2 div add neg        pixy bordertop add borderwidth 2 div add ] def
        /tr [ pixx borderright add borderwidth 2 div add  pixy bordertop add borderwidth 2 div add ] def
        /bl [ borderleft borderwidth 2 div add neg        borderbottom borderwidth 2 div add neg   ] def
        /br [ pixx borderright add borderwidth 2 div add  borderbottom borderwidth 2 div add neg   ] def
    } {  % No need to extend background when there is no border
        /tl [ borderleft neg inkspread add                pixy bordertop add inkspread sub         ] def
        /tr [ pixx borderright add inkspread sub          pixy bordertop add inkspread sub         ] def
        /bl [ borderleft neg inkspread add                borderbottom neg inkspread add           ] def
        /br [ pixx borderright add inkspread sub          borderbottom neg inkspread add           ] def
    } ifelse
    backgroundcolor (unset) ne {
        gsave
        newpath bl aload pop moveto [ br tr tl ] { aload pop lineto } forall closepath
        backgroundcolor setanycolor fill
        grestore
    } if
    showborder {
        gsave
        newpath bl aload pop moveto [ br tr tl ] { aload pop lineto } forall closepath
        bordercolor (unset) ne { bordercolor setanycolor } if
        borderwidth inkspread 2 mul sub setlinewidth stroke
        grestore
    } if

    %
    % Display the matrix
    %
    colormap (unset) eq {
        /colormap << 1 barcolor >> def
    } if

    colormap {
        dup (unset) ne { setanycolor } { pop } ifelse
        /key exch def
        [
            pixs { key eq {1} {0} ifelse } forall
        ] dotty {drawlayerdots} {drawlayer} ifelse
    } forall

    %
    % Display the text
    %
    //rendertext exec

    grestore

    end

}
[/barcode] {null def} forall
bind def
/renmatrix dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
setglobal
% --END RENDERER renmatrix--
