% Barcode Writer in Pure PostScript
% https://bwipp.terryburton.co.uk
%
% vim: set sw=4 sts=4 et:
%
% Copyright (c) 2004-2025 Terry Burton
%
% $Id$
%
% Permission is hereby granted, free of charge, to any
% person obtaining a copy of this software and associated
% documentation files (the "Software"), to deal in the
% Software without restriction, including without
% limitation the rights to use, copy, modify, merge,
% publish, distribute, sublicense, and/or sell copies of
% the Software, and to permit persons to whom the Software
% is furnished to do so, subject to the following
% conditions:
%
% The above copyright notice and this permission notice
% shall be included in all copies or substantial portions
% of the Software.
%
% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY
% KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
% THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
% PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
% THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
% DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
% CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
% CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
% IN THE SOFTWARE.

% --BEGIN ENCODER codeone--
% --REQUIRES preamble raiseerror processoptions parseinput setanycolor rendertext renmatrix--
% --DESC: Code One
% --EXAM: Code One
% --EXOP:
% --RNDR: renmatrix
currentglobal
true setglobal
/setpacking where {pop currentpacking true setpacking} if
32 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /processoptions dup /uk.co.terryburton.bwipp findresource put
dup /parseinput dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin

/codeone.versionopts <<
   [ (T-16) (T-32) (T-48) (S-10) (S-20) (S-30) (A) (B) (C) (D) (E) (F) (G) (H) ]
   {dup} forall
>> readonly def

/codeone.stypevals [
    (1)
    (1010)
    (1100100)
    (1111101000)
    (10011100010000)
    (11000011010100000)
    (11110100001001000000)
    (100110001001011010000000)
    (101111101011110000100000000)
    (111011100110101100101000000000)
    (1001010100000010111110010000000000)
    (1011101001000011101101110100000000000)
    (1110100011010100101001010001000000000000)
    (10010001100001001110011100101010000000000000)
    (10110101111001100010000011110100100000000000000)
    (11100011010111111010100100110001101000000000000000)
    (100011100001101111001001101111110000010000000000000000)
    (101100011010001010111100001011101100010100000000000000000)
] readonly def

%
% Basic metrics for the each symbol
%
/codeone.stypemetrics [
%     ver    row col dcol dcws rscw rsbl  ro ri rl
    [ (S-10)   8  11   10    4    4    1  99 99 99 ]
    [ (S-20)   8  21   20    8    8    1  99 99 99 ]
    [ (S-30)   8  31   30   12   12    1  99 99 99 ]
] readonly def

%
% Basic metrics for the each symbol
%
/codeone.nonstypemetrics [
%     ver    row col dcol dcws rscw rsbl  ro ri rl
    [ (A)     16  18   16   10   10    1   4 99  6 ]
    [ (B)     22  22   20   19   16    1   4 99  8 ]
    [ (C)     28  32   28   44   26    1   4 22 11 ]
    [ (D)     40  42   36   91   44    1   4 16 16 ]
    [ (E)     52  54   48  182   70    1   4 22 22 ]
    [ (F)     70  76   68  370  140    2   4 22 31 ]
    [ (G)    104  98   88  732  280    4   6 21 47 ]
    [ (H)    148 134  120 1480  560    8   6 20 69 ]
    [ (T-16)  16  17   16   10   10    1  99 99 99 ]
    [ (T-32)  16  33   32   24   16    1  99 99 99 ]
    [ (T-48)  16  49   48   38   22    1  99 99 99 ]
] readonly def

%
% Special characters
%
/codeone.fnc1   -1 def  /codeone.fnc3  -2 def
/codeone.lc     -5 def  /codeone.lb    -6 def  /codeone.lx    -7 def  /codeone.lt    -8 def  /codeone.ld    -9 def  /codeone.unl -10 def
/codeone.fnc2  -11 def  /codeone.fnc4 -12 def  /codeone.sft1 -13 def  /codeone.sft2 -14 def  /codeone.sft3 -15 def  /codeone.eci -16 def  /codeone.pad -17 def  /codeone.fnc1ld -18 def
/codeone.unlcw 255 def

/codeone.a 0 def  /codeone.c 1 def  /codeone.t 2 def  /codeone.x 3 def  /codeone.d 4 def  /codeone.b 5 def

/codeone.encfuncs [ /encA /encCTX /encCTX /encCTX /encD /encB ] readonly def

/codeone.cpatmap <<
    /A (121343)
    /B (12134343)
    /C (12121343)
    /D (1213434343)
    /E (1212134343)
    /F (1212121343)
    /G (121213434343)
    /H (121212134343)
    /S (56661278)
    /T (5666666666127878)
>> readonly def

/codeone.blackdotmap <<
    /A [ [12 5] ]
    /B [ [16 7] ]
    /C [ [26 12] ]
    /D []
    /E [ [26 23] ]
    /F [ [26 32] [70 32] [26 34] [70 34] ]
    /G [ [27 48] [69 48] ]
    /H [ [26 70] [66 70] [106 70] [26 72] [66 72] [106 72] ]
    /S-10 []
    /S-20 [ [10 4] ]
    /S-30 [ [15 4] [15 6] ]
    /T-16 [ [8 10] ]
    /T-32 [ [16 10] [16 12] ]
    /T-48 [ [24 10] [24 12] [24 14] ]
>> readonly def

%
% Reed-Solomon parameters
%
/codeone.rsparams [
    % GF  PM
    [] [] [] [] []
    [  32  37 ]   % 5-bit S-type codewords
    [] []
    [ 256 301 ]   % 8-bit standard codewords
] readonly def

/codeone.latevars dup 16 dict def load /init {

    currentglobal
    true setglobal

    //codeone.latevars begin

    %
    % Character mapping dictionaries
    %
    /avals <<
        0 1 128 {dup 1 add} for
        //codeone.pad 129
        0 1 99 {  % Double digits
            dup 10 2 string cvrs (00) 2 string copy dup 2 3 index length sub 4 -1 roll putinterval
            exch 130 add
        } for
        229 [ //codeone.lc //codeone.lb //codeone.fnc1 //codeone.fnc2 //codeone.fnc3 //codeone.fnc4 //codeone.fnc1ld ] {exch 1 add dup} forall pop
        //codeone.lx 238
        //codeone.lt 239
        % 240-255 lD + 4 bits
    >> def
    /avals <<
        avals {[exch]} bind forall
    >> def

    /cnvals <<
        //codeone.sft1 0
        //codeone.sft2 1
        //codeone.sft3 2
        32   3
        48 1 57 {dup 44 sub} for  % 0-9
        65 1 90 {dup 51 sub} for  % A-Z
    >> readonly def
    /c1vals << 0 1 31 {dup} for >> readonly def
    /c2vals <<
        33 1 47 {dup 33 sub} for
        58 1 64 {dup 43 sub} for
        91 1 95 {dup 69 sub} for
        //codeone.fnc1 27
        //codeone.fnc2 28
        //codeone.fnc3 29
        //codeone.fnc4 30
        //codeone.pad  31
    >> readonly def
    /c3vals << 96 1 127 {dup 96 sub} for >> readonly def
    /cvals <<
        cnvals {[exch]} bind forall
        c1vals {[exch cnvals //codeone.sft1 get exch]} bind forall
        c2vals {[exch cnvals //codeone.sft2 get exch]} bind forall
        c3vals {[exch cnvals //codeone.sft3 get exch]} bind forall
    >> def

    /tnvals <<
        //codeone.sft1 0
        //codeone.sft2 1
        //codeone.sft3 2
        32   3
        48 1  57 {dup 44 sub} for  % 0-9
        97 1 122 {dup 83 sub} for  % a-z
    >> readonly def
    /t1vals << 0 1 31 {dup} for >> readonly def
    /t2vals <<
        33 1 47 {dup 33 sub} for
        58 1 64 {dup 43 sub} for
        91 1 95 {dup 69 sub} for
        //codeone.fnc1 27
        //codeone.fnc2 28
        //codeone.fnc3 29
        //codeone.fnc4 30
        //codeone.pad  31
    >> readonly def
    /t3vals <<
         96 0
         65 1  90 {dup 64 sub} for
        123 1 127 {dup 96 sub} for
    >> readonly def
    /tvals <<
        tnvals {[exch]} bind forall
        t1vals {[exch tnvals //codeone.sft1 get exch]} bind forall
        t2vals {[exch tnvals //codeone.sft2 get exch]} bind forall
        t3vals {[exch tnvals //codeone.sft3 get exch]} bind forall
    >> def

    %
    % Extended ASCII mappings
    %
    128 1 255 {
        /i exch def
        avals i [ avals //codeone.fnc4 get aload pop avals i 128 sub get aload pop ] put
        cvals i [ cvals //codeone.fnc4 get aload pop cvals i 128 sub get aload pop ] put
        tvals i [ tvals //codeone.fnc4 get aload pop tvals i 128 sub get aload pop ] put
    } bind for
    /avals avals readonly def
    /cvals cvals readonly def
    /tvals tvals readonly def

    /xvals <<
        13 0
        42 1
        62 2
        32 3
        48 1 57 {dup 44 sub} for
        65 1 90 {dup 51 sub} for
    >> readonly def
    /xvals <<
        xvals {[exch]} bind forall
    >> readonly def

    /bvals <<
        0 1 255 {dup} for
    >> readonly def
    /bvals <<
        bvals {[exch]} bind forall
    >> readonly def

    /encvals [ avals cvals tvals xvals -1 bvals ] readonly def

    %
    % Calculate the log and anti-log tables for each Galois field
    %
    /rstables [
        //codeone.rsparams {
            dup length 0 ne {
                aload pop /rspm exch def /rsgf exch def
                /rsalog [ 1 rsgf 1 sub { dup 2 mul dup rsgf ge {rspm xor} if } repeat ] def
                /rslog rsgf array def
                1 1 rsgf 1 sub {dup rsalog exch get exch rslog 3 1 roll put} for
                [ rslog rsalog ]
            } {
                pop []
            } ifelse
        } forall
    ] readonly def

    /init { //codeone.latevars {def} forall } def

    end

    //codeone.latevars /init get exec

    setglobal

} bind put

/uk.co.terryburton.bwipp.global_ctx dup where {
    exch get /preload known {//codeone.latevars /init get exec} if
} {pop} ifelse

/codeone {

    128 dict begin

    /dontdraw false def
    /version (unset) def
    /parse false def
    /parsefnc false def

    //processoptions exec /options exch def
    /barcode exch def

    /_render
        dontdraw /uk.co.terryburton.bwipp.global_ctx dup where {exch get /enabledontdraw known} {pop false} ifelse and
        /uk.co.terryburton.bwipp._dontdraw dup where {exch get} {pop false} ifelse or not
    def

    //codeone.latevars /init get exec

    version (unset) ne {
        //codeone.versionopts version known not {
            /bwipp.codeoneBadVersion (version must be A to H, T-16, T-32, T-48, S-10, S-20 or S-30) //raiseerror exec
        } if
    } if

    /stype version 0 1 getinterval (S) eq def
    /ttype version 0 1 getinterval (T) eq def

    stype {

        barcode {
            dup 48 lt exch 57 gt or {
                /bwipp.codeoneStypeNonDigit (S-Type symbols can only contain digits) //raiseerror exec
            } if
        } forall

        /barlen barcode length def
        barlen 18 gt {
            /bwipp.codeoneStypeTooLong (Maximum length exceeded) //raiseerror exec
        } if

        /normalize {
            /base exch def
            /num exch def
            num length 1 sub -1 1 {
                /i exch def
                num i 1 sub 2 copy get num i get base idiv add put
                num i num i get base mod put
            } for
            { % loop - extend input as necessary
                num 0 get base lt {exit} if
                /num [0 num aload pop] def
                num 0 num 0 get num 1 get base idiv add put
                num 1 num 1 get base mod put
            } loop
            % Trim leading zeros
            /num [/i true def num {dup 0 eq i and {pop} {/i false def} ifelse} forall] def
            num length 0 eq {/num [0] def} if
            num
        } def

        /bigadd {
            2 copy length exch length
            2 copy sub abs /offset exch def
            lt {exch} if
            /a exch def /b exch def
            0 1 b length 1 sub {
                dup a exch offset add 2 copy get b 5 -1 roll get add put
            } for
            a
        } def

        /barlen barcode length def

        %
        % Convert value plus one to binary
        %
        /v [ 1 ] def
        0 1 barlen 1 sub {
            /i exch def
            [ //codeone.stypevals i get {48 sub barcode barlen i sub 1 sub get 48 sub mul} forall ]
            v bigadd /v exch def
        } for
        /v v 2 normalize def

        %
        % Split into 5-bit codewords
        %
        /v [ 5 v length 5 mod sub 5 mod {0} repeat v aload pop ] def
        /cws v length 5 idiv array def
        0 1 cws length 1 sub {
            /i exch def
            v i 5 mul 5 getinterval
            0 exch {add 2 mul} forall 2 idiv
            cws exch i exch put
        } for

        /metrics //codeone.stypemetrics def

    } {  % Standard and type-T

        %
        % Convert input into bytes accounting for FNC characters
        %
        /fncvals <<
            /parse parse
            /parsefnc parsefnc
            /eci true
            (FNC1) //codeone.fnc1
            (FNC3) //codeone.fnc3
        >> def
        barcode fncvals //parseinput exec /msg exch def
        /msglen msg length def

        %
        % Code One stores ECIs in data
        %
        /eciesc 16#5c def  % We choose \ as a typical default
        /numecis 0 msg { -1000000 le {1 add} if } forall def
        numecis 0 gt {
            /msgtmp msg length 2 mul numecis 6 mul add 2 add array def
            msgtmp 0 //codeone.pad put
            msgtmp 1 eciesc put
            /j 2 def
            0 1 msg length 1 sub {
                msg exch get
                dup -1000000 le {
                    neg 10 7 string cvrs 1 6 getinterval {} forall 6 array astore
                    msgtmp exch j 1 add exch putinterval
                    msgtmp j eciesc put
                    /j j 7 add def
                } {
                    dup eciesc ne {
                        msgtmp exch j exch put
                        /j j 1 add def
                    } {
                        pop
                        msgtmp j eciesc put
                        msgtmp j 1 add eciesc put
                        /j j 2 add def
                    } ifelse
                } ifelse
            } for
            /msg msgtmp 0 j getinterval def
            /msglen msg length def
        } if

        /metrics //codeone.nonstypemetrics def

        %
        % Select metrics of an appropriate symbol
        %
        /fullcws [] def
        metrics {
            /m exch def
            /vers m 0 get def           % Version of symbol
            /dcws m 4 get def           % Data codewords in symbol
            /okay true def
            version (unset) eq {
                vers length 1 ne {/okay false def} if
            } {
                version vers ne {/okay false def} if
            } ifelse
            okay {/fullcws [ fullcws aload pop dcws ] def} if
        } forall
        /numremcws [ 1480 {10000} repeat ] def
        fullcws {numremcws exch 1 sub 1 put} bind forall
        1478 -1 0 {
            /i exch def
            numremcws i get 1 ne {
                numremcws i numremcws i 1 add get 1 add put
            } if
        } for

        /numD [ msglen {0} repeat 0 ] def
        /nextXterm [ msglen {0} repeat 9999 ] def
        /nextNonX  [ msglen {0} repeat 9999 ] def
        msglen 1 sub -1 0 {
            /i exch def
            /barchar msg i get def
            barchar 48 ge barchar 57 le and {
                numD i numD i 1 add get 1 add put
            } if
            barchar 13 eq barchar 42 eq or barchar 62 eq or {
                nextXterm i 0 put
            } {
                nextXterm i nextXterm i 1 add get 1 add put
            } ifelse
            xvals barchar known not {
                nextNonX i 0 put
            } {
                nextNonX i nextNonX i 1 add get 1 add put
            } ifelse
        } for
        /nextXterm [nextXterm {dup 10000 gt {pop 10000} if} forall] def
        /nextNonX  [nextNonX  {dup 10000 gt {pop 10000} if} forall] def

        /isD  {char 48 ge char 57 le and} def
        /isC  {cnvals char known} def
        /isT  {tnvals char known} def
        /isX  {xvals char known} def
        /isEA {char 127 gt} def
        /isFN {char 0 lt} def
        /XtermFirst {dup nextXterm exch get exch nextNonX exch get lt} def

        /lookup {
            /ac 1 def /cc 2 def /tc 2 def /xc 2 def /bc 3 def
            mode //codeone.a eq {/ac 0 def /cc 1 def /tc 1 def /xc 1 def /bc 2 def} if
            mode //codeone.c eq {/cc 0 def} if
            mode //codeone.t eq {/tc 0 def} if
            mode //codeone.x eq {/xc 0 def} if  % Assume mistake in spec
            mode //codeone.b eq {/bc 0 def} if
            1 {  % common exit
                /k 0 def {  % loop
                    i k add msglen eq {
                        true [ac cc tc xc   ] {bc         exch ceiling le and} forall {//codeone.b exit} if
                        true [   cc tc xc bc] {ac         exch ceiling le and} forall {//codeone.a exit} if
                        true [      tc xc   ] {cc ceiling exch ceiling le and} forall {//codeone.c exit} if
                        true [         xc   ] {tc ceiling exch ceiling le and} forall {//codeone.t exit} if
                        //codeone.x exit
                    } if
                    /char msg i k add get def
                    /ac ac isD {1 2 div add} {isEA {ceiling 2 add} {ceiling 1 add} ifelse} ifelse def
                    /cc cc isC {2 3 div add} {isEA { 8 3 div add } { 4 3 div add } ifelse} ifelse def
                    /tc tc isT {2 3 div add} {isEA { 8 3 div add } { 4 3 div add } ifelse} ifelse def
                    /xc xc isX {2 3 div add} {isEA {13 3 div add } {10 3 div add } ifelse} ifelse def
                    /bc bc isFN {3 add} {1 add} ifelse def
                    k 3 ge {  % Checking after at least 4 characters (cf. Data Matrix), not 3 as in spec Step Q
                        true [ac cc tc xc   ] {bc 1 add exch ceiling le and} forall {//codeone.b exit} if
                        true [   cc tc xc bc] {ac 1 add exch ceiling le and} forall {//codeone.a exit} if
                        true [ac cc    xc bc] {tc ceiling 1 add exch ceiling le and} forall {//codeone.t exit} if
                        true [ac    tc      ] {cc ceiling 1 add exch ceiling le and} forall {
                            cc ceiling xc ceiling lt {//codeone.c exit} if
                            cc xc eq {i k add 1 add XtermFirst {//codeone.x exit} {//codeone.c exit} ifelse} if
                        } if
                        true [ac cc tc    bc] {xc ceiling 1 add exch ceiling le and} forall {//codeone.x exit} if
                    } if
                    /k k 1 add def
                } loop
            } repeat
        } def

        /addtocws {
            dup length j add 1480 gt {
                pop /bwipp.codeoneTooLong (Maximum length exceeded) //raiseerror exec
            } if
            dup cws exch j exch putinterval
            /j exch length j add def
        } def

        /tobin {
            string dup length 1 sub 0 exch 1 exch {1 index exch 48 put} for
            dup 3 -1 roll 2 2 index length string cvrs dup length 2 index length exch sub exch putinterval
            [ exch {48 sub} forall ]
        } def

        %
        % Decimal mode: 3 digits -> 10 bits, plus entry/unlatch/padding overhead
        %
        /Dbitsbuf msglen 10 mul 3 idiv 20 add array def
        /Dbitslen 0 def

        % Helper to append bits to Dbitsbuf
        /appendbits {  % bits... count -> -
            /apnd_n exch def              % bits...
            apnd_n array astore           % [bits]
            Dbitsbuf Dbitslen 3 -1 roll putinterval  % -
            /Dbitslen Dbitslen apnd_n add def        % -
        } def

        /encA {
            1 {  % Common exit
                numD i get 21 ge {
                    % Initialize Dbits buffer with [ 1 1 1 1 ]
                    Dbitsbuf 0 1 put  Dbitsbuf 1 1 put  Dbitsbuf 2 1 put  Dbitsbuf 3 1 put
                    /Dbitslen 4 def
                    /mode //codeone.d def
                    exit
                } if
                numD i get dup 13 ge exch i add msglen eq and {
                    % Initialize Dbits buffer with [ 1 1 1 1 ]
                    Dbitsbuf 0 1 put  Dbitsbuf 1 1 put  Dbitsbuf 2 1 put  Dbitsbuf 3 1 put
                    /Dbitslen 4 def
                    /mode //codeone.d def
                    exit
                } if
                numD i get 2 ge {
                    2 string dup 0 msg i get put dup 1 msg i 1 add get put avals exch get addtocws
                    /i i 2 add def
                    exit
                } if
                msg i get //codeone.fnc1 eq {
                    numD i 1 add get 15 ge {
                        avals //codeone.fnc1ld get addtocws
                        /i i 1 add def
                        /Dbitslen 0 def  % Initialize Dbits buffer as empty
                        /mode //codeone.d def
                        exit
                    } if
                    numD i 1 add get dup 7 ge exch i add 1 add msglen eq and {
                        avals //codeone.fnc1ld get addtocws
                        /i i 1 add def
                        /Dbitslen 0 def  % Initialize Dbits buffer as empty
                        /mode //codeone.d def
                        exit
                    } if
                } if
                /newmode lookup def
                newmode mode ne {
                    avals [-1 //codeone.lc //codeone.lt //codeone.lx //codeone.ld //codeone.lb] newmode get get addtocws
                    /mode newmode def
                    exit
                } if
                avals msg i get get addtocws
                /i i 1 add def
                exit
            } repeat
        } def

        /CTXvalstocws {
            /in exch def
            mark
            0 3 in length 1 sub {
                in exch 3 getinterval 0 exch {add 40 mul} forall 40 idiv 1 add
                dup 256 idiv exch 256 mod
            } for
            counttomark array astore exch pop
        } def

        /encCTX {
            /p 0 def
            /ctxvals 2220 array def

            %
            % Lookup the values for each character
            %
            {
                i msglen eq {exit} if
                p 3 mod 0 eq {
                    numD i get 12 ge {
                        ctxvals 0 p getinterval CTXvalstocws addtocws
                        [//codeone.unlcw] addtocws
                        /mode //codeone.a def
                        exit
                    } if
                    numD i get dup 8 ge exch i add msglen eq and {
                        ctxvals 0 p getinterval CTXvalstocws addtocws
                        [//codeone.unlcw] addtocws
                        /mode //codeone.a def
                        exit
                    } if
                    mode //codeone.x eq {  % Steps E1c, E2
                        xvals msg i get known not {
                            ctxvals 0 p getinterval CTXvalstocws addtocws
                            % Unlatch to ASCII unless one codeword left and single ASCII to encode
                            numremcws j get 1 ne msg i get 127 gt or {
                                [//codeone.unlcw] addtocws
                            } if
                            /mode //codeone.a def
                            exit
                        } if
                        i 1 add msglen lt {
                            xvals msg i 1 add get known not {exit} if
                            i 2 add msglen lt {
                                xvals msg i 2 add get known not {exit} if
                            } if
                        } if
                    } {
                        lookup mode ne {
                            ctxvals 0 p getinterval CTXvalstocws addtocws
                            [//codeone.unlcw] addtocws
                            /mode //codeone.a def
                            exit
                        } if
                    } ifelse
                    msglen i sub 3 le {  % Check end of data conditions
                        /remcws numremcws j p 3 idiv 2 mul add get def
                        /remvals [
                            msg i msglen i sub getinterval {
                                dup encvals mode get exch known {
                                    encvals mode get exch get aload pop
                                } {  % Unencodable X12 characters
                                    pop -1 -1 -1 -1
                                } ifelse
                            } forall
                        ] def
                        remcws 2 eq remvals length 3 eq and {
                            % Encode and omit unlatch
                            [
                                ctxvals 0 p getinterval aload pop
                                remvals aload pop
                            ] CTXvalstocws addtocws
                            /mode //codeone.a def
                            /i msglen def
                            exit
                        } if
                        remcws 2 eq remvals length 2 eq and mode //codeone.x ne and {
                            % Encode with sft1 as third value, omit unlatch
                            [
                                ctxvals 0 p getinterval aload pop
                                remvals aload pop
                                encvals mode get //codeone.sft1 get aload pop
                            ] CTXvalstocws addtocws
                            /mode //codeone.a def
                            /i msglen def
                            exit
                        } if
                        remcws 2 eq remvals length 1 eq and {
                            % Unlatch to ASCII
                            ctxvals 0 p getinterval CTXvalstocws addtocws
                            [//codeone.unlcw] addtocws
                            avals msg i get get addtocws
                            /mode //codeone.a def
                            /i msglen def
                            exit
                        } if
                        remcws 1 eq remvals length 1 eq and {
                            % Implied unlatch to ASCII
                            ctxvals 0 p getinterval CTXvalstocws addtocws
                            avals msg i get get addtocws
                            /mode //codeone.a def
                            /i msglen def
                            exit
                        } if
                    } if
                } if
                encvals mode get msg i get get
                dup ctxvals exch p exch putinterval
                /p exch length p add def
                /i i 1 add def
            } loop

            %
            % Backtrack to a boundary and return to ASCII
            %
            mode //codeone.a ne {
                {
                    p 3 mod 0 eq {exit} if
                    /i i 1 sub def
                    /p p encvals mode get msg i get get length sub def
                } loop
                [
                    ctxvals 0 p getinterval aload pop
                ] CTXvalstocws addtocws
                [//codeone.unlcw] addtocws
                /mode //codeone.a def
                i msglen ne {  % Encode something to avoid latching immediately back
                    numD i get 2 ge {
                        2 string dup 0 msg i get put dup 1 msg i 1 add get put avals exch get addtocws
                        /i i 2 add def
                    } {
                        avals msg i get get addtocws
                        /i i 1 add def
                    } ifelse
                } if
            } if

        } def

        /encD {

            {  % loop

                numD i get 3 lt {

                    /Drem 8 Dbitslen 8 mod sub 8 mod def
                    /remcws numremcws j Dbitslen 8 idiv add get def

                    %
                    % Final codeword with no data
                    %
                    numremcws j Dbitslen 8 idiv add 1 sub get 1 sub 0 eq Drem 0 eq and  % No remaining codewords and no bits
                    remcws 1 eq Drem 0 ne and or  % Or 1 remaining codeword and some bits
                    i msglen eq and {
                        Drem 4 eq Drem 6 eq or {
                            1 1 1 1  4 appendbits
                        } if
                        Drem 2 eq Drem 6 eq or {
                            0 1  2 appendbits
                        } if
                        exit
                    } if

                    %
                    % Final digit or double-digit into final codeword as ASCII
                    %
                    i msglen 1 sub eq numD i get 1 eq and
                    i msglen 2 sub eq numD i get 2 eq and or
                    remcws 1 eq and Drem 0 eq and {exit} if

                    %
                    % Latch to ASCII unless 4 or 6 bits remain in final codeword
                    %
                    i msglen 1 sub eq numD i get 1 eq and
                    remcws 1 eq and Drem 4 eq Drem 6 eq or and not {
                        1 1 1 1 1 1  6 appendbits
                        /Drem 8 Dbitslen 8 mod sub 8 mod def
                    } if

                    %
                    % Try to encode a digit in remaining bits
                    %
                    Drem 4 eq Drem 6 eq or {
                        numD i get 1 ge {
                            msg i get 48 sub 1 add 4 tobin aload pop  4 appendbits
                            /i i 1 add def
                        } {
                            1 1 1 1  4 appendbits
                        } ifelse
                        /Drem Drem 4 sub def
                    } if
                    Drem 2 eq {
                        0 1  2 appendbits
                        /Drem 0 def
                    } if

                    exit

                } if

                %
                % Three digit value plus one to ten bits
                %
                0 msg i 3 getinterval {48 sub add 10 mul} forall 10 idiv
                1 add 10 tobin aload pop  10 appendbits
                /i i 3 add def

            } loop

            /Dbits Dbitsbuf 0 Dbitslen getinterval def
            mark
            Dbitslen 0 gt {
                0 8 Dbitslen 1 sub {
                    Dbits exch 8 getinterval 0 exch {add 2 mul} forall 2 idiv
                } for
            } if
            counttomark array astore exch pop addtocws
            /mode //codeone.a def

        } def

        /encB {
            /p 0 def /bvals 1480 array def {
                i msglen eq {exit} if
                msg i get 0 lt {exit} if  % Function character
                lookup mode ne {exit} if
                bvals p msg i get put
                /p p 1 add def
                /i i 1 add def
            } loop
            /remcws numremcws j p add get 1 sub def
            /bvals [
                remcws 0 eq i msglen eq and {  % Terminates symbol
                    0
                } {
                    p 250 lt {p} {p 250 idiv 249 add p 250 mod} ifelse
                } ifelse
                bvals 0 p getinterval aload pop
            ] def
            bvals addtocws
            /mode //codeone.a def
        } def

        %
        % Derive the codewords
        %
        /cws 1480 array def
        /mode //codeone.a def /i 0 def /j 0 def {
            i msglen ge {exit} if
            //codeone.encfuncs mode get load exec
        } loop
        /cws cws 0 j getinterval def

    } ifelse

    %
    % Select metrics of an appropriate symbol
    %
    metrics {
        /m exch def
        /vers m 0 get def           % Version of symbol
        /rows m 1 get def           % Rows in symbol
        /cols m 2 get def           % Columns in symbol
        /dcol m 3 get def           % Data columns in symbol
        /dcws m 4 get def           % Data codewords in symbol
        /rscw m 5 get def           % Error correction codewords
        /rsbl m 6 get def           % Error correction blocks
        /riso m 7 get def           % Riser offset
        /risi m 8 get def           % Riser interval
        /risl m 9 get def           % Riser length
        /dcpb dcws rsbl idiv def    % Data codewords per block
        /ecpb rscw rsbl idiv def    % Error codewords per block
        /okay true def
        version (unset) ne version vers ne and {/okay false def} if  % The version must match that supplied
        cws length dcws gt {/okay false def} if
        okay {exit} if
    } forall

    okay not {
        /bwipp.codeoneNoValidSymbol (Maximum length exceeded) //raiseerror exec
    } if

    %
    % Extend cws to ncws codewords by addition of pad characters
    %
    stype not {
        /cws [ cws aload pop dcws cws length sub {129} repeat ] def
    } {
        /cws [ dcws cws length sub {0} repeat cws aload pop ] def
    } ifelse

    options /debugcws known
    /uk.co.terryburton.bwipp.global_ctx dup where {exch get /enabledebug known} {pop false} ifelse
    and { /bwipp.debugcws cws //raiseerror exec } if

    %
    % De-interleave the codewords into blocks
    %
    /cwbs rsbl array def  % Array of data codeword blocks
    /ecbs rsbl array def  % Array of error correction blocks
    0 1 rsbl 1 sub {
        /i exch def
        /cwb dcpb array def
        0 1 dcpb 1 sub {
            /j exch def
            cwb j cws j rsbl mul i add get put
        } for
        cwbs i cwb put
    } for

    %
    % Get log and anti-log tables from pre-calculated tables
    %
    /rsbt stype {5} {8} ifelse def
    /rslog rstables rsbt get 0 get def
    /rsalog rstables rsbt get 1 get def
    /gf rsalog length def
    /gf-1 gf 1 sub def

    /rsprod {
        dup 0 ne { 1 index 0 ne {
            rslog exch get exch rslog exch get add gf-1 mod rsalog exch get
        } { pop pop 0 } ifelse } { pop pop 0 } ifelse
    } def

    %
    % Generate the coefficients for the Reed-Solomon algorithm
    %
    /coeffs [ 1 ecpb {0} repeat ] def
    0 1 ecpb 1 sub {  % i
        rsalog 1 index get                        % ai = rsalog[i]
        exch dup 1 add                            % ai i i+1
        coeffs exch 2 copy 1 sub get put          % ai i ; coeffs[i+1] = coeffs[i]
        -1 1 {  % j
            coeffs exch 2 copy get                % ... coeffs j coeffs[j]
            3 index                               % ... ai
            rsprod                                % p = coeffs[j] * ai
            coeffs 2 index 1 sub get              % ... coeffs[j-1]
            xor put                               % coeffs[j] = p ^ coeffs[j-1]
        } for
        coeffs 0 2 copy get 3 index rsprod put    % coeffs[0] = coeffs[0] * ai
        pop  % ai
    } for
    /coeffs coeffs 0 coeffs length 1 sub getinterval def

    %
    % Reed-Solomon algorithm to derive the error correction codewords
    %
    0 1 cwbs length 1 sub {
        /i exch def
        /rscws [ cwbs i get aload pop ecpb {0} repeat ] def
        0 1 dcpb 1 sub {  % m
            rscws 1 index get                               % k = rscws[m]
            0 1 ecpb 1 sub {  % j
                rscws 3 index 2 index add 1 add 2 copy get  % ... rscws m+j+1 rscws[m+j+1]
                coeffs ecpb 6 -1 roll sub 1 sub get         % ... coeffs[ecpb-j-1]
                4 index                                     % ... k
                rsprod                                      % p = coeffs[ecpb-j-1] * k
                xor put                                     % rscws[m+j+1] = rscws[m+j+1] ^ p
            } for
            pop  % k
            pop  % m
        } for
        ecbs i rscws dcpb ecpb getinterval put
    } for

    %
    % Extend codewords with the interleaved error correction codes
    %
    /cws [ cws aload pop rscw {0} repeat ] def
    0 1 rscw 1 sub {
        /i exch def
        cws dcws i add ecbs i rsbl mod get i rsbl idiv get put
    } for

    %
    % Module matrix for layout of the codewords
    %
    /mmat dcws rscw add stype {5} {8} ifelse mul array def
    /r 0 def /c 0 def
    0 stype {2} {1} ifelse cws length 1 sub {
        /i exch def
        stype not {
            (00000000) 8 string copy dup cws i get 2 8 string cvrs
            dup length 8 exch sub exch putinterval [ exch {48 sub} forall ]
            dup 0 4 getinterval /top exch def
            4 4 getinterval /bot exch def
        } {
            (00000) 5 string copy dup cws i get 2 5 string cvrs
            dup length 5 exch sub exch putinterval [ exch {48 sub} forall ]
            /c1 exch def
            (00000) 5 string copy dup cws i 1 add get 2 5 string cvrs
            dup length 5 exch sub exch putinterval [ exch {48 sub} forall ]
            /c2 exch def
            /top [ c1 0 3 getinterval aload pop c2 0 2 getinterval aload pop ] def
            /bot [ c1 3 2 getinterval aload pop c2 2 3 getinterval aload pop ] def
        } ifelse
        mmat r dcol mul c add top putinterval
        mmat r 1 add dcol mul c add bot putinterval
        /c c top length add def
        c dcol eq {/c 0 def /r r 2 add def} if
    } for

    %
    % Create bitmap and add finder patterns
    %
    /mmv {cols mul add} def
    /pixs [ rows cols mul {-1} repeat ] def

    %
    % Centre pattern
    %
    /artifact [
        {cols {0} repeat}
        {cols {1} repeat}
        {0   cols 2 sub {1} repeat   0}
        {0 1 cols 4 sub {0} repeat 1 0}
        {cols 1 sub 2 idiv {-1} repeat 1 cols 1 sub 2 idiv {-1} repeat}
        {cols 1 sub 2 idiv {-1} repeat 0 cols 1 sub 2 idiv {-1} repeat}
        {1   cols 2 sub {0} repeat   1}
        {1 0 cols 4 sub {1} repeat 0 1}
    ] def
    /cpat //codeone.cpatmap vers 0 1 getinterval get def
    pixs 0 rows cpat length sub 2 idiv mmv
    [ cpat {artifact exch 49 sub get exec} forall ] putinterval

    %
    % Risers
    %
    0 1 risl 1 sub {
        /i exch def
        riso risi cols 1 sub {
            /j exch def
            [ 1 i 12 mod 0 eq {1} {0} ifelse ] dup
            pixs j i mmv
            3 -1 roll putinterval
            i risl 1 sub ne {
                pixs cols j sub 2 sub rows i sub 1 sub mmv
                3 -1 roll putinterval
            } {pop} ifelse
        } for
    } for

    %
    % Black dots
    %
    //codeone.blackdotmap vers get {pixs exch aload pop mmv 1 put} bind forall

    %
    % Place the modules onto a pixel map between alignment patterns
    %
    /j 0 def
    0 1 pixs length 1 sub {
        /i exch def
        pixs i get -1 eq {
            pixs i mmat j get put
            /j j 1 add def
        } if
    } for

    <<
    /ren /renmatrix
    /pixs pixs
    /pixx cols
    /pixy rows
    /height rows 72 div 2 mul
    /width cols 72 div 2 mul
    stype ttype or {
        /borderleft 1.0
        /borderright 1.0
        /bordertop 0.0
        /borderbottom 1.0
    } if
    /opt options
    >>

    _render //renmatrix if

    end

}
[/barcode] {null def} forall
bind def
/codeone dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
setglobal
% --END ENCODER codeone--
