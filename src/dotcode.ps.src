% Barcode Writer in Pure PostScript
% https://bwipp.terryburton.co.uk
%
% Copyright (c) 2004-2025 Terry Burton
%
% $Id$
%
% Permission is hereby granted, free of charge, to any
% person obtaining a copy of this software and associated
% documentation files (the "Software"), to deal in the
% Software without restriction, including without
% limitation the rights to use, copy, modify, merge,
% publish, distribute, sublicense, and/or sell copies of
% the Software, and to permit persons to whom the Software
% is furnished to do so, subject to the following
% conditions:
%
% The above copyright notice and this permission notice
% shall be included in all copies or substantial portions
% of the Software.
%
% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY
% KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
% THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
% PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
% THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
% DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
% CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
% CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
% IN THE SOFTWARE.

% --BEGIN ENCODER dotcode--
% --REQUIRES preamble raiseerror processoptions parseinput rendertext renmatrix--
% --DESC: DotCode
% --EXAM: This is DotCode
% --EXOP: inkspread=0.16
% --RNDR: renmatrix
currentglobal
true setglobal
/setpacking where {pop currentpacking true setpacking} if
32 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /processoptions dup /uk.co.terryburton.bwipp findresource put
dup /parseinput dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin

/dotcode.laa  -1 def  /dotcode.lab  -2 def  /dotcode.lac  -3 def  /dotcode.bin  -4 def
/dotcode.sfa  -5 def  /dotcode.sfb  -6 def  /dotcode.sb2  -7 def  /dotcode.sb3  -8 def
/dotcode.sb4  -9 def  /dotcode.sb5 -10 def  /dotcode.sb6 -11 def  /dotcode.sfc -12 def
/dotcode.sc2 -13 def  /dotcode.sc3 -14 def  /dotcode.sc4 -15 def  /dotcode.sc5 -16 def
/dotcode.sc6 -17 def  /dotcode.sc7 -18 def  /dotcode.bsa -19 def  /dotcode.bsb -20 def
/dotcode.tma -21 def  /dotcode.tmb -22 def  /dotcode.tmc -23 def  /dotcode.tms -24 def
/dotcode.fn1 -25 def  /dotcode.fn2 -26 def  /dotcode.fn3 -27 def  /dotcode.crl -28 def
/dotcode.aim -29 def  /dotcode.m05 -30 def  /dotcode.m06 -31 def  /dotcode.m12 -32 def
/dotcode.mac -33 def

/laa //dotcode.laa def  /lab //dotcode.lab def  /lac //dotcode.lac def  /bin //dotcode.bin def
/sfa //dotcode.sfa def  /sfb //dotcode.sfb def  /sb2 //dotcode.sb2 def  /sb3 //dotcode.sb3 def
/sb4 //dotcode.sb4 def  /sb5 //dotcode.sb5 def  /sb6 //dotcode.sb6 def  /sfc //dotcode.sfc def
/sc2 //dotcode.sc2 def  /sc3 //dotcode.sc3 def  /sc4 //dotcode.sc4 def  /sc5 //dotcode.sc5 def
/sc6 //dotcode.sc6 def  /sc7 //dotcode.sc7 def  /bsa //dotcode.bsa def  /bsb //dotcode.bsb def
/tma //dotcode.tma def  /tmb //dotcode.tmb def  /tmc //dotcode.tmc def  /tms //dotcode.tms def
/fn1 //dotcode.fn1 def  /fn2 //dotcode.fn2 def  /fn3 //dotcode.fn3 def  /crl //dotcode.crl def
/aim //dotcode.aim def  /m05 //dotcode.m05 def  /m06 //dotcode.m06 def  /m12 //dotcode.m12 def
/mac //dotcode.mac def

/dotcode.charmaps [
    %  A    B    C         A    B    C         A    B    C
    [  32   32  (00) ]  [ (!)  (!)  (01) ]  [ (")  (")  (02) ]  % 0-2
    [ (#)  (#)  (03) ]  [ ($)  ($)  (04) ]  [ (%)  (%)  (05) ]  % 3-5
    [ (&)  (&)  (06) ]  [ (')  (')  (07) ]  [  40   40  (08) ]  % 6-8
    [  41   41  (09) ]  [ (*)  (*)  (10) ]  [ (+)  (+)  (11) ]  % 9-11
    [ (,)  (,)  (12) ]  [ (-)  (-)  (13) ]  [ (.)  (.)  (14) ]  % 12-14
    [ (/)  (/)  (15) ]  [ (0)  (0)  (16) ]  [ (1)  (1)  (17) ]  % 15-17
    [ (2)  (2)  (18) ]  [ (3)  (3)  (19) ]  [ (4)  (4)  (20) ]  % 18-20
    [ (5)  (5)  (21) ]  [ (6)  (6)  (22) ]  [ (7)  (7)  (23) ]  % 21-23
    [ (8)  (8)  (24) ]  [ (9)  (9)  (25) ]  [ (:)  (:)  (26) ]  % 24-26
    [ (;)  (;)  (27) ]  [ (<)  (<)  (28) ]  [ (=)  (=)  (29) ]  % 27-29
    [ (>)  (>)  (30) ]  [ (?)  (?)  (31) ]  [ (@)  (@)  (32) ]  % 30-32
    [ (A)  (A)  (33) ]  [ (B)  (B)  (34) ]  [ (C)  (C)  (35) ]  % 33-35
    [ (D)  (D)  (36) ]  [ (E)  (E)  (37) ]  [ (F)  (F)  (38) ]  % 36-38
    [ (G)  (G)  (39) ]  [ (H)  (H)  (40) ]  [ (I)  (I)  (41) ]  % 39-41
    [ (J)  (J)  (42) ]  [ (K)  (K)  (43) ]  [ (L)  (L)  (44) ]  % 42-44
    [ (M)  (M)  (45) ]  [ (N)  (N)  (46) ]  [ (O)  (O)  (47) ]  % 45-47
    [ (P)  (P)  (48) ]  [ (Q)  (Q)  (49) ]  [ (R)  (R)  (50) ]  % 48-50
    [ (S)  (S)  (51) ]  [ (T)  (T)  (52) ]  [ (U)  (U)  (53) ]  % 51-53
    [ (V)  (V)  (54) ]  [ (W)  (W)  (55) ]  [ (X)  (X)  (56) ]  % 54-56
    [ (Y)  (Y)  (57) ]  [ (Z)  (Z)  (58) ]  [ ([)  ([)  (59) ]  % 57-59
    [  92   92  (60) ]  [ (])  (])  (61) ]  [ (^)  (^)  (62) ]  % 60-62
    [ (_)  (_)  (63) ]  [   0  (`)  (64) ]  [   1  (a)  (65) ]  % 63-65
    [   2  (b)  (66) ]  [   3  (c)  (67) ]  [   4  (d)  (68) ]  % 66-68
    [   5  (e)  (69) ]  [   6  (f)  (70) ]  [   7  (g)  (71) ]  % 69-71
    [   8  (h)  (72) ]  [   9  (i)  (73) ]  [  10  (j)  (74) ]  % 72-74
    [  11  (k)  (75) ]  [  12  (l)  (76) ]  [  13  (m)  (77) ]  % 75-77
    [  14  (n)  (78) ]  [  15  (o)  (79) ]  [  16  (p)  (80) ]  % 78-80
    [  17  (q)  (81) ]  [  18  (r)  (82) ]  [  19  (s)  (83) ]  % 81-83
    [  20  (t)  (84) ]  [  21  (u)  (85) ]  [  22  (v)  (86) ]  % 84-86
    [  23  (w)  (87) ]  [  24  (x)  (88) ]  [  25  (y)  (89) ]  % 87-89
    [  26  (z)  (90) ]  [  27  ({)  (91) ]  [  28  (|)  (92) ]  % 90-92
    [  29  (})  (93) ]  [  30  (~)  (94) ]  [  31  127  (95) ]  % 93-95
    [ sfb  crl  (96) ]  [ sb2    9  (97) ]  [ sb3   28  (98) ]  % 96-98
    [ sb4   29  (99) ]  [ sb5   30  aim  ]  [ sb6  sfa  laa  ]  % 99-101
    [ lab  laa  sfb  ]  [ sc2  sc2  sb2  ]  [ sc3  sc3  sb3  ]  % 102-104
    [ sc4  sc4  sb4  ]  [ lac  lac  lab  ]  [ fn1  fn1  fn1  ]  % 105-107
    [ fn2  fn2  fn2  ]  [ fn3  fn3  fn3  ]  [ bsa  bsa  bsa  ]  % 108-110
    [ bsb  bsb  bsb  ]  [ bin  bin  bin  ]                      % 111-112
] readonly def

/dotcode.encs [
    (101010101) (010101011) (010101101) (010110101) (011010101)
    (101010110) (101011010) (101101010) (110101010) (010101110)
    (010110110) (010111010) (011010110) (011011010) (011101010)
    (100101011) (100101101) (100110101) (101001011) (101001101)
    (101010011) (101011001) (101100101) (101101001) (110010101)
    (110100101) (110101001) (001010111) (001011011) (001011101)
    (001101011) (001101101) (001110101) (010010111) (010011011)
    (010011101) (010100111) (010110011) (010111001) (011001011)
    (011001101) (011010011) (011011001) (011100101) (011101001)
    (100101110) (100110110) (100111010) (101001110) (101011100)
    (101100110) (101101100) (101110010) (101110100) (110010110)
    (110011010) (110100110) (110101100) (110110010) (110110100)
    (111001010) (111010010) (111010100) (001011110) (001101110)
    (001110110) (001111010) (010011110) (010111100) (011001110)
    (011011100) (011100110) (011101100) (011110010) (011110100)
    (100010111) (100011011) (100011101) (100100111) (100110011)
    (100111001) (101000111) (101100011) (101110001) (110001011)
    (110001101) (110010011) (110011001) (110100011) (110110001)
    (111000101) (111001001) (111010001) (000101111) (000110111)
    (000111011) (000111101) (001001111) (001100111) (001110011)
    (001111001) (010001111) (011000111) (011100011) (011110001)
    (100011110) (100111100) (101111000) (110001110) (110011100)
    (110111000) (111000110) (111001100)
] readonly def

/dotcode.encfuncs [ /encA /encB /encC /encBIN ] readonly def
/dotcode.maskvals [ 0 3 7 17 ] readonly def
/dotcode.maskbits [ (00) (01) (10) (11) ] readonly def

/dotcode.latevars dup 16 dict def load /init {

    currentglobal
    true setglobal

    //dotcode.latevars begin

    /rsalog [ 1 112 { dup 3 mul 113 mod } repeat ] readonly def

    % Invert charmaps to give character to value maps for each state
    /charvals [ 113 dict 117 dict 113 dict ] def
    0 1 //dotcode.charmaps length 1 sub {
        /i exch def
        /encs //dotcode.charmaps i get def
        0 1 2 {
            /j exch def
            encs j get dup type /stringtype eq {0 get} if  % convert string to ASCII if required
            charvals j get exch i put
        } for
    } for

    /Avals charvals 0 get readonly def
    /Bvals charvals 1 get def
    Bvals //dotcode.m05  97 put
    Bvals //dotcode.m06  98 put
    Bvals //dotcode.m12  99 put
    Bvals //dotcode.mac 100 put
    /Bvals Bvals readonly def
    /Cvals charvals 2 get readonly def
    /charvals charvals readonly def

    /BINvals <<
        102 [ //dotcode.sc2 //dotcode.sc3 //dotcode.sc4 //dotcode.sc5 //dotcode.sc6 //dotcode.sc7 //dotcode.tma //dotcode.tmb //dotcode.tmc //dotcode.tms ] {exch 1 add dup} forall pop
    >> readonly def

    /init { //dotcode.latevars {def} forall } def

    end

    //dotcode.latevars /init get exec

    setglobal

} bind put

/uk.co.terryburton.bwipp.global_ctx dup where {
    exch get /preload known {//dotcode.latevars /init get exec} if
} {pop} ifelse

/dotcode {

    128 dict begin

    /dontdraw false def
    /rows -1 def
    /columns -1 def
    /ratio -1.0 def
    /parse false def
    /parsefnc false def
    /raw false def
    /fast false def
    /mask -1 def

    //processoptions exec /options exch def
    /barcode exch def

    //dotcode.latevars /init get exec

    rows -1 ne {
        rows 5 lt {
            /bwipp.dotcodeBadRows (There must be at least 5 rows) //raiseerror exec
        } if
    } if

    columns -1 ne {
        columns 5 lt {
            /bwipp.dotcodeBadColumns (There must be at least 5 columns) //raiseerror exec
        } if
    } if

    rows -1 ne columns -1 ne and rows columns add 2 mod 1 ne and {
        /bwipp.dotcodeRowsColumnsBadParity (Sum of rows and columns must be odd) //raiseerror exec
    } if

    %
    % Set the ratio to 3:2 if no size is specified
    %
    ratio -1 eq rows -1 eq and columns -1 eq and {
        /ratio 3 2 div def
    } if
    ratio -1 ne {
        ratio 0 le {
            /bwipp.dotcodeRatio (The ratio must be greater than 0) //raiseerror exec
        } if
    } if

    mask -1 ne {
        mask 0 lt mask 3 gt or {
            /bwipp.dotcodeBadMask (Valid mask values are 0 to 3) //raiseerror exec
        } if
    } if

    %
    % Parse the input
    %
    /fncvals <<
        /parse parse
        /parsefnc parsefnc
        /eci true
        (FNC1) //dotcode.fn1
        % (FNC2) fn2  %  Use ^ECInnnnnn for ECI; Structured append not supported
        (FNC3) //dotcode.fn3
    >> def
    /msg barcode fncvals //parseinput exec def
    /msglen msg length def

    %
    % Special FNC2 semantics: Expand ECI characters into ^FNC2nnnnnn
    %
    /numecis 0 msg { -1000000 le {1 add} if } forall def
    /msgtmp msg length numecis 6 mul add array def
    /j 0 def
    0 1 msg length 1 sub {
        msg exch get dup -1000000 le {
            neg 10 7 string cvrs 1 6 getinterval {} forall 6 array astore
            msgtmp exch j 1 add exch putinterval
            msgtmp j //dotcode.fn2 put
            /j j 7 add def
        } {
            msgtmp exch j exch put
            /j j 1 add def
        } ifelse
    } for
    /msg msgtmp def
    /msglen msg length def

    /A 0 def  /B 1 def  /C 2 def  /BIN 3 def

    %
    % Pre-compute properties of the input at each point
    %
    /nDigits      [ msglen 1 add {0} repeat     ] def
    /SeventeenTen [ msglen 1 add {false} repeat ] def
    /ECI          [ msglen 1 add {false} repeat ] def
    /DatumA       [ msglen 1 add {false} repeat ] def
    /DatumB       [ msglen 1 add {false} repeat ] def
    /DatumC       [ msglen 1 add {false} repeat ] def
    /Binary       [ msglen 8 add {false} repeat ] def
    /AheadC       [ msglen 1 add {0} repeat     ] def
    /TryC         [ msglen 1 add {0} repeat     ] def
    /AheadA       [ msglen 1 add {0} repeat     ] def
    /AheadB       [ msglen 1 add {0} repeat     ] def
    /UntilEndSeg  [ msglen 1 add {0} repeat     ] def
    msglen 1 sub -1 0 {
        /i exch def
        /barchar msg i get def
        barchar 48 ge barchar 57 le and {
            nDigits i nDigits i 1 add get 1 add put
        } if
        Avals barchar known {DatumA i true put} if
        Bvals barchar known {DatumB i true put} if
        /CRLF false def
        barchar 13 eq i msglen 1 sub lt and {
            msg i 1 add get 10 eq {/CRLF true def} if
        } if
        CRLF {DatumB i true put} if
        nDigits i get 2 ge  {DatumC i true put} if
        barchar 0 lt        {DatumC i true put} if  % FNCx
        barchar 128 ge      {Binary i true put} if
        nDigits i get 10 ge {  % 17xxxxxx10
            mark
            msg i 10 getinterval aload pop
            1 {  % common exit
                48 ne {false exit} if
                49 ne {false exit} if
                pop pop pop pop pop pop
                55 ne {false exit} if
                49 ne {false exit} if
                true
            } repeat
            SeventeenTen i 3 -1 roll put
            cleartomark
        } if
        nDigits i 1 add get 6 ge msg i get //dotcode.fn2 eq and {  % ^FNC2xxxxxx
            ECI i true put
        } if
        barchar 0 lt barchar //dotcode.fn3 ne and {  % FNCx, except FNC3
            AheadC i AheadC i 1 add get 1 add put
        } {
            nDigits i get 1 le {
                AheadC i 0 put
            } {
                AheadC i AheadC i 2 add get 1 add put
            } ifelse
        } ifelse
        nDigits i get 0 gt AheadC i get AheadC i 1 add get gt and {
            TryC i AheadC i get put
        } if
        DatumA i get TryC i get 2 lt and barchar //dotcode.fn3 ne and {
            AheadA i AheadA i 1 add get 1 add put
        } if
        DatumB i get TryC i get 2 lt and barchar //dotcode.fn3 ne and {
            AheadB i AheadB i 1 add CRLF {1 add} if get 1 add put
        } if
        barchar //dotcode.fn3 ne {
            UntilEndSeg i UntilEndSeg i 1 add get 1 add put
        } if
    } for

    /addtocws {
        dup cws exch j exch putinterval
        /j exch length j add def
    } def

    %
    % Base 259 to one more in base 103
    %
    /base259to103 {
        /in exch def
        /inlen in length def
        /in [ 5 inlen sub {0} repeat in aload pop ] def
        /out 6 array def
        /msbs [ in 0 2 getinterval aload pop ] def
        /mscs [
            msbs aload pop exch 259 mul add
            2 {dup 103 mod exch 103 idiv} repeat
        ] def
        /lsbs [ in 2 3 getinterval aload pop ] def
        /lscs [
            lsbs aload pop exch 259 mul add exch 67081 mul add
            3 {dup 103 mod exch 103 idiv} repeat
        ] def
        lscs 0 get mscs 0 get 42 mul add
        out 5 2 index 103 mod put
        103 idiv lscs 1 get add mscs 0 get 68 mul add mscs 1 get 42 mul add
        out 4 2 index 103 mod put
        103 idiv lscs 2 get add mscs 0 get 92 mul add mscs 1 get 68 mul add mscs 2 get 42 mul add
        out 3 2 index 103 mod put
        103 idiv lscs 3 get add mscs 0 get 15 mul add mscs 1 get 92 mul add mscs 2 get 68 mul add
        out 2 2 index 103 mod put
        103 idiv mscs 1 get 15 mul add mscs 2 get 92 mul add
        out 1 2 index 103 mod put
        103 idiv mscs 2 get 15 mul add
        out 0 3 -1 roll 103 mod put
        out 6 inlen sub 1 sub inlen 1 add getinterval
    } def

    /finaliseBIN {
        bpos 0 ne {
            bvals 0 bpos getinterval base259to103 aload pop
            /bpos 0 def
        } if
    } def

    /addtobin {
        bvals exch bpos exch put
        /bpos bpos 1 add def
        bpos 5 eq { finaliseBIN } if
    } def

    /ECIabc {  % ECI encoding for modes A, B and C
        msg i 1 add 6 getinterval 0 exch {48 sub add 10 mul} forall 10 idiv
        dup 40 ge {
            40 sub
            dup 12769 idiv 40 add exch 12769 mod
            dup   113 idiv        exch   113 mod
        } if
    } def

    /ECIbin {  % ECI encoding for binary mode
        [
            msg i 1 add 6 getinterval 0 exch {48 sub add 10 mul} forall 10 idiv
            dup 65536 ge {
                258 exch dup 65536 idiv exch 65536 mod dup 256 idiv exch 256 mod
            } {
                dup 256 ge {
                    257 exch dup 256 idiv exch 256 mod
                } {
                    256 exch
                } ifelse
            } ifelse
        ] {
            addtobin
        } forall
    } def

    /encC {
        1 {  % Common exit
            i segstart eq {  % Structured data macros
                1 {  % common exit
                    i segend 7 sub gt {0 exit} if
                    msg segstart       get 91 ne {0 exit} if                    % [
                    msg segstart 1 add get 41 ne {0 exit} if                    % )
                    msg segstart 2 add get 62 ne {0 exit} if                    % >
                    msg segstart 3 add get 30 ne {0 exit} if                    % {RS}
                    msg segstart 4 add get dup 48 lt exch 57 gt or {0 exit} if  % digit
                    msg segstart 5 add get dup 48 lt exch 57 gt or {0 exit} if  % digit
                    msg segend   1 sub get  4 ne {0 exit} if                    % End: {EOT}
                    msg segstart 4 add get 48 sub 10 mul msg segstart 5 add get 48 sub add
                    dup dup 05 ne exch dup 06 ne exch 12 ne and and {pop //dotcode.mac exit} if
                    msg segstart 6 add get 29 ne {pop 0 exit} if                % {GS}
                    msg segend   2 sub get 30 ne {pop 0 exit} if                % End: {RS}
                    dup 05 eq {pop //dotcode.m05 exit} if
                        06 eq {    //dotcode.m06 exit} if
                                   //dotcode.m12 exit
                } repeat
                /inmac exch def
                inmac 0 ne {
                    [ Cvals //dotcode.lab get ] addtocws
                    /mode B def
                    [ Bvals inmac get ] addtocws
                    inmac //dotcode.mac eq {
                        [ Bvals msg segstart 4 add get get ] addtocws
                        [ Bvals msg segstart 5 add get get ] addtocws
                        /i i 6 add def
                    } {
                        /i i 7 add def
                    } ifelse
                    exit
                } if
            } if
            % Special treatment of FNC1 in First for Dotcode
            i segstart eq {
                % Encode an FNC1 if two digits start a segment
                nDigits i get 2 ge {
                    [ Cvals //dotcode.fn1 get ] addtocws
                } if
                % Skip an FNC1 if followed by two digits at start of segment
                msg i get //dotcode.fn1 eq nDigits i 1 add get 2 ge and {
                    /i i 1 add def
                } if
            } if
            SeventeenTen i get {
                [  % 17xxxxxx10 macro
                    Cvals //dotcode.aim get
                    msg i 2 add get 48 sub 10 mul msg i 3 add get 48 sub add
                    msg i 4 add get 48 sub 10 mul msg i 5 add get 48 sub add
                    msg i 6 add get 48 sub 10 mul msg i 7 add get 48 sub add
                ] addtocws
                /i i 10 add def
                exit
            } if
            DatumC i get {
                msg i get dup //dotcode.fn1 eq exch dup //dotcode.fn2 eq exch //dotcode.fn3 eq or or {  % FNCx
                    [ Cvals msg i get get ] addtocws
                    ECI i get {  % FNC2 then 6 digits
                        [ ECIabc ] addtocws
                        /i i 7 add def
                        exit
                    } if
                    msg i get //dotcode.fn3 eq segstart i ne and {  % FNC3
                        /i i 1 add def
                        /inmac 0 def
                        /segstart i def
                        /segend i UntilEndSeg i get add def
                        exit
                    } if
                    /i i 1 add def
                    exit
                } if
                [ msg i get 48 sub 10 mul msg i 1 add get 48 sub add ] addtocws
                /i i 2 add def
                exit
            } if
            Binary i get {  % Binary
                nDigits i 1 add get 0 gt {
                    msg i get 160 lt {
                        [ Cvals //dotcode.bsa get Avals msg i get 128 sub get ] addtocws
                    } {
                        [ Cvals //dotcode.bsb get Bvals msg i get 128 sub get ] addtocws
                    } ifelse
                    /i i 1 add def
                    exit
                } if
                [ Cvals //dotcode.bin get ] addtocws
                /mode BIN def
                exit
            } if
            /m AheadA i get def  /n AheadB i get def
            m n gt {
                [ Cvals //dotcode.laa get ] addtocws
                /mode A def
                exit
            } if
            i segstart eq {
                msg i get dup 9 eq exch dup 28 eq exch dup 29 eq exch 30 eq or or or {
                    [ Cvals //dotcode.laa get ] addtocws
                    /mode A def
                    exit
                } if
            } if
            n 4 gt {
                [ Cvals //dotcode.lab get ] addtocws
                /mode B def
                exit
            } if
            [ Cvals [ //dotcode.sfb //dotcode.sb2 //dotcode.sb3 //dotcode.sb4 ] n 1 sub get get ] addtocws
            n {
                msg i get 13 eq {
                    [ Bvals //dotcode.crl get ] addtocws
                    /i i 2 add def
                } {
                    [ Bvals msg i get get ] addtocws
                    /i i 1 add def
                } ifelse
            } repeat
            exit
        } repeat
    } def  % encC

    /encB {
        1 {  % Common exit
            /n TryC i get def
            n 2 ge {
                n 4 gt {
                    [ Bvals //dotcode.lac get ] addtocws
                    /mode C def
                    exit
                } if
                [ Bvals [ //dotcode.sfc //dotcode.sc2 //dotcode.sc3 //dotcode.sc4 ] n 1 sub get get ] addtocws
                n {
                    msg i get 0 lt {
                        [ Cvals msg i get get ] addtocws
                        /i i 1 add def
                    } {
                        [ msg i get 48 sub 10 mul msg i 1 add get 48 sub add ] addtocws
                        /i i 2 add def
                    } ifelse
                } repeat
                exit
            } if
            DatumB i get {
                msg i get dup //dotcode.fn1 eq exch dup //dotcode.fn2 eq exch //dotcode.fn3 eq or or {  % FNCx
                    [ Bvals msg i get get ] addtocws
                    ECI i get {  % FNC2 then 6 digits
                        [ ECIabc ] addtocws
                        /i i 7 add def
                        exit
                    } if
                    msg i get //dotcode.fn3 eq i segstart ne and {  % FNC3
                        /i i 1 add def
                        /mode C def
                        /inmac 0 def
                        /segstart i def
                        /segend i UntilEndSeg i get add def
                        exit
                    } if
                    /i i 1 add def
                    exit
                } if
                msg i get 13 eq i msglen 1 sub lt and {
                    msg i 1 add get 10 eq {  % CRLF
                        [ Bvals //dotcode.crl get ] addtocws
                        /i i 2 add def
                        exit
                    } if
                } if
                [ Bvals msg i get get ] addtocws
                /i i 1 add def
                exit
            } if
            Binary i get {  % Binary
                DatumB i 1 add get {
                    msg i get 160 lt {
                        [ Bvals //dotcode.bsa get Avals msg i get 128 sub get ] addtocws
                    } {
                        [ Bvals //dotcode.bsb get Bvals msg i get 128 sub get ] addtocws
                    } ifelse
                    /i i 1 add def
                    exit
                } if
                [ Bvals //dotcode.bin get ] addtocws
                /mode BIN def
                exit
            } if
            AheadA i get 1 eq {
                [ Bvals //dotcode.sfa get Avals msg i get get ] addtocws
                /i i 1 add def
                exit
            } if
            [ Bvals //dotcode.laa get ] addtocws
            /mode A def
            exit
        } repeat
    } def

    /encA {
        1 {  % Common exit
            /n TryC i get def
            n 2 ge {
                n 4 gt {
                    [ Avals //dotcode.lac get ] addtocws
                    /mode C def
                    exit
                } if
                [ Avals [ //dotcode.sfc //dotcode.sc2 //dotcode.sc3 //dotcode.sc4 ] n 1 sub get get ] addtocws
                n {
                    msg i get 0 lt {
                        [ Cvals msg i get get ] addtocws
                        /i i 1 add def
                    } {
                        [ msg i get 48 sub 10 mul msg i 1 add get 48 sub add ] addtocws
                        /i i 2 add def
                    } ifelse
                } repeat
                exit
            } if
            DatumA i get {
                msg i get dup //dotcode.fn1 eq exch dup //dotcode.fn2 eq exch //dotcode.fn3 eq or or {  % FNCx
                    [ Avals msg i get get ] addtocws
                    ECI i get {  % FNC2 then 6 digits
                        [ ECIabc ] addtocws
                        /i i 7 add def
                        exit
                    } if
                    msg i get //dotcode.fn3 eq i segstart ne and {  % FNC3
                        /i i 1 add def
                        /mode C def
                        /inmac 0 def
                        /segstart i def
                        /segend i UntilEndSeg i get add def
                        exit
                    } if
                    /i i 1 add def
                    exit
                } if
                [ Avals msg i get get ] addtocws
                /i i 1 add def
                exit
            } if
            Binary i get {  % Binary
                DatumA i 1 add get {
                    msg i get 160 lt {
                        [ Avals //dotcode.bsa get Avals msg i get 128 sub get ] addtocws
                    } {
                        [ Avals //dotcode.bsb get Bvals msg i get 128 sub get ] addtocws
                    } ifelse
                    /i i 1 add def
                    exit
                } if
                [ Avals //dotcode.bin get ] addtocws
                /mode BIN def
                exit
            } if
            /n AheadB i get def
            n 6 gt {
                [ Avals //dotcode.lab get ] addtocws
                /mode B def
                exit
            } if
            [ Avals [ //dotcode.sfb //dotcode.sb2 //dotcode.sb3 //dotcode.sb4 //dotcode.sb5 //dotcode.sb6 ] n 1 sub get get ] addtocws
            n {
                msg i get 13 eq {
                    [ Bvals //dotcode.crl get ] addtocws
                    /i i 2 add def
                } {
                    [ Bvals msg i get get ] addtocws
                    /i i 1 add def
                } ifelse
            } repeat
            exit
        } repeat
    } def

    /encBIN {
        1 {  % Common exit
            /n TryC i get def
            n 2 ge {
                [ finaliseBIN ] addtocws
                n 7 gt {  % Terminate to C
                    [ BINvals //dotcode.tmc get ] addtocws
                    /mode C def
                    exit
                } if
                [ BINvals [ //dotcode.sc2 //dotcode.sc3 //dotcode.sc4 //dotcode.sc5 //dotcode.sc6 //dotcode.sc7 ] n 2 sub get get ] addtocws
                n {
                    msg i get 0 lt {
                        [ Cvals msg i get get ] addtocws
                        /i i 1 add def
                    } {
                        [ msg i get 48 sub 10 mul msg i 1 add get 48 sub add ] addtocws
                        /i i 2 add def
                    } ifelse
                } repeat
                exit
            } if
            ECI i get Binary i 7 add get and {  % ECI then binary
                [ ECIbin ] addtocws
                /i i 7 add def
                i msglen eq { [ finaliseBIN ] addtocws } if
                exit
            } if
            msg i get 0 ge {  % Not FNCx
                Binary i       get    Binary i 1 add get or
                Binary i 2 add get or Binary i 3 add get or
                ECI i 1 add get       Binary i 8 add get and or {
                    [ msg i get addtobin ] addtocws
                    /i i 1 add def
                    i msglen eq { [ finaliseBIN ] addtocws } if
                    exit
                } if
            } if
            [ finaliseBIN ] addtocws
            i msglen 1 sub ne {  % Not last character
                msg i get //dotcode.fn3 eq i segstart ne and {  % FNC3
                    [ BINvals //dotcode.tms get ] addtocws
                    /i i 1 add def
                    /mode C def
                    /inmac 0 def
                    /segstart i def
                    /segend i UntilEndSeg i get add def
                    exit
                } if
                AheadA i get AheadB i get gt {
                    [ BINvals //dotcode.tma get ] addtocws
                    /mode A def
                } {
                    [ BINvals //dotcode.tmb get ] addtocws
                    /mode B def
                } ifelse
                exit
            } if
            exit
        } repeat
    } def

    /cws msglen 2 mul 1 add array def
    /mode C def
    /bvals 5 array def  /bpos 0 def
    /inmac 0 def  /segstart 0 def  /segend UntilEndSeg 0 get def
    /i 0 def  /j 0 def  {
        i msglen ge {exit} if
        inmac 0 ne {  % Jump over macro trailers
            inmac //dotcode.mac ne i segend 2 sub eq and {  % {RS}{EOT}
                /i i 2 add def
                i msglen ge {exit} if
            } if
            inmac //dotcode.mac eq i segend 1 sub eq and {  % {EOT}
                /i i 1 add def
                i msglen ge {exit} if
            } if
        } if
        //dotcode.encfuncs mode get load exec
    } loop
    /cws cws 0 j getinterval def

    %
    % Determine the symbol size
    %
    /nd cws length def
    /minarea nd 3 add nd 2 idiv add 9 mul 2 add 2 mul def
    ratio -1 ne {        % Fixed ratio
        /hgt minarea ratio div sqrt def
        /wid minarea ratio mul sqrt def
        /h hgt cvi def  /w wid cvi def
        h w add 2 mod 1 eq {
            h w mul minarea lt {/h h 1 add def  /w w 1 add def} if
        } {
            hgt w mul wid h mul lt {
                /w w 1 add def
                h w mul minarea lt {
                    /w w 1 sub def  /h h 1 add def
                    h w mul minarea lt {/w w 2 add def} if
                } if
            } {
                /h h 1 add def
                h w mul minarea lt {
                    /h h 1 sub def  /w w 1 add def
                    h w mul minarea lt {/h h 2 add def} if
                } if
            } ifelse
        } ifelse
        /rows h def  /columns w def
    } {
        columns -1 eq {  % Fixed height
            /columns minarea rows add 1 sub rows idiv dup rows add 2 mod 0 eq {1 add} if def
        } if
        rows -1 eq {     % Fixed width
            /rows minarea columns add 1 sub columns idiv dup columns add 2 mod 0 eq {1 add} if def
        } if
    } ifelse

    %
    % Extend the codewords with padding
    %
    /ndots rows columns mul 2 idiv def
    {
        nd 1 add dup 2 idiv 3 add add 9 mul 2 add ndots gt {exit} if
        /nd nd 1 add def
    } loop
    /nc nd 2 idiv 3 add def
    /nw nd nc add def
    /rembits ndots nw 9 mul 2 add sub def
    nd cws length gt {
        /cws [
            cws aload pop
            mode BIN eq {109} {106} ifelse
            nd cws length sub 1 sub {106} repeat
        ] def
    } if

    options /debugcws known { /bwipp.debugcws cws //raiseerror exec } if

    %
    % Check that the codewords will fit in the symbol
    %
    nw 9 mul ndots 2 sub gt {
        /bwipp.dotcodeTooLong (Maximum length exceeded) //raiseerror exec
    } if

    %
    % Final six dots arranged at edges
    %
    rows 2 mod 0 eq {
        /sixedges [
            [ columns 1 sub  rows 2 sub ]
            [ 0              rows 2 sub ]
            [ columns 2 sub  rows 1 sub ]
            [ 1              rows 1 sub ]
            [ columns 1 sub  0          ]
            [ 0              0          ]
        ] def
    } {
        /sixedges [
            [ columns 2 sub  0          ]
            [ columns 2 sub  rows 1 sub ]
            [ columns 1 sub  1          ]
            [ columns 1 sub  rows 2 sub ]
            [ 0              0          ]
            [ 0              rows 1 sub ]
        ] def
    } ifelse

    /dmv {columns mul add} def

    %
    % Construct the template
    %
    /outline rows columns mul array def
    0 1 rows 1 sub {
        /y exch def
        0 1 columns 1 sub {
            /x exch def
            outline x y dmv x y add 2 mod 1 sub put
        } for
    } for
    sixedges {
        outline exch aload pop dmv 1 put
    } forall

    /clearcol {
        /x exch def
        true
        x 1 and 2 rows 1 sub {
            x exch dmv sym exch get 1 eq {pop false exit} if
        } for
    } def

    /clearrow {
        /y exch def
        true
        y 1 and 2 columns 1 sub {
            y dmv sym exch get 1 eq {pop false exit} if
        } for
    } def

    %
    % Evaluate the symbol
    %
    /evalsymbol {
        /sym exch def

        %
        % Identify the worst side
        %
        /worst 9999999 def
        [ [ /x 0 ] [ /x 1 ] [ /y 0 ] [ /y 1 ] ] {  % Top Bottom Left Right
            aload pop  /fl exch def  /dir exch def
            /sum 0 def  /first -1 def  /last -1 def
            0 1 dir /x eq {columns} {rows} ifelse 1 sub {
                dir exch def
                sym
                dir load
                dir /x eq {rows} {columns} ifelse 1 sub fl mul
                dir /y eq {exch} if
                dmv get 1 eq {
                    first -1 eq {/first dir load def} if
                    /last dir load def
                    /sum sum 1 add def
                } if
            } for
            sum last add first sub
            dir /x eq {rows} {columns} ifelse mul
            dup worst lt {/worst exch def} {pop} ifelse
        } forall

        /pen 0 def

        %
        % Check for groups of blank columns unless data is encoded vertically
        % in a symbol of sufficient height to overcome up to six consecutive 0s
        % in two neighbouring 5 of 9 dot patterns
        %
        rows 2 mod 1 eq rows 12 le or {
            /sum 0 def  /p 0 def
            1 1 columns 2 sub {
                clearcol {
                    /sum sum 1 add def
                    /p sum 1 eq {rows} {p rows mul} ifelse def
                } {
                    /sum 0 def
                    /pen pen p add def
                    /p 0 def
                } ifelse
            } for
            /pen pen p add def
        } if

        %
        % Check for groups of blank rows unless data is encoded horizontally
        % in a symbol of sufficient width to overcome up to six consecutive 0s
        % in two neighbouring 5 of 9 dot patterns
        %
        rows 2 mod 0 eq columns 12 le or {
            /sum 0 def  /p 0 def
            1 1 rows 2 sub {
                clearrow {
                    /sum sum 1 add def
                    /p sum 1 eq {columns} {p columns mul} ifelse def
                } {
                    /sum 0 def
                    /pen pen p add def
                    /p 0 def
                } ifelse
            } for
            /pen pen p add def
        } if

        %
        % Pad twice on all sides
        %
        /symp [
            columns 4 add 2 mul {0} repeat
            0 columns sym length 1 sub {
                0 exch 0 exch
                sym exch columns getinterval aload pop
                0 0
            } for
            columns 4 add 2 mul {0} repeat
        ] def

        %
        % Count voids and isolated dots
        %
        /columns columns 4 add def
        /rows    rows    4 add def
        /sum 0 def
        2 1 rows 3 sub {
            /y exch def
            y 1 and 2 add 2 columns 3 sub {
                /x exch def
                1 {  % Common exit
                    symp x 1 sub y 1 sub dmv get 1 eq {exit} if
                    symp x 1 add y 1 sub dmv get 1 eq {exit} if
                    symp x 1 sub y 1 add dmv get 1 eq {exit} if
                    symp x 1 add y 1 add dmv get 1 eq {exit} if
                    symp x y dmv get 0 eq {/sum sum 1 add def exit} if
                    symp x 2 sub y       dmv get 1 eq {exit} if
                    symp x       y 2 sub dmv get 1 eq {exit} if
                    symp x 2 add y       dmv get 1 eq {exit} if
                    symp x       y 2 add dmv get 1 eq {exit} if
                    /sum sum 1 add def
                } repeat
            } for
        } for
        /columns columns 4 sub def
        /rows    rows    4 sub def

        worst 0 eq {  % Fixed penalty to disqualify a symbol with an unlit edge
            -99999
        } {
            worst sum sum mul sub pen sub
        } ifelse

    } def

    /step nw 112 idiv 1 add def
    /offset {step mul start add} def

    %
    % Evaluate the symbols in the following order:
    % fast mode: m3 -> m3' -> m2 -> m2' -> m1 -> m1' -> m0 -> m0'
    % dflt mode: (m0 m1 m2 m3) -> (m0' m1' m2' m3')
    % -> : Test if we have met the HxW/2 threshold
    % m' : Symbols with six edge dots forcibly lit
    % () : Best of
    %
    /bestscore -99999999 def
    /masks mask -1 ne {
        [ mask ]
    } {
        fast { [ 2#11 2#10 2#01 2#00 ] } { [ 2#00 2#01 2#10 2#11 ] } ifelse
    } ifelse def
    /litmasks 4 array def
    masks {  % For each mask pattern

        /mask exch def

        %
        % Calculate the error correction codewords for each block
        %
        /rscws [
             mask
             //dotcode.maskvals mask get 0 cws {1 index add 113 mod exch 2 index add exch 3 1 roll} forall pop pop
             nc {0} repeat
        ] def
        0 1 step 1 sub {
            /start exch def
            /ND nd 1 add start sub step add 1 sub step idiv def
            /NW nw 1 add start sub step add 1 sub step idiv def
            /NC NW ND sub def
            /coeffs [ 1 NC {0} repeat ] def
            1 1 NC {
                /i exch def
                NC -1 1 {
                    /j exch def
                    coeffs j coeffs j get 113 add rsalog i get coeffs j 1 sub get mul 113 mod sub 113 mod put
                } for
            } for
            0 1 ND 1 sub {
                /t exch rscws exch offset get rscws ND offset get add 113 mod def
                0 1 NC 2 sub {
                    /j exch def
                    rscws ND j add offset rscws ND j add 1 add offset get 113 add t coeffs j 1 add get mul 113 mod sub 113 mod put
                } for
                rscws ND NC add 1 sub offset 113 t coeffs NC get mul 113 mod sub 113 mod put
            } for
            ND 1 NW 1 sub { dup rscws exch offset 113 rscws 5 -1 roll offset get sub 113 mod put } for
        } for

        %
        % Create the bitstream
        %
        /bits ndots string def
        bits 0 //dotcode.maskbits mask get putinterval
        1 1 nw {
            /i exch def
            bits i 1 sub 9 mul 2 add //dotcode.encs rscws i get get putinterval
        } for
        rembits 0 gt {
            bits nw 9 mul 2 add (11111111111111111) 0 rembits getinterval putinterval
        } if

        %
        % Walk the symbol placing the bitstream
        %
        /pixs outline dup length array copy def
        /posx 0 def
        /posy rows 2 mod 0 eq {0} {rows 1 sub} ifelse def
        bits 0 bits length 6 sub getinterval {
            {  % Move to next vacant position
                pixs posx posy dmv get -1 eq {exit} if
                rows 2 mod 0 eq {
                    /posy posy 1 add def
                    posy rows eq {
                        /posy 0 def
                        /posx posx 1 add def
                    } if
                } {
                    /posx posx 1 add def
                    posx columns eq {
                        /posx 0 def
                        /posy posy 1 sub def
                    } if
                } ifelse
            } loop
            pixs posx posy dmv 3 -1 roll 48 sub put
        } forall
        0 1 5 {  % Last six edge dots
            /i exch def
            pixs sixedges i get aload pop dmv
            bits bits length 6 sub i add get 48 sub put
        } for

        %
        % Evaluate the symbol to find the most suitable mask
        %
        /score pixs evalsymbol def
        score bestscore gt {
            /bestsym pixs def
            /bestscore score def
            fast bestscore rows columns mul 2 idiv gt and {exit} if
        } if

        %
        % Make a copy with lit edges for possible later evaluation
        %
        /litmask pixs dup length array copy def
        0 1 5 {  % Light last six edge dots
            /i exch def
            litmask sixedges i get aload pop dmv
            1 put
        } for
        litmasks mask litmask put

        %
        % In fast mode immediately score the lit symbol
        %
        fast {
            /score litmask evalsymbol def
            score bestscore gt {
                /bestsym litmask def
                /bestscore score def
                bestscore rows columns mul 2 idiv gt {exit} if
            } if
        } if

    } forall
    /pixs bestsym def

    %
    % For default mode, if best mask fails threshold then recalculate with lit corners and pick best
    %
    fast not bestscore rows columns mul 2 idiv le and {
        /bestscore -99999999 def
        masks {
            litmasks exch get /litmask exch def
            /score litmask evalsymbol def
            score bestscore gt {
                /bestsym litmask def
                /bestscore score def
            } if
        } forall
        /pixs bestsym def
    } if

    <<
    /ren /renmatrix
    /dotty true
    /pixs pixs
    /pixx columns
    /pixy rows
    /height rows 2 mul 72 div
    /width columns 2 mul 72 div
    /borderleft 3.0
    /borderright 3.0
    /bordertop 3.0
    /borderbottom 3.0
    /opt options
    >>

    dontdraw not //renmatrix if

    end

}
[/barcode] {null def} forall
bind def
/dotcode dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
setglobal
% --END ENCODER dotcode--
