%!PS

% Barcode Writer in Pure PostScript
% https://bwipp.terryburton.co.uk
%
% Copyright (c) 2004-2024 Terry Burton
%
% $Id$
%
% Permission is hereby granted, free of charge, to any
% person obtaining a copy of this software and associated
% documentation files (the "Software"), to deal in the
% Software without restriction, including without
% limitation the rights to use, copy, modify, merge,
% publish, distribute, sublicense, and/or sell copies of
% the Software, and to permit persons to whom the Software
% is furnished to do so, subject to the following
% conditions:
%
% The above copyright notice and this permission notice
% shall be included in all copies or substantial portions
% of the Software.
%
% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY
% KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
% THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
% PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
% THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
% DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
% CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
% CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
% IN THE SOFTWARE.

% --BEGIN ENCODER code128--
% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput renlinear--
% --DESC: Code 128
% --EXAM: Count01234567!
% --EXOP: includetext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
10 dict
dup /loadctx dup /uk.co.terryburton.bwipp findresource put
dup /unloadctx dup /uk.co.terryburton.bwipp findresource put
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /processoptions dup /uk.co.terryburton.bwipp findresource put
dup /parseinput dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/code128 {

    20 dict begin                  % Confine variables to local scope

    /ctx null def
    /dontdraw false def
    /includetext false def    % Enable/disable text
    /textfont /Courier def
    /textsize 10.0 def
    /textxoffset 0.0 def
    /textyoffset -7.0 def
    /height 1.0 def
    /encoding (auto) def
    /raw false def
    /parse false def
    /parsefnc false def

    //processoptions exec /options exch def
    /barcode exch def

    /code128 //loadctx exec

    % Special function characters
{
    /sta  -1 def  /stb  -2 def  /stc  -3 def
    /swa  -4 def  /swb  -5 def  /swc  -6 def
    /fn1  -7 def  /fn2  -8 def  /fn3  -9 def
    /fn4 -10 def  /sft -11 def  /stp -12 def
    /lka -13 def  /lkc -14 def  % CC-A/B and CC-C linkage
} ctxdef

    % Parse the input
    /fncvals <<
        /parse parse
        /parsefnc parsefnc
        (FNC1) fn1
        (FNC1) fn1
        (FNC2) fn2
        (FNC3) fn3
%        (FNC4) fn4    Not user accessible as encoded automatically
        (LNKA) lka
        (LNKC) lkc
    >> def
    /msg barcode fncvals //parseinput exec def
    /msglen msg length def

    % Character maps for each state
{
    /charmaps [
      %  A    B    C         A    B    C         A    B    C
      [  32   32  (00) ]  [ (!)  (!)  (01) ]  [ (")  (")  (02) ]  % 0-2
      [ (#)  (#)  (03) ]  [ ($)  ($)  (04) ]  [ (%)  (%)  (05) ]  % 3-5
      [ (&)  (&)  (06) ]  [ (')  (')  (07) ]  [  40   40  (08) ]  % 6-8
      [  41   41  (09) ]  [ (*)  (*)  (10) ]  [ (+)  (+)  (11) ]  % 9-11
      [ (,)  (,)  (12) ]  [ (-)  (-)  (13) ]  [ (.)  (.)  (14) ]  % 12-14
      [ (/)  (/)  (15) ]  [ (0)  (0)  (16) ]  [ (1)  (1)  (17) ]  % 15-17
      [ (2)  (2)  (18) ]  [ (3)  (3)  (19) ]  [ (4)  (4)  (20) ]  % 18-20
      [ (5)  (5)  (21) ]  [ (6)  (6)  (22) ]  [ (7)  (7)  (23) ]  % 21-23
      [ (8)  (8)  (24) ]  [ (9)  (9)  (25) ]  [ (:)  (:)  (26) ]  % 24-26
      [ (;)  (;)  (27) ]  [ (<)  (<)  (28) ]  [ (=)  (=)  (29) ]  % 27-29
      [ (>)  (>)  (30) ]  [ (?)  (?)  (31) ]  [ (@)  (@)  (32) ]  % 30-32
      [ (A)  (A)  (33) ]  [ (B)  (B)  (34) ]  [ (C)  (C)  (35) ]  % 33-35
      [ (D)  (D)  (36) ]  [ (E)  (E)  (37) ]  [ (F)  (F)  (38) ]  % 36-38
      [ (G)  (G)  (39) ]  [ (H)  (H)  (40) ]  [ (I)  (I)  (41) ]  % 39-41
      [ (J)  (J)  (42) ]  [ (K)  (K)  (43) ]  [ (L)  (L)  (44) ]  % 42-44
      [ (M)  (M)  (45) ]  [ (N)  (N)  (46) ]  [ (O)  (O)  (47) ]  % 45-47
      [ (P)  (P)  (48) ]  [ (Q)  (Q)  (49) ]  [ (R)  (R)  (50) ]  % 48-50
      [ (S)  (S)  (51) ]  [ (T)  (T)  (52) ]  [ (U)  (U)  (53) ]  % 51-53
      [ (V)  (V)  (54) ]  [ (W)  (W)  (55) ]  [ (X)  (X)  (56) ]  % 54-56
      [ (Y)  (Y)  (57) ]  [ (Z)  (Z)  (58) ]  [ ([)  ([)  (59) ]  % 57-59
      [  92   92  (60) ]  [ (])  (])  (61) ]  [ (^)  (^)  (62) ]  % 60-62
      [ (_)  (_)  (63) ]  [   0  (`)  (64) ]  [   1  (a)  (65) ]  % 63-65
      [   2  (b)  (66) ]  [   3  (c)  (67) ]  [   4  (d)  (68) ]  % 66-68
      [   5  (e)  (69) ]  [   6  (f)  (70) ]  [   7  (g)  (71) ]  % 69-71
      [   8  (h)  (72) ]  [   9  (i)  (73) ]  [  10  (j)  (74) ]  % 72-74
      [  11  (k)  (75) ]  [  12  (l)  (76) ]  [  13  (m)  (77) ]  % 75-77
      [  14  (n)  (78) ]  [  15  (o)  (79) ]  [  16  (p)  (80) ]  % 78-80
      [  17  (q)  (81) ]  [  18  (r)  (82) ]  [  19  (s)  (83) ]  % 81-83
      [  20  (t)  (84) ]  [  21  (u)  (85) ]  [  22  (v)  (86) ]  % 84-86
      [  23  (w)  (87) ]  [  24  (x)  (88) ]  [  25  (y)  (89) ]  % 87-89
      [  26  (z)  (90) ]  [  27  ({)  (91) ]  [  28  (|)  (92) ]  % 90-92
      [  29  (})  (93) ]  [  30  (~)  (94) ]  [  31  127  (95) ]  % 93-95
      [ fn3  fn3  (96) ]  [ fn2  fn2  (97) ]  [ sft  sft  (98) ]  % 96-98
      [ swc  swc  (99) ]  [ swb  fn4  swb  ]  [ fn4  swa  swa  ]  % 99-101
      [ fn1  fn1  fn1  ]  [ sta  sta  sta  ]  [ stb  stb  stb  ]  % 102-104
      [ stc  stc  stc  ]  [ stp  stp  stp  ]                      % 105-106
    ] def

    % Invert charmaps to give character to value maps for each state
    /charvals [ 109 dict 109 dict 109 dict ] def
    0 1 charmaps length 1 sub {
        /i exch def
        /encs charmaps i get def
        0 1 2 {
            /j exch def
            encs j get dup type /stringtype eq {0 get} if  % convert string to ASCII if required
            charvals j get exch i put
        } for
    } for
    /seta charvals 0 get def
    /setb charvals 1 get def
    /setc charvals 2 get def
} ctxdef

    % Include pseudo characters for GS1-128 Composite linkage identifiers
    seta lka seta swb get put  seta lkc seta swc get put
    setb lka setb swc get put  setb lkc setb swa get put
    setc lka setc swa get put  setc lkc setc swb get put

    raw {/encoding (raw) def} if

    encoding (raw) eq {
        /cws barcode length array def
        /i 0 def /j 0 def
        { % loop
            i barcode length eq {exit} if
            /cw barcode i 1 add 3 getinterval cvi def
            cws j cw put
            /i i 4 add def
            /j j 1 add def
        } loop
        /cws cws 0 j getinterval def
        /text () def
    } if

    encoding (auto) eq {

        /text msglen string def
        0 1 msglen 1 sub {
            /i exch def
            text i msg i get dup 0 lt { pop 32 } if put
        } for

        % Divide-And-Conquer with Memoization by Alex Geller, adapted from ZXing - see
        % https://github.com/zxing/zxing/commit/94fb277607003c070ffd1413754a782f3f87cbcd

        /canc {
            msg p get dup 48 ge exch 57 le and {
                p 1 add msglen lt {
                    msg p 1 add get dup 48 ge exch 57 le and
                } {
                    false
                } ifelse
            } {
                setc msg p get known
            } ifelse
        } def

        /canaorb {
            {
                msg p get -1 le { tryset 1 eq {seta} {setb} ifelse msg p get known exit } if
                msg p get 31 le { tryset 1 eq exit } if
                msg p get 95 le { true exit } if
                msg p get 127 le { tryset 2 eq exit } if
                msg p get 159 le { tryset 1 eq exit } if
                msg p get 223 le { true exit } if
                tryset 2 eq exit
            } loop
        } def

        %                A (1)                 B (2)                 C (3)
        /costs [ [ 0 ] [ msglen {0} repeat ] [ msglen {0} repeat ] [ msglen {0} repeat ] ] def
        /modes [ [ 0 ] [ msglen {0} repeat ] [ msglen {0} repeat ] [ msglen {0} repeat ] ] def

        /p 0 def /cs 0 def /mincost 0 def /minlatch 0 def /cost 0 def /latch 0 def /tryset 0 def  % Recursive state

        /dmcost {  % Args charset cs and msg index p
            p cs mincost minlatch cost latch tryset  % Save state on recursion
            9 -2 roll  % Move args to front
            /p exch def
            /cs exch def
            costs cs get p get 0 ne {  % Memoized?
                costs cs get p get
            } {
                /mincost 999999 def
                /minlatch 0 def
                canc {  % Mode C
                    /advance msg p get fn1 eq {1} {2} ifelse def
                    /cost 1 def
                    /latch 0 def  % Continue in current `cs`
                    cs 3 ne { /cost cost 1 add def /latch 3 def } if
                    p advance add msglen lt {
                        /cost cost 3 p advance add dmcost add def
                    } if
                    cost mincost lt { /mincost cost def /minlatch latch def } if
                } if
                2 -1 1 {  % Mode B then A
                    /tryset exch def
                    canaorb {
                        /cost 1 def
                        /latch 0 def  % Continue in current `cs`
                        cs tryset ne { /cost cost 1 add def /latch tryset def } if
                        p 1 add msglen lt { /cost cost tryset p 1 add dmcost add def } if
                        cost mincost lt { /mincost cost def /minlatch latch def } if
                        cs tryset ne cs 1 eq cs 2 eq or and {
                            /cost 2 def
                            /latch cs 3 add def  % Shift A/B
                            p 1 add msglen lt { /cost cost cs p 1 add dmcost add def } if
                            cost mincost lt { /mincost cost def /minlatch latch def } if
                        } if
                    } if
                } for
                costs cs get p mincost put
                modes cs get p minlatch put
                mincost
            } ifelse

            8 1 roll  % Move saved state to front and restore
            /tryset exch def /latch exch def /cost exch def /minlatch exch def /mincost exch def /cs exch def /p exch def
        } def

        msglen 0 gt { 0 0 dmcost pop } if

        % ASCII modes: 1 A, 2 B, 3 C, 4 shift from B, 5 shift from A
        /aset msglen array def
        /cs 0 def
        /i 0 def
        {
            i msglen ge {exit} if
            /latch modes cs get i get def
            latch 4 ge latch 5 le and {  % Shift A/B
                /cs latch 3 sub def
                aset i latch put
            } {
                latch 1 ge latch 3 le and { /cs latch def } if  % Else continue in current `cs`
                aset i cs put
                cs 3 eq msg i get 0 ge and { /i i 1 add def aset i cs put } if  % Guaranteed to be in range by algorithm
            } ifelse
            /i i 1 add def
        } loop

        % Extended ASCII modes: 0 not extended, 1 extended shift, 2 extended latch, 3 ASCII shift from extended
        /eset [ msglen {0} repeat ] def
        0 1 msglen 1 sub {
            /i exch def
            msg i get 128 ge { eset i 1 put } if
        } for

        % Decide when to latch to extended - ISO/IEC 15417:2007 Annex E note 3
        /j 0 def /k 0 def
        0 1 msglen 1 sub {
            /i exch def
            eset i get 1 eq {
                /j j 1 add def
                j 4 ge {
                    eset i 2 put
                    k 0 eq {
                        eset i 1 sub 2 put eset i 2 sub 2 put eset i 3 sub 2 put
                        /k i def
                    } if
                } if
            } {
                /j 0 def /k 0 def
            } ifelse
        } for
        j 3 ge k 0 eq and {
            eset msglen 1 sub 2 put eset msglen 2 sub 2 put eset msglen 3 sub 2 put
        } if

        % Decide if it is worth reverting to ASCII encodation for a few characters as described in 4.3.4.2 (d)
        1 1 msglen 1 sub {
            /i exch def
            eset i 1 sub get 2 eq eset i get 0 eq and {
                % Detected a change from extended to ASCII - count ASCII
                /c aset i get 3 eq {1} {0} ifelse def  % Count C so can subtract when deciding below
                /j 1 def
                1 1 msglen i sub {
                    /j exch def
                    i j add msglen ge {exit} if
                    eset i j add get 0 ne {exit} if
                    aset i j add get 3 eq { /c c 1 add def } if
                } for
                % Count how many extended beyond
                /k i j add msglen lt {1} {0} ifelse def
                k 1 msglen i j add sub {
                    /k exch def
                    i j add k add msglen ge {exit} if
                    eset i j add k add get 0 eq {exit} if
                } for
                j c sub 3 lt j c sub 5 lt k 2 gt and or {
                    % Change to shifting rather than latching back
                    0 1 j 1 sub {
                        /k exch def
                        eset i k add 3 put
                    } for
                } if
            } if
        } for

        % Encoding for each alphabet
        /enca {
            seta exch get cws exch j exch put
            /j j 1 add def
        } def
        /encb {
            setb exch get cws exch j exch put
            /j j 1 add def
        } def
        /encc {
            dup type /arraytype ne {
                setc exch get
            } {
                aload pop 48 sub exch 48 sub 10 mul add
            } ifelse
            cws exch j exch put
            /j j 1 add def
        } def

        /cws barcode length 2 mul 3 add array def

        % Select start character
        /j 0 def
        {  % common exit
            msglen 0 eq {
                stb enca
                /cset 2 def
                exit
            } if
            aset 0 get 1 eq {  % StartA
                sta enca
                /cset 1 def
                exit
            } if
            aset 0 get 3 eq {  % StartC
                stc enca
                /cset 3 def
                exit
            } if
            stb enca  % StartB
            /cset 2 def
            exit
        } loop

        % Main encoding loop
        /estate false def  % Extended latch state
        /i 0 def {
            i msglen eq {exit} if
            /aseti aset i get def
            /eseti eset i get def
            % Determine switches and shifts
            aseti cset ne {
                aseti 1 eq {
                    swa encb
                    /cset 1 def
                } if
                aseti 2 eq {
                    swb enca
                    /cset 2 def
                } if
                aseti 3 eq {
                    swc enca
                    /cset 3 def
                } if
            } if

            eseti 2 eq estate not and eseti 0 eq estate and or {
                cset 1 eq {
                    fn4 enca fn4 enca
                    /estate estate not def
                } if
                cset 2 eq {
                    fn4 encb fn4 encb
                    /estate estate not def
                } if
            } {
                eseti 1 eq estate not and eseti 3 eq estate and or {
                    cset 1 eq {
                        fn4 enca
                    } if
                    cset 2 eq {
                        fn4 encb
                    } if
                } if
            } ifelse

            aseti 4 eq aseti 5 eq or {
                sft enca
            } if

            aseti 1 eq aseti 5 eq or {  % A
                msg i get dup 0 ge {127 and} if enca
                /i i 1 add def
            } if
            aseti 2 eq aseti 4 eq or {  % B
                msg i get dup 0 ge {127 and} if encb
                /i i 1 add def
            } if
            aseti 3 eq {  % C
                msg i get -1 le {
                    msg i get encc
                    /i i 1 add def
                } {
                    msg i 2 getinterval encc
                    /i i 2 add def
                } ifelse
            } if
        } loop
        /cws cws 0 j getinterval def
    } if  % auto encoding

    % Derive checksum and place stop character
    /cws j 2 add array dup 0 cws putinterval def
    /csum cws 0 get def
    1 1 j 1 sub {
        /i exch def
        /csum csum cws i get i mul add def
    } for
    /csum csum 103 mod def
    cws j csum put
    cws j 1 add seta stp get put

    options /debugcws known { /bwipp.debugcws cws //raiseerror exec } if

    % Create an array containing the character mappings
{
    /encs
    [ (212222) (222122) (222221) (121223) (121322) (131222) (122213)
      (122312) (132212) (221213) (221312) (231212) (112232) (122132)
      (122231) (113222) (123122) (123221) (223211) (221132) (221231)
      (213212) (223112) (312131) (311222) (321122) (321221) (312212)
      (322112) (322211) (212123) (212321) (232121) (111323) (131123)
      (131321) (112313) (132113) (132311) (211313) (231113) (231311)
      (112133) (112331) (132131) (113123) (113321) (133121) (313121)
      (211331) (231131) (213113) (213311) (213131) (311123) (311321)
      (331121) (312113) (312311) (332111) (314111) (221411) (431111)
      (111224) (111422) (121124) (121421) (141122) (141221) (112214)
      (112412) (122114) (122411) (142112) (142211) (241211) (221114)
      (413111) (241112) (134111) (111242) (121142) (121241) (114212)
      (124112) (124211) (411212) (421112) (421211) (212141) (214121)
      (412121) (111143) (111341) (131141) (114113) (114311) (411113)
      (411311) (113141) (114131) (311141) (411131) (211412) (211214)
      (211232) (2331112)
    ] def
} ctxdef

    % Derive space bar succession
    /sbs cws length 6 mul 1 add string def
    0 1 cws length 1 sub {
        /i exch def
        sbs i 6 mul encs cws i get get putinterval
    } for

    % Return the arguments
    <<
    /ren /renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    /txt [ [text textxoffset textyoffset textfont textsize] ]
    /textxalign (center)
    /opt options
    >>

    dontdraw not //renlinear if

    //unloadctx exec

    end

}
[/barcode] {null def} forall
bind def
/code128 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER code128--
