% Barcode Writer in Pure PostScript
% https://bwipp.terryburton.co.uk
%
% vim: set sw=4 sts=4 et:
%
% Copyright (c) 2004-2026 Terry Burton
%
% $Id$
%
% Permission is hereby granted, free of charge, to any
% person obtaining a copy of this software and associated
% documentation files (the "Software"), to deal in the
% Software without restriction, including without
% limitation the rights to use, copy, modify, merge,
% publish, distribute, sublicense, and/or sell copies of
% the Software, and to permit persons to whom the Software
% is furnished to do so, subject to the following
% conditions:
%
% The above copyright notice and this permission notice
% shall be included in all copies or substantial portions
% of the Software.
%
% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY
% KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
% THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
% PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
% THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
% DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
% CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
% CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
% IN THE SOFTWARE.

% --BEGIN ENCODER code128--
% --REQUIRES preamble raiseerror setuphooks processoptions parseinput setanycolor rendertext renlinear--
% --DESC: Code 128
% --EXAM: Count01234567!
% --EXOP: includetext
% --RNDR: renlinear
currentglobal
true setglobal
/setpacking where {pop currentpacking true setpacking} if
64 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /processoptions dup /uk.co.terryburton.bwipp findresource put
dup /parseinput dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin

%
% Special function characters
%
/code128.sta  -1 def  /code128.stb  -2 def  /code128.stc  -3 def
/code128.swa  -4 def  /code128.swb  -5 def  /code128.swc  -6 def
/code128.fn1  -7 def  /code128.fn2  -8 def  /code128.fn3  -9 def
/code128.fn4 -10 def  /code128.sft -11 def  /code128.stp -12 def
/code128.lka -13 def  /code128.lkc -14 def  % CC-A/B and CC-C linkage

/sta //code128.sta def  /stb //code128.stb def  /stc //code128.stc def
/swa //code128.swa def  /swb //code128.swb def  /swc //code128.swc def
/fn1 //code128.fn1 def  /fn2 //code128.fn2 def  /fn3 //code128.fn3 def
/fn4 //code128.fn4 def  /sft //code128.sft def  /stp //code128.stp def
/lka //code128.lka def  /lkc //code128.lkc def

%
% Character maps for each state, used by the legacy encoder
%
/code128.charmaps [
    %  A    B    C         A    B    C         A    B    C
    [  32   32  (00) ]  [ (!)  (!)  (01) ]  [ (")  (")  (02) ]  % 0-2
    [ (#)  (#)  (03) ]  [ ($)  ($)  (04) ]  [ (%)  (%)  (05) ]  % 3-5
    [ (&)  (&)  (06) ]  [ (')  (')  (07) ]  [  40   40  (08) ]  % 6-8
    [  41   41  (09) ]  [ (*)  (*)  (10) ]  [ (+)  (+)  (11) ]  % 9-11
    [ (,)  (,)  (12) ]  [ (-)  (-)  (13) ]  [ (.)  (.)  (14) ]  % 12-14
    [ (/)  (/)  (15) ]  [ (0)  (0)  (16) ]  [ (1)  (1)  (17) ]  % 15-17
    [ (2)  (2)  (18) ]  [ (3)  (3)  (19) ]  [ (4)  (4)  (20) ]  % 18-20
    [ (5)  (5)  (21) ]  [ (6)  (6)  (22) ]  [ (7)  (7)  (23) ]  % 21-23
    [ (8)  (8)  (24) ]  [ (9)  (9)  (25) ]  [ (:)  (:)  (26) ]  % 24-26
    [ (;)  (;)  (27) ]  [ (<)  (<)  (28) ]  [ (=)  (=)  (29) ]  % 27-29
    [ (>)  (>)  (30) ]  [ (?)  (?)  (31) ]  [ (@)  (@)  (32) ]  % 30-32
    [ (A)  (A)  (33) ]  [ (B)  (B)  (34) ]  [ (C)  (C)  (35) ]  % 33-35
    [ (D)  (D)  (36) ]  [ (E)  (E)  (37) ]  [ (F)  (F)  (38) ]  % 36-38
    [ (G)  (G)  (39) ]  [ (H)  (H)  (40) ]  [ (I)  (I)  (41) ]  % 39-41
    [ (J)  (J)  (42) ]  [ (K)  (K)  (43) ]  [ (L)  (L)  (44) ]  % 42-44
    [ (M)  (M)  (45) ]  [ (N)  (N)  (46) ]  [ (O)  (O)  (47) ]  % 45-47
    [ (P)  (P)  (48) ]  [ (Q)  (Q)  (49) ]  [ (R)  (R)  (50) ]  % 48-50
    [ (S)  (S)  (51) ]  [ (T)  (T)  (52) ]  [ (U)  (U)  (53) ]  % 51-53
    [ (V)  (V)  (54) ]  [ (W)  (W)  (55) ]  [ (X)  (X)  (56) ]  % 54-56
    [ (Y)  (Y)  (57) ]  [ (Z)  (Z)  (58) ]  [ ([)  ([)  (59) ]  % 57-59
    [  92   92  (60) ]  [ (])  (])  (61) ]  [ (^)  (^)  (62) ]  % 60-62
    [ (_)  (_)  (63) ]  [   0  (`)  (64) ]  [   1  (a)  (65) ]  % 63-65
    [   2  (b)  (66) ]  [   3  (c)  (67) ]  [   4  (d)  (68) ]  % 66-68
    [   5  (e)  (69) ]  [   6  (f)  (70) ]  [   7  (g)  (71) ]  % 69-71
    [   8  (h)  (72) ]  [   9  (i)  (73) ]  [  10  (j)  (74) ]  % 72-74
    [  11  (k)  (75) ]  [  12  (l)  (76) ]  [  13  (m)  (77) ]  % 75-77
    [  14  (n)  (78) ]  [  15  (o)  (79) ]  [  16  (p)  (80) ]  % 78-80
    [  17  (q)  (81) ]  [  18  (r)  (82) ]  [  19  (s)  (83) ]  % 81-83
    [  20  (t)  (84) ]  [  21  (u)  (85) ]  [  22  (v)  (86) ]  % 84-86
    [  23  (w)  (87) ]  [  24  (x)  (88) ]  [  25  (y)  (89) ]  % 87-89
    [  26  (z)  (90) ]  [  27  ({)  (91) ]  [  28  (|)  (92) ]  % 90-92
    [  29  (})  (93) ]  [  30  (~)  (94) ]  [  31  127  (95) ]  % 93-95
    [ fn3  fn3  (96) ]  [ fn2  fn2  (97) ]  [ sft  sft  (98) ]  % 96-98
    [ swc  swc  (99) ]  [ swb  fn4  swb  ]  [ fn4  swa  swa  ]  % 99-101
    [ fn1  fn1  fn1  ]  [ sta  sta  sta  ]  [ stb  stb  stb  ]  % 102-104
    [ stc  stc  stc  ]  [ stp  stp  stp  ]                      % 105-106
] readonly def

%
% State machine constants for new encoder
%
% - Encoder states are named A0, B0, C0, A1, B1, and C1.
% - A, B, and C are the Code 128 code sets.
% - 0 is for ASCII and 1 is for extended ASCII range.
%
% The encoder relies on this order a lot, but it uses the "state_priority" list
% for prioritizing states.
%
% Strings are a convenient way of defining latch sequences. The strings map to
% Code 128 instructions.
%
% The (dddc) sequences are never inserted, but they are in the lists to provide
% the correct length.
%

% Prior state:      A0    B0    C0     A1    B1    C1
/code128.latch_a0 [ ()    (e)   (e)    (ee)  (eee) (eee)  ] readonly def
/code128.latch_b0 [ (d)   ()    (d)    (ddd) (dd)  (ddd)  ] readonly def
/code128.latch_c0 [ (c)   (c)   ()     (eec) (ddc) (dddc) ] readonly def
/code128.latch_a1 [ (ee)  (eee) (eee)  ()    (e)   (e)    ] readonly def
/code128.latch_b1 [ (ddd) (dd)  (ddd)  (d)   ()    (d)    ] readonly def
/code128.latch_c1 [ (eec) (ddc) (dddc) (c)   (c)   ()     ] readonly def

/code128.latch_length_a0 [ code128.latch_a0 {length} bind forall ] readonly def
/code128.latch_length_b0 [ code128.latch_b0 {length} bind forall ] readonly def
/code128.latch_length_c0 [ code128.latch_c0 {length} bind forall ] readonly def
/code128.latch_length_a1 [ code128.latch_a1 {length} bind forall ] readonly def
/code128.latch_length_b1 [ code128.latch_b1 {length} bind forall ] readonly def
/code128.latch_length_c1 [ code128.latch_c1 {length} bind forall ] readonly def

% For backtracking support
/code128.latch_sequence [ code128.latch_a0 code128.latch_b0 code128.latch_c0 code128.latch_a1 code128.latch_b1 code128.latch_c1 ] readonly def
/code128.start_code     [ 103 104 105 ] readonly def

% State machine configuration
/code128.state_priority [ 1 0 2 4 3 5 ] readonly def   % Configure encoder to conform with existing tests
/code128.start_state    [ 0 1 2 0 1 2 ] readonly def   % Encoding starts in ASCII
/code128.start_length   [ 1 1 1 1 1 1 ] readonly def   % Room for start code

% Reverse priority list for preprocessing latch lengths and final state
/code128.reverse_priority [ [ 5 4 3 2 1 0 ] {code128.state_priority exch get } forall] readonly def

% Preprocessed latch lengths for get_best_prior_state
/code128.prioritized_latch_length_a0 [ code128.reverse_priority {dup dup code128.latch_length_a0 exch get exch} bind forall ] readonly def
/code128.prioritized_latch_length_a1 [ code128.reverse_priority {dup dup code128.latch_length_a1 exch get exch} bind forall ] readonly def
/code128.prioritized_latch_length_b0 [ code128.reverse_priority {dup dup code128.latch_length_b0 exch get exch} bind forall ] readonly def
/code128.prioritized_latch_length_b1 [ code128.reverse_priority {dup dup code128.latch_length_b1 exch get exch} bind forall ] readonly def
/code128.prioritized_latch_length_c0 [ code128.reverse_priority {dup dup code128.latch_length_c0 exch get exch} bind forall ] readonly def
/code128.prioritized_latch_length_c1 [ code128.reverse_priority {dup dup code128.latch_length_c1 exch get exch} bind forall ] readonly def

%
% New encoder character sets - map special function characters to codewords
%
/code128.seta_new << fn3 96  fn2 97  fn1 102  stp 106  lka 100  lkc  99 >> readonly def
/code128.setb_new << fn3 96  fn2 97  fn1 102  stp 106  lka  99  lkc 101 >> readonly def
/code128.setc_new <<                 fn1 102  stp 106  lka 101  lkc 100 >> readonly def

%
% Create an array containing the character mappings
%
/code128.encs [
    (212222) (222122) (222221) (121223) (121322) (131222) (122213)
    (122312) (132212) (221213) (221312) (231212) (112232) (122132)
    (122231) (113222) (123122) (123221) (223211) (221132) (221231)
    (213212) (223112) (312131) (311222) (321122) (321221) (312212)
    (322112) (322211) (212123) (212321) (232121) (111323) (131123)
    (131321) (112313) (132113) (132311) (211313) (231113) (231311)
    (112133) (112331) (132131) (113123) (113321) (133121) (313121)
    (211331) (231131) (213113) (213311) (213131) (311123) (311321)
    (331121) (312113) (312311) (332111) (314111) (221411) (431111)
    (111224) (111422) (121124) (121421) (141122) (141221) (112214)
    (112412) (122114) (122411) (142112) (142211) (241211) (221114)
    (413111) (241112) (134111) (111242) (121142) (121241) (114212)
    (124112) (124211) (411212) (421112) (421211) (212141) (214121)
    (412121) (111143) (111341) (131141) (114113) (114311) (411113)
    (411311) (113141) (114131) (311141) (411131) (211412) (211214)
    (211232) (2331112)
] readonly def

/code128.max_int 16#7FFFFFFF def

/code128.latevars dup 8 dict def load /init {

    currentglobal
    true setglobal

    //code128.latevars begin

    %
    % Invert charmaps to give character to value maps for each state
    %
    /charvals_legacy [ 109 dict 109 dict 109 dict ] def
    0 1 //code128.charmaps length 1 sub {
        /i exch def
        /encs //code128.charmaps i get def
        0 1 2 {
            /j exch def
            encs j get dup type /stringtype eq {0 get} if  % convert string to ASCII if required
            charvals_legacy j get exch i put
        } for
    } for
    /charvals_legacy charvals_legacy readonly def

    %
    % Legacy encoder character sets with pseudo characters for GS1-128 Composite linkage
    %
    /seta_legacy charvals_legacy 0 get dup dup //code128.swb get //code128.lka exch put dup dup //code128.swc get //code128.lkc exch put readonly def
    /setb_legacy charvals_legacy 1 get dup dup //code128.swc get //code128.lka exch put dup dup //code128.swa get //code128.lkc exch put readonly def
    /setc_legacy charvals_legacy 2 get dup dup //code128.swa get //code128.lka exch put dup dup //code128.swb get //code128.lkc exch put readonly def

    /init { //code128.latevars {def} forall } def

    end

    //code128.latevars /init get exec

    setglobal

} bind put

/uk.co.terryburton.bwipp.global_ctx dup where {
    exch get /preload known {//code128.latevars /init get exec} if
} {pop} ifelse

/code128 {

    64 dict begin

    /dontdraw false def
    /includetext false def
    /textfont /Courier def
    /textsize 10.0 def
    /textxoffset 0.0 def
    /textyoffset -7.0 def
    /height 1.0 def
    /raw false def
    /newencoder false def
    /parse false def
    /parsefnc false def
    /suppressc false def          % Suppress code set C
    /unlatchextbeforec false def  % Suppress extended ASCII with code set C

    //processoptions exec /options exch def
    /barcode exch def

    /_render
        dontdraw /uk.co.terryburton.bwipp.global_ctx dup where {exch get /enabledontdraw known} {pop false} ifelse and
        /uk.co.terryburton.bwipp._dontdraw dup where {exch get} {pop false} ifelse or not
    def

    //code128.latevars /init get exec

    %
    % Parse the input
    %
    /fncvals <<
        /parse parse
        /parsefnc parsefnc
        (FNC1) //code128.fn1
        (FNC2) //code128.fn2
        (FNC3) //code128.fn3
%        (FNC4) fn4    Not user accessible as encoded automatically
        (LNKA) //code128.lka
        (LNKC) //code128.lkc
    >> def
    barcode fncvals //parseinput exec /msg exch def
    /msglen msg length def

    /encoding (legacy) def
    newencoder {/encoding (new) def} if
    raw {/encoding (raw) def} if

    encoding (raw) eq {
        /cws barcode length array def
        /i 0 def /j 0 def
        { % loop
            i barcode length eq {exit} if
            /cw barcode i 1 add 3 getinterval cvi def
            cws j cw put
            /i i 4 add def
            /j j 1 add def
        } loop
        /cws cws 0 j getinterval def
        /text () def
    } {
        /text msglen string def
        0 1 msglen 1 sub {
            /i exch def
            text i msg i get dup 0 lt { pop 32 } if put
        } for
    } ifelse

    encoding (legacy) eq {

        % Character sets with pseudo characters for GS1-128 Composite linkage
        /seta seta_legacy def
        /setb setb_legacy def
        /setc setc_legacy def

        %
        % Standard and extended ASCII runlength at position
        %
        /numSA [ msglen {0} repeat 0 ] def
        /numEA [ msglen {0} repeat 0 ] def
        msglen 1 sub -1 0 {
            /i exch def
            msg i get 0 ge {
                msg i get 128 ge {
                    numEA i numEA i 1 add get 1 add put
                } {
                    numSA i numSA i 1 add get 1 add put
                } ifelse
            } if
        } for

        %
        % FNC4 codeword insertion for extended ASCII
        %
        /ea false def
        mark
        0 1 msglen 1 sub {
            /i exch def
            /c msg i get def
            ea c 128 lt xor not c 0 ge and {  % Other mode required
                ea {numSA} {numEA} ifelse i get dup  % Runlength of other mode
                i add msglen eq {3} {5} ifelse       % Does run terminate symbol
                lt {  % Shift
                    //code128.fn4
                } {   % Latch
                    //code128.fn4 //code128.fn4
                    /ea ea not def
                } ifelse
            } if
            c 0 ge {c 127 and} {c} ifelse
        } for
        counttomark array astore /msg exch def pop
        /msglen msg length def

        %
        % Determine digit runlength from given position
        %
        /numsscr {
            /s 0 def
            /p exch def {
                p msglen ge {exit} if
                msg p get
                dup setc exch known not {pop exit} if
                dup -1 le {
                    % FNC1 in odd position of run like two digits
                    //code128.fn1 eq s 2 mod 0 eq and {/s s 1 add def} {exit} ifelse
                } {
                    pop
                } ifelse
                /s s 1 add def
                /p p 1 add def
            } loop
            s
        } def

        %
        % Encoding for each alphabet
        %
        /enca {
            seta exch get cws exch j exch put
            /j j 1 add def
        } def
        /encb {
            setb exch get cws exch j exch put
            /j j 1 add def
        } def
        /encc {
            dup type /arraytype ne {
                setc exch get
            } {
                aload pop 48 sub exch 48 sub 10 mul add
            } ifelse
            cws exch j exch put
            /j j 1 add def
        } def

        %
        % Character exclusively in either alphabet A or B
        %
        /anotb {dup seta exch known exch setb exch known not and} def
        /bnota {dup setb exch known exch seta exch known not and} def

        %
        % Pre-compute relative position of next anotb and next bnota characters
        %
        /nextanotb [ msg length {0} repeat 9999 ] def
        /nextbnota [ msg length {0} repeat 9999 ] def
        msg length 1 sub -1 0 {
            /i exch def
            msg i get anotb {
                nextanotb i 0 put
            } {
                nextanotb i nextanotb i 1 add get 1 add put
            } ifelse
            msg i get bnota {
                nextbnota i 0 put
            } {
                nextbnota i nextbnota i 1 add get 1 add put
            } ifelse
        } for

        %
        % Does a-only come before b-only after given position and vice versa
        %
        /abeforeb {dup nextanotb exch get exch nextbnota exch get lt} def
        /bbeforea {dup nextbnota exch get exch nextanotb exch get lt} def

        /cws barcode length 2 mul 3 add array def

        %
        % Select start character
        %
        /j 0 def
        msglen 0 gt {0 numsscr} {-1} ifelse /nums exch def
        {  % common exit
            msglen 0 eq {
                //code128.stb enca
                /cset (setb) def
                exit
            } if
            msglen 2 eq nums 2 eq and {
                //code128.stc enca
                /cset (setc) def
                exit
            } if
            nums 4 ge {
                //code128.stc enca
                /cset (setc) def
                exit
            } if
            0 abeforeb {
                //code128.sta enca
                /cset (seta) def
                exit
            } if
            //code128.stb enca
            /cset (setb) def
            exit
        } loop

        %
        % Main encoding loop
        %
        /i 0 def {
            i msglen eq {exit} if

            i numsscr /nums exch def

            %
            % Determine switches and shifts
            %
            {  % common exit
                cset (seta) eq cset (setb) eq or nums 4 ge and
                msg i get //code128.fn1 ne and {
                    nums 2 mod 0 eq {
                        //code128.swc cset (seta) eq {enca} {encb} ifelse
                        /cset (setc) def
                        exit
                    } {
                        msg i get cset (seta) eq {enca} {encb} ifelse
                        /i i 1 add def
                        i numsscr 4 ge {
                            //code128.swc cset (seta) eq {enca} {encb} ifelse
                            /cset (setc) def
                            exit
                       } if
                    } ifelse
                } if
                cset (setb) eq msg i get anotb and {
                    i msglen 1 sub lt {
                        i 1 add bbeforea {
                            //code128.sft encb
                            msg i get enca
                            /i i 1 add def
                            exit
                        } if
                    } if
                    //code128.swa encb
                    /cset (seta) def
                    exit
                } if
                cset (seta) eq msg i get bnota and {
                    i msglen 1 sub lt {
                        i 1 add abeforeb {
                            //code128.sft enca
                            msg i get encb
                            /i i 1 add def
                            exit
                        } if
                    } if
                    //code128.swb enca
                    /cset (setb) def
                    exit
                } if
                cset (setc) eq nums 2 lt and msg i get -1 gt msg i get //code128.fn4 eq or and {
                    i abeforeb {
                        //code128.swa encc
                        /cset (seta) def
                        exit
                    } if
                    //code128.swb encc
                    /cset (setb) def
                    exit
                } if

                % No switches or latches so encode
                cset (seta) eq {
                    msg i get enca
                    /i i 1 add def
                    exit
                } if
                cset (setb) eq {
                    msg i get encb
                    /i i 1 add def
                    exit
                } if
                cset (setc) eq {
                    msg i get -1 le {
                        msg i get encc
                        /i i 1 add def
                    } {
                        msg i 2 getinterval encc
                        /i i 2 add def
                    } ifelse
                    exit
                } if

                exit
            } loop

        } loop
        /cws cws 0 j getinterval def

    } if  % legacy encoder

    encoding (new) eq {

        %
        % Character sets for special function characters
        %
        /seta //code128.seta_new def
        /setb //code128.setb_new def
        /setc //code128.setc_new def

        %
        % Backtracking needs a way of mapping states to encode procedures
        %
        /encode [ {enc_a0} {enc_b0} {enc_c} {enc_a1} {enc_b1} {enc_c} ] def

        %
        % Predicates for ability to encode
        %
        /can_a  {c          0 ge {true} {seta c known} ifelse} def
        /can_b  {c          0 ge {true} {setb c known} ifelse} def
        /can_c0 {num_digits 2 ge {true} {setc c known} ifelse} def
        /can_c1 {num_digits 2 ge {true} {setc c known} ifelse} def

        %
        % Predicates overruled by options
        %
        suppressc                      {/can_c0 {false} def} if
        suppressc unlatchextbeforec or {/can_c1 {false} def} if

        %
        % Output length
        %
        /out_a0 {1 c 0 ge {c 128 ge {1 add} if c 127 and 96 ge {1 add} if} if} def
        /out_a1 {1 c 0 ge {c 128 lt {1 add} if c 127 and 96 ge {1 add} if} if} def
        /out_b0 {1 c 0 ge {c 128 ge {1 add} if c 127 and 32 lt {1 add} if} if} def
        /out_b1 {1 c 0 ge {c 128 lt {1 add} if c 127 and 32 lt {1 add} if} if} def

        %
        % Encode
        %
        /map_ab {dup 32 lt {64 add} {32 sub} ifelse} def
        /enc_a0 {[c 0 lt {seta c get} {c 128 ge {101} if c 127 and dup 96 ge {98 exch} if map_ab} ifelse]} def
        /enc_a1 {[c 0 lt {seta c get} {c 128 lt {101} if c 127 and dup 96 ge {98 exch} if map_ab} ifelse]} def
        /enc_b0 {[c 0 lt {setb c get} {c 128 ge {100} if c 127 and dup 32 lt {98 exch} if map_ab} ifelse]} def
        /enc_b1 {[c 0 lt {setb c get} {c 128 lt {100} if c 127 and dup 32 lt {98 exch} if map_ab} ifelse]} def
        /enc_c  {[c 0 lt {setc c get} {msg n get 48 sub 10 mul msg n 1 add get 48 sub add       } ifelse]} def

        %
        % Get best prior state based on a prior row of lengths and a row of latch
        % lengths (unrolled and with preprocessed latch lengths on the stack)
        %
        /get_best_prior_state {
            bln_0 exch get add             /len exch def /o exch def
            bln_0 exch get add dup len lt {/len exch def /o exch def} {pop pop} ifelse
            bln_0 exch get add dup len lt {/len exch def /o exch def} {pop pop} ifelse
            bln_0 exch get add dup len lt {/len exch def /o exch def} {pop pop} ifelse
            bln_0 exch get add dup len lt {/len exch def /o exch def} {pop pop} ifelse
            bln_0 exch get add     len lt {              /o exch def} {    pop} ifelse
            o
        } def

        %
        % The encoder considers the current row and two rows back.
        % The circular history buffer size is 4 for convenience.
        % The names are short to keep the lines below reasonable
        %
        /bln_0 //code128.start_length def /bln_1 //code128.start_length def /bln [4 {[0 0 0 0 0 0]} repeat] def     %  Best Length
        /bps_0 //code128.start_state  def /bps_1 //code128.start_state  def /bps [4 {[0 0 0 0 0 0]} repeat] def     %  Best Prior State

        %
        % Path for backtracking
        %
        /path [msg length {[0 0 0 0 0 0]} repeat] def

        /make_tables {
            /num_digits 0 def
            0 1 msg length 1 sub {
                /n exch def
                /c msg n get def

                %
                % Keep a tab on digits
                %
                /num_digits c 48 ge c 58 lt and {num_digits 1 add} {0} ifelse def

                %
                % Circular history buffer machinery
                %
                /bln_2 bln_1 def /bln_1 bln_0 def /bln_0 bln n 3 and get def
                /bps_2 bps_1 def /bps_1 bps_0 def /bps_0 bps n 3 and get def

                %
                % Pick history rows for code set c depending on digits
                %
                /bps_c num_digits 2 ge {bps_2} {bps_1} ifelse def
                /bln_c num_digits 2 ge {bln_2} {bln_1} ifelse def

                %
                % Use the best prior states and the prior best lengths to determine new best lengths and plot the path
                %
                bln_0 0 can_a  {/p bps_1 0 get def path n get 0 p put bln_1 p get //code128.latch_length_a0 p get add out_a0 add} {//code128.max_int} ifelse put
                bln_0 3 can_a  {/p bps_1 3 get def path n get 3 p put bln_1 p get //code128.latch_length_a1 p get add out_a1 add} {//code128.max_int} ifelse put
                bln_0 1 can_b  {/p bps_1 1 get def path n get 1 p put bln_1 p get //code128.latch_length_b0 p get add out_b0 add} {//code128.max_int} ifelse put
                bln_0 4 can_b  {/p bps_1 4 get def path n get 4 p put bln_1 p get //code128.latch_length_b1 p get add out_b1 add} {//code128.max_int} ifelse put
                bln_0 2 can_c0 {/p bps_c 2 get def path n get 2 p put bln_c p get //code128.latch_length_c0 p get add      1 add} {//code128.max_int} ifelse put
                bln_0 5 can_c1 {/p bps_c 5 get def path n get 5 p put bln_c p get //code128.latch_length_c1 p get add      1 add} {//code128.max_int} ifelse put

                %
                % Use the new best lengths to determine new best prior states
                %
                bps_0 0 //code128.prioritized_latch_length_a0 aload pop get_best_prior_state put
                bps_0 3 //code128.prioritized_latch_length_a1 aload pop get_best_prior_state put
                bps_0 1 //code128.prioritized_latch_length_b0 aload pop get_best_prior_state put
                bps_0 4 //code128.prioritized_latch_length_b1 aload pop get_best_prior_state put
                bps_0 2 //code128.prioritized_latch_length_c0 aload pop get_best_prior_state put
                bps_0 5 //code128.prioritized_latch_length_c1 aload pop get_best_prior_state put
            } for
        } def

        /backtrack {
            /n msg length def

            %
            % Get best final state and final length
            %
            //code128.reverse_priority {dup bln_0 exch get dup} forall
            pop        /len exch def /state exch def
            5 {len lt {/len exch def /state exch def} {pop pop} ifelse} repeat

            len array                                                                           % Put output array on the stack
            {
                n 0 le {exit} if
                /prior_state path n 1 sub get state get def                                     % Get prior state (following path)
                /latch [//code128.latch_sequence state get prior_state get {} forall] def       % Get latch sequence and convert from string to array
                /n n state 2 eq state 5 eq or msg n 1 sub get 48 ge and {2} {1} ifelse sub def  % Get intake and subtract it from the input index
                /c msg n get def                                                                % Get current character (the encoding below needs it)
                /enc encode state get exec def                                                  % Encode state
                /len len latch length sub enc length sub def                                    % Subtract latch length and output length from output index
                dup len latch 3 copy putinterval length add enc putinterval                     % Copy latch and encoded entry to output
                /state prior_state def                                                          % Prepare for next iteration
            } loop
            dup 0 //code128.start_code state get put                                              % Add start code
        } def

        make_tables backtrack

        /cws exch def

    } if  % auto encoding

    %
    % Derive checksum and place stop character
    %
    /j cws length def
    /cws j 2 add array dup 0 cws putinterval def
    /csum cws 0 get def
    1 1 j 1 sub {
        /i exch def
        /csum csum cws i get i mul add def
    } for
    /csum csum 103 mod def
    cws j csum put
    cws j 1 add 106 put  % stp

    options /debugcws known
    /uk.co.terryburton.bwipp.global_ctx dup where {exch get /enabledebug known} {pop false} ifelse
    and { /bwipp.debugcws cws //raiseerror exec } if

    %
    % Derive space bar succession
    %
    /sbs cws length 6 mul 1 add string def
    0 1 cws length 1 sub {
        /i exch def
        sbs i 6 mul //code128.encs cws i get get putinterval
    } for

    <<
    /ren /renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    /txt [ [text textxoffset textyoffset textfont textsize] ]
    /textxalign (center)
    /opt options
    >>

    _render //renlinear if

    end

}
[/barcode] {null def} forall
bind def
/code128 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
setglobal
% --END ENCODER code128--
