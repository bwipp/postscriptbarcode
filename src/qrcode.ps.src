% Barcode Writer in Pure PostScript
% https://bwipp.terryburton.co.uk
%
% Copyright (c) 2004-2025 Terry Burton
%
% $Id$
%
% Permission is hereby granted, free of charge, to any
% person obtaining a copy of this software and associated
% documentation files (the "Software"), to deal in the
% Software without restriction, including without
% limitation the rights to use, copy, modify, merge,
% publish, distribute, sublicense, and/or sell copies of
% the Software, and to permit persons to whom the Software
% is furnished to do so, subject to the following
% conditions:
%
% The above copyright notice and this permission notice
% shall be included in all copies or substantial portions
% of the Software.
%
% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY
% KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
% THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
% PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
% THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
% DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
% CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
% CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
% IN THE SOFTWARE.

% --BEGIN ENCODER qrcode--
% --REQUIRES preamble raiseerror processoptions parseinput rendertext renmatrix--
% --DESC: QR Code
% --EXAM: http://goo.gl/0bis
% --EXOP: eclevel=M
% --RNDR: renmatrix
currentglobal
true setglobal
/setpacking where {pop currentpacking true setpacking} if
10 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /processoptions dup /uk.co.terryburton.bwipp findresource put
dup /parseinput dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin

%
% Enumerate vergrps
%
[
    /qrcode.v1to9    /qrcode.v10to26  /qrcode.v27to40
    /qrcode.vM1      /qrcode.vM2      /qrcode.vM3      /qrcode.vM4
    /qrcode.vR7x43   /qrcode.vR7x59   /qrcode.vR7x77   /qrcode.vR7x99   /qrcode.vR7x139
    /qrcode.vR9x43   /qrcode.vR9x59   /qrcode.vR9x77   /qrcode.vR9x99   /qrcode.vR9x139
    /qrcode.vR11x27  /qrcode.vR11x43  /qrcode.vR11x59  /qrcode.vR11x77  /qrcode.vR11x99   /qrcode.vR11x139
    /qrcode.vR13x27  /qrcode.vR13x43  /qrcode.vR13x59  /qrcode.vR13x77  /qrcode.vR13x99   /qrcode.vR13x139
    /qrcode.vR15x43  /qrcode.vR15x59  /qrcode.vR15x77  /qrcode.vR15x99  /qrcode.vR15x139
    /qrcode.vR17x43  /qrcode.vR17x59  /qrcode.vR17x77  /qrcode.vR17x99  /qrcode.vR17x139
] 0 exch {1 index def 1 add} bind forall pop

%
% Encoding modes: (N)umeric, (A)lphanumeric, (B)yte, (K)anji, (E)CI
%
/qrcode.N 0 def  /qrcode.A 1 def  /qrcode.B 2 def  /qrcode.K 3 def  /qrcode.E 4 def

%
% Encoding function names
%
/qrcode.encfuncs [ /encN /encA /encB /encK /encE ] readonly def

/qrcode.fn1 -1 def

%
% Characters exclusive to each encoding mode
%
/qrcode.Nexcl <<
   [
       16#30 1 16#39 {} for
   ] {-1} forall
>> readonly def

/qrcode.Aexcl <<
    [
        16#20 16#24 16#25 16#2A 16#2B 16#2D 16#2E 16#2F 16#3A
        16#41 1 16#5A {} for
        //qrcode.fn1
    ] {-1} forall
>> readonly def

/qrcode.Kexcl <<
    [
        16#81 1 16#9F {} for
        16#E0 1 16#EB {} for
    ] {-1} forall
>> readonly def

% Note: Binary exclusives are calculated from "not others"

%
% Mode identifiers
%
/qrcode.mids [
    %           N      A      B      K      E
           [ (0001) (0010) (0100) (1000) (0111) ]  % v1to9
    dup  % [ (0001) (0010) (0100) (1000) (0111) ]  % v10to26
    dup  % [ (0001) (0010) (0100) (1000) (0111) ]  % v27to40
           [     ()   -1     -1     -1     -1   ]  % vM1
           [    (0)    (1)   -1     -1     -1   ]  % vM2
           [   (00)   (01)   (10)   (11)   -1   ]  % vM3
           [  (000)  (001)  (010)  (011)   -1   ]  % vM4
           [  (001)  (010)  (011)  (100)  (111) ]  % vR7x43 ...
    31 { dup } repeat                              % ... vR17x139
] readonly def

%
% Character counts for each mode for each version
%
/qrcode.cclens [
    % N  A  B  K
    [ 10  9  8  8 ]  % v1to9
    [ 12 11 16 10 ]  % v10to26
    [ 14 13 16 12 ]  % v27to40
    [  3 -1 -1 -1 ]  % vM1
    [  4  3 -1 -1 ]  % vM2
    [  5  4  4  3 ]  % vM3
    [  6  5  5  4 ]  % vM4
    [  4  3  3  2 ]  % vR7x43
    [  5  5  4  3 ]  % vR7x59
    [  6  5  5  4 ]  % vR7x77
    [  7  6  5  5 ]  % vR7x99
    [  7  6  6  5 ]  % vR7x139
    [  5  5  4  3 ]  % vR9x43
    [  6  5  5  4 ]  % vR9x59
    [  7  6  5  5 ]  % vR9x77
    [  7  6  6  5 ]  % vR9x99
    [  8  7  6  6 ]  % vR9x139
    [  4  4  3  2 ]  % vR11x27
    [  6  5  5  4 ]  % vR11x43
    [  7  6  5  5 ]  % vR11x59
    [  7  6  6  5 ]  % vR11x77
    [  8  7  6  6 ]  % vR11x99
    [  8  7  7  6 ]  % vR11x139
    [  5  5  4  3 ]  % vR13x27
    [  6  6  5  5 ]  % vR13x43
    [  7  6  6  5 ]  % vR13x59
    [  7  7  6  6 ]  % vR13x77
    [  8  7  7  6 ]  % vR13x99
    [  8  8  7  7 ]  % vR13x139
    [  7  6  6  5 ]  % vR15x43
    [  7  7  6  5 ]  % vR15x59
    [  8  7  7  6 ]  % vR15x77
    [  8  7  7  6 ]  % vR15x99
    [  9  8  7  7 ]  % vR15x139
    [  7  6  6  5 ]  % vR17x43
    [  8  7  6  6 ]  % vR17x59
    [  8  7  7  6 ]  % vR17x77
    [  8  8  7  6 ]  % vR17x99
    [  9  8  8  7 ]  % vR17x139
] readonly def

%
% Terminiator length for each version
%
/qrcode.termlens [
  3 {
    4  % v1to9 ... v27to40
  } repeat
    3  % vM1
    5  % vM2
    7  % vM3
    9  % vM4
  32 {
    3  % vR7x43 ... vR17x139
  } repeat
] readonly def

%
% Padding sequences
%
/qrcode.padstrs [ (11101100) (00010001) ] readonly def

%
% Alphanumeric character to value map
%
/qrcode.charmap (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:) def

%
% Version group mapping for each symbol size
%
/qrcode.versetmap <<
    (full) <<
         0 1  9 { 10 2 string cvrs //qrcode.v1to9   } bind for
        10 1 26 { 10 2 string cvrs //qrcode.v10to26 } bind for
        27 1 40 { 10 2 string cvrs //qrcode.v27to40 } bind for
    >>
    (micro) <<
        (M1) //qrcode.vM1  (M2) //qrcode.vM2  (M3) //qrcode.vM3  (M4) //qrcode.vM4
    >>
    (rmqr) <<
                                   (R7x43)  //qrcode.vR7x43   (R7x59)  //qrcode.vR7x59   (R7x77)  //qrcode.vR7x77   (R7x99)  //qrcode.vR7x99   (R7x139)  //qrcode.vR7x139
                                   (R9x43)  //qrcode.vR9x43   (R9x59)  //qrcode.vR9x59   (R9x77)  //qrcode.vR9x77   (R9x99)  //qrcode.vR9x99   (R9x139)  //qrcode.vR9x139
        (R11x27) //qrcode.vR11x27  (R11x43) //qrcode.vR11x43  (R11x59) //qrcode.vR11x59  (R11x77) //qrcode.vR11x77  (R11x99) //qrcode.vR11x99  (R11x139) //qrcode.vR11x139
        (R13x27) //qrcode.vR13x27  (R13x43) //qrcode.vR13x43  (R13x59) //qrcode.vR13x59  (R13x77) //qrcode.vR13x77  (R13x99) //qrcode.vR13x99  (R13x139) //qrcode.vR13x139
                                   (R15x43) //qrcode.vR15x43  (R15x59) //qrcode.vR15x59  (R15x77) //qrcode.vR15x77  (R15x99) //qrcode.vR15x99  (R15x139) //qrcode.vR15x139
                                   (R17x43) //qrcode.vR17x43  (R17x59) //qrcode.vR17x59  (R17x77) //qrcode.vR17x77  (R17x99) //qrcode.vR17x99  (R17x139) //qrcode.vR17x139
    >>
>> readonly def

/qrcode.versetfull  [ //qrcode.v1to9 //qrcode.v10to26 //qrcode.v27to40 ] readonly def
/qrcode.versetmicro [ //qrcode.vM1 //qrcode.vM2 //qrcode.vM3 //qrcode.vM4 ] readonly def

%
% Symbol specification table
%
/qrcode.metrics [
    % format   vers       vergrp           rows cols align modules    error codewords        error correction blocks
    %                                                                 L    M    Q    H       L1 L2 M1 M2 Q1 Q2 H1 H2
    [ (micro)  (M1)       //qrcode.vM1       11  11  98 99     36  [   2   99   99   99 ]  [  1  0 -1 -1 -1 -1 -1 -1 ] ]
    [ (micro)  (M2)       //qrcode.vM2       13  13  98 99     80  [   5    6   99   99 ]  [  1  0  1  0 -1 -1 -1 -1 ] ]
    [ (micro)  (M3)       //qrcode.vM3       15  15  98 99    132  [   6    8   99   99 ]  [  1  0  1  0 -1 -1 -1 -1 ] ]
    [ (micro)  (M4)       //qrcode.vM4       17  17  98 99    192  [   8   10   14   99 ]  [  1  0  1  0  1  0 -1 -1 ] ]
    [ (full)   (1)        //qrcode.v1to9     21  21  98 99    208  [   7   10   13   17 ]  [  1  0  1  0  1  0  1  0 ] ]
    [ (full)   (2)        //qrcode.v1to9     25  25  18 99    359  [  10   16   22   28 ]  [  1  0  1  0  1  0  1  0 ] ]
    [ (full)   (3)        //qrcode.v1to9     29  29  22 99    567  [  15   26   36   44 ]  [  1  0  1  0  2  0  2  0 ] ]
    [ (full)   (4)        //qrcode.v1to9     33  33  26 99    807  [  20   36   52   64 ]  [  1  0  2  0  2  0  4  0 ] ]
    [ (full)   (5)        //qrcode.v1to9     37  37  30 99   1079  [  26   48   72   88 ]  [  1  0  2  0  2  2  2  2 ] ]
    [ (full)   (6)        //qrcode.v1to9     41  41  34 99   1383  [  36   64   96  112 ]  [  2  0  4  0  4  0  4  0 ] ]
    [ (full)   (7)        //qrcode.v1to9     45  45  22 38   1568  [  40   72  108  130 ]  [  2  0  4  0  2  4  4  1 ] ]
    [ (full)   (8)        //qrcode.v1to9     49  49  24 42   1936  [  48   88  132  156 ]  [  2  0  2  2  4  2  4  2 ] ]
    [ (full)   (9)        //qrcode.v1to9     53  53  26 46   2336  [  60  110  160  192 ]  [  2  0  3  2  4  4  4  4 ] ]
    [ (full)   (10)       //qrcode.v10to26   57  57  28 50   2768  [  72  130  192  224 ]  [  2  2  4  1  6  2  6  2 ] ]
    [ (full)   (11)       //qrcode.v10to26   61  61  30 54   3232  [  80  150  224  264 ]  [  4  0  1  4  4  4  3  8 ] ]
    [ (full)   (12)       //qrcode.v10to26   65  65  32 58   3728  [  96  176  260  308 ]  [  2  2  6  2  4  6  7  4 ] ]
    [ (full)   (13)       //qrcode.v10to26   69  69  34 62   4256  [ 104  198  288  352 ]  [  4  0  8  1  8  4 12  4 ] ]
    [ (full)   (14)       //qrcode.v10to26   73  73  26 46   4651  [ 120  216  320  384 ]  [  3  1  4  5 11  5 11  5 ] ]
    [ (full)   (15)       //qrcode.v10to26   77  77  26 48   5243  [ 132  240  360  432 ]  [  5  1  5  5  5  7 11  7 ] ]
    [ (full)   (16)       //qrcode.v10to26   81  81  26 50   5867  [ 144  280  408  480 ]  [  5  1  7  3 15  2  3 13 ] ]
    [ (full)   (17)       //qrcode.v10to26   85  85  30 54   6523  [ 168  308  448  532 ]  [  1  5 10  1  1 15  2 17 ] ]
    [ (full)   (18)       //qrcode.v10to26   89  89  30 56   7211  [ 180  338  504  588 ]  [  5  1  9  4 17  1  2 19 ] ]
    [ (full)   (19)       //qrcode.v10to26   93  93  30 58   7931  [ 196  364  546  650 ]  [  3  4  3 11 17  4  9 16 ] ]
    [ (full)   (20)       //qrcode.v10to26   97  97  34 62   8683  [ 224  416  600  700 ]  [  3  5  3 13 15  5 15 10 ] ]
    [ (full)   (21)       //qrcode.v10to26  101 101  28 50   9252  [ 224  442  644  750 ]  [  4  4 17  0 17  6 19  6 ] ]
    [ (full)   (22)       //qrcode.v10to26  105 105  26 50  10068  [ 252  476  690  816 ]  [  2  7 17  0  7 16 34  0 ] ]
    [ (full)   (23)       //qrcode.v10to26  109 109  30 54  10916  [ 270  504  750  900 ]  [  4  5  4 14 11 14 16 14 ] ]
    [ (full)   (24)       //qrcode.v10to26  113 113  28 54  11796  [ 300  560  810  960 ]  [  6  4  6 14 11 16 30  2 ] ]
    [ (full)   (25)       //qrcode.v10to26  117 117  32 58  12708  [ 312  588  870 1050 ]  [  8  4  8 13  7 22 22 13 ] ]
    [ (full)   (26)       //qrcode.v10to26  121 121  30 58  13652  [ 336  644  952 1110 ]  [ 10  2 19  4 28  6 33  4 ] ]
    [ (full)   (27)       //qrcode.v27to40  125 125  34 62  14628  [ 360  700 1020 1200 ]  [  8  4 22  3  8 26 12 28 ] ]
    [ (full)   (28)       //qrcode.v27to40  129 129  26 50  15371  [ 390  728 1050 1260 ]  [  3 10  3 23  4 31 11 31 ] ]
    [ (full)   (29)       //qrcode.v27to40  133 133  30 54  16411  [ 420  784 1140 1350 ]  [  7  7 21  7  1 37 19 26 ] ]
    [ (full)   (30)       //qrcode.v27to40  137 137  26 52  17483  [ 450  812 1200 1440 ]  [  5 10 19 10 15 25 23 25 ] ]
    [ (full)   (31)       //qrcode.v27to40  141 141  30 56  18587  [ 480  868 1290 1530 ]  [ 13  3  2 29 42  1 23 28 ] ]
    [ (full)   (32)       //qrcode.v27to40  145 145  34 60  19723  [ 510  924 1350 1620 ]  [ 17  0 10 23 10 35 19 35 ] ]
    [ (full)   (33)       //qrcode.v27to40  149 149  30 58  20891  [ 540  980 1440 1710 ]  [ 17  1 14 21 29 19 11 46 ] ]
    [ (full)   (34)       //qrcode.v27to40  153 153  34 62  22091  [ 570 1036 1530 1800 ]  [ 13  6 14 23 44  7 59  1 ] ]
    [ (full)   (35)       //qrcode.v27to40  157 157  30 54  23008  [ 570 1064 1590 1890 ]  [ 12  7 12 26 39 14 22 41 ] ]
    [ (full)   (36)       //qrcode.v27to40  161 161  24 50  24272  [ 600 1120 1680 1980 ]  [  6 14  6 34 46 10  2 64 ] ]
    [ (full)   (37)       //qrcode.v27to40  165 165  28 54  25568  [ 630 1204 1770 2100 ]  [ 17  4 29 14 49 10 24 46 ] ]
    [ (full)   (38)       //qrcode.v27to40  169 169  32 58  26896  [ 660 1260 1860 2220 ]  [  4 18 13 32 48 14 42 32 ] ]
    [ (full)   (39)       //qrcode.v27to40  173 173  26 54  28256  [ 720 1316 1950 2310 ]  [ 20  4 40  7 43 22 10 67 ] ]
    [ (full)   (40)       //qrcode.v27to40  177 177  30 58  29648  [ 750 1372 2040 2430 ]  [ 19  6 18 31 34 34 20 61 ] ]
    [ (rmqr)   (R7x43)    //qrcode.vR7x43     7  43  22 99    104  [  99    7   99   10 ]  [ -1 -1  1  0 -1 -1  1  0 ] ]
    [ (rmqr)   (R7x59)    //qrcode.vR7x59     7  59  20 40    171  [  99    9   99   14 ]  [ -1 -1  1  0 -1 -1  1  0 ] ]
    [ (rmqr)   (R7x77)    //qrcode.vR7x77     7  77  26 52    261  [  99   12   99   22 ]  [ -1 -1  1  0 -1 -1  1  0 ] ]
    [ (rmqr)   (R7x99)    //qrcode.vR7x99     7  99  24 50    358  [  99   16   99   30 ]  [ -1 -1  1  0 -1 -1  1  0 ] ]
    [ (rmqr)   (R7x139)   //qrcode.vR7x139    7 139  28 56    545  [  99   24   99   44 ]  [ -1 -1  1  0 -1 -1  2  0 ] ]
    [ (rmqr)   (R9x43)    //qrcode.vR9x43     9  43  22 99    170  [  99    9   99   14 ]  [ -1 -1  1  0 -1 -1  1  0 ] ]
    [ (rmqr)   (R9x59)    //qrcode.vR9x59     9  59  20 40    267  [  99   12   99   22 ]  [ -1 -1  1  0 -1 -1  1  0 ] ]
    [ (rmqr)   (R9x77)    //qrcode.vR9x77     9  77  26 52    393  [  99   18   99   32 ]  [ -1 -1  1  0 -1 -1  1  1 ] ]
    [ (rmqr)   (R9x99)    //qrcode.vR9x99     9  99  24 50    532  [  99   24   99   44 ]  [ -1 -1  1  0 -1 -1  2  0 ] ]
    [ (rmqr)   (R9x139)   //qrcode.vR9x139    9 139  28 56    797  [  99   36   99   66 ]  [ -1 -1  1  1 -1 -1  3  0 ] ]
    [ (rmqr)   (R11x27)   //qrcode.vR11x27   11  27  98 99    122  [  99    8   99   10 ]  [ -1 -1  1  0 -1 -1  1  0 ] ]
    [ (rmqr)   (R11x43)   //qrcode.vR11x43   11  43  22 99    249  [  99   12   99   20 ]  [ -1 -1  1  0 -1 -1  1  0 ] ]
    [ (rmqr)   (R11x59)   //qrcode.vR11x59   11  59  20 40    376  [  99   16   99   32 ]  [ -1 -1  1  0 -1 -1  1  1 ] ]
    [ (rmqr)   (R11x77)   //qrcode.vR11x77   11  77  26 52    538  [  99   24   99   44 ]  [ -1 -1  1  0 -1 -1  1  1 ] ]
    [ (rmqr)   (R11x99)   //qrcode.vR11x99   11  99  24 50    719  [  99   32   99   60 ]  [ -1 -1  1  1 -1 -1  1  1 ] ]
    [ (rmqr)   (R11x139)  //qrcode.vR11x139  11 139  28 56   1062  [  99   48   99   90 ]  [ -1 -1  2  0 -1 -1  3  0 ] ]
    [ (rmqr)   (R13x27)   //qrcode.vR13x27   13  27  98 99    172  [  99    9   99   14 ]  [ -1 -1  1  0 -1 -1  1  0 ] ]
    [ (rmqr)   (R13x43)   //qrcode.vR13x43   13  43  22 99    329  [  99   14   99   28 ]  [ -1 -1  1  0 -1 -1  1  0 ] ]
    [ (rmqr)   (R13x59)   //qrcode.vR13x59   13  59  20 40    486  [  99   22   99   40 ]  [ -1 -1  1  0 -1 -1  2  0 ] ]
    [ (rmqr)   (R13x77)   //qrcode.vR13x77   13  77  26 52    684  [  99   32   99   56 ]  [ -1 -1  1  1 -1 -1  1  1 ] ]
    [ (rmqr)   (R13x99)   //qrcode.vR13x99   13  99  24 50    907  [  99   40   99   78 ]  [ -1 -1  1  1 -1 -1  1  2 ] ]
    [ (rmqr)   (R13x139)  //qrcode.vR13x139  13 139  28 56   1328  [  99   60   99  112 ]  [ -1 -1  2  1 -1 -1  2  2 ] ]
    [ (rmqr)   (R15x43)   //qrcode.vR15x43   15  43  22 99    409  [  99   18   99   36 ]  [ -1 -1  1  0 -1 -1  1  1 ] ]
    [ (rmqr)   (R15x59)   //qrcode.vR15x59   15  59  20 40    596  [  99   26   99   48 ]  [ -1 -1  1  0 -1 -1  2  0 ] ]
    [ (rmqr)   (R15x77)   //qrcode.vR15x77   15  77  26 52    830  [  99   36   99   72 ]  [ -1 -1  1  1 -1 -1  2  1 ] ]
    [ (rmqr)   (R15x99)   //qrcode.vR15x99   15  99  24 50   1095  [  99   48   99   88 ]  [ -1 -1  2  0 -1 -1  4  0 ] ]
    [ (rmqr)   (R15x139)  //qrcode.vR15x139  15 139  28 56   1594  [  99   72   99  130 ]  [ -1 -1  2  1 -1 -1  1  4 ] ]
    [ (rmqr)   (R17x43)   //qrcode.vR17x43   17  43  22 99    489  [  99   22   99   40 ]  [ -1 -1  1  0 -1 -1  1  1 ] ]
    [ (rmqr)   (R17x59)   //qrcode.vR17x59   17  59  20 40    706  [  99   32   99   60 ]  [ -1 -1  2  0 -1 -1  2  0 ] ]
    [ (rmqr)   (R17x77)   //qrcode.vR17x77   17  77  26 52    976  [  99   44   99   84 ]  [ -1 -1  2  0 -1 -1  1  2 ] ]
    [ (rmqr)   (R17x99)   //qrcode.vR17x99   17  99  24 50   1283  [  99   60   99  104 ]  [ -1 -1  2  1 -1 -1  4  0 ] ]
    [ (rmqr)   (R17x139)  //qrcode.vR17x139  17 139  28 56   1860  [  99   80   99  156 ]  [ -1 -1  4  0 -1 -1  2  4 ] ]
] readonly def

%
% Finder patterns
%
/qrcode.fpat [
               [ 1 1 1 1 1 1 1 0 ]
               [ 1 0 0 0 0 0 1 0 ]
               [ 1 0 1 1 1 0 1 0 ]
    dup      % [ 1 0 1 1 1 0 1 0 ]
    dup      % [ 1 0 1 1 1 0 1 0 ]
    3 index  % [ 1 0 0 0 0 0 1 0 ]
    5 index  % [ 1 1 1 1 1 1 1 0 ]
               [ 0 0 0 0 0 0 0 0 ]
] readonly def

/qrcode.fsubpat [
               [ 1 1 1 1 1 9 9 9 ]
               [ 1 0 0 0 1 9 9 9 ]
               [ 1 0 1 0 1 9 9 9 ]
    1 index  % [ 1 0 0 0 1 9 9 9 ]
    3 index  % [ 1 1 1 1 1 9 9 9 ]
               [ 9 9 9 9 9 9 9 9 ]
    dup      % [ 9 9 9 9 9 9 9 9 ]
    dup      % [ 9 9 9 9 9 9 9 9 ]
] readonly def

/qrcode.fcorpat [
               [ 1 1 1 9 9 9 9 9 ]
               [ 1 0 9 9 9 9 9 9 ]
               [ 1 9 9 9 9 9 9 9 ]
               [ 9 9 9 9 9 9 9 9 ]
    dup      % [ 9 9 9 9 9 9 9 9 ]
    dup      % [ 9 9 9 9 9 9 9 9 ]
    dup      % [ 9 9 9 9 9 9 9 9 ]
    dup      % [ 9 9 9 9 9 9 9 9 ]
] readonly def

/qrcode.fnullpat [
               [ 9 9 9 9 9 9 9 9 ]
    dup      % [ 9 9 9 9 9 9 9 9 ]
    dup      % [ 9 9 9 9 9 9 9 9 ]
    dup      % [ 9 9 9 9 9 9 9 9 ]
    dup      % [ 9 9 9 9 9 9 9 9 ]
    dup      % [ 9 9 9 9 9 9 9 9 ]
    dup      % [ 9 9 9 9 9 9 9 9 ]
    dup      % [ 9 9 9 9 9 9 9 9 ]
] readonly def

%
% Finder pattern layout
%
/qrcode.fpatmap <<
    %               TL             TR                 BL                 BR
    (full)  [ //qrcode.fpat  //qrcode.fpat      //qrcode.fpat      //qrcode.fnullpat ]
    (micro) [ //qrcode.fpat  //qrcode.fnullpat  //qrcode.fnullpat  //qrcode.fnullpat ]
    (rmqr)  [ //qrcode.fpat  //qrcode.fcorpat   //qrcode.fcorpat   //qrcode.fsubpat  ]
>> readonly def

%
% Alignment patterns
%
/qrcode.algnpatfull [
               [ 1 1 1 1 1 ]
               [ 1 0 0 0 1 ]
               [ 1 0 1 0 1 ]
    1 index  % [ 1 0 0 0 1 ]
    3 index  % [ 1 1 1 1 1 ]
] readonly def

/qrcode.algnpatrmqr [
               [ 1 1 1 9 9 ]
               [ 1 0 1 9 9 ]
    1 index  % [ 1 1 1 9 9 ]
               [ 9 9 9 9 9 ]
    dup      % [ 9 9 9 9 9 ]
] readonly def

%
% Format information module map
%
/qrcode.formatfimmap <<
    (full) [
        [ { pop pop 0 8 } bind  { pop 8 exch 1 sub } bind ]
        [ { pop pop 1 8 } bind  { pop 8 exch 2 sub } bind ]
        [ { pop pop 2 8 } bind  { pop 8 exch 3 sub } bind ]
        [ { pop pop 3 8 } bind  { pop 8 exch 4 sub } bind ]
        [ { pop pop 4 8 } bind  { pop 8 exch 5 sub } bind ]
        [ { pop pop 5 8 } bind  { pop 8 exch 6 sub } bind ]
        [ { pop pop 7 8 } bind  { pop 8 exch 7 sub } bind ]
        [ { pop pop 8 8 } bind  { pop 8 sub  8     } bind ]
        [ { pop pop 8 7 } bind  { pop 7 sub  8     } bind ]
        [ { pop pop 8 5 } bind  { pop 6 sub  8     } bind ]
        [ { pop pop 8 4 } bind  { pop 5 sub  8     } bind ]
        [ { pop pop 8 3 } bind  { pop 4 sub  8     } bind ]
        [ { pop pop 8 2 } bind  { pop 3 sub  8     } bind ]
        [ { pop pop 8 1 } bind  { pop 2 sub  8     } bind ]
        [ { pop pop 8 0 } bind  { pop 1 sub  8     } bind ]
    ]
    (micro) [
        [ { pop pop 1 8 } bind ]
        [ { pop pop 2 8 } bind ]
        [ { pop pop 3 8 } bind ]
        [ { pop pop 4 8 } bind ]
        [ { pop pop 5 8 } bind ]
        [ { pop pop 6 8 } bind ]
        [ { pop pop 7 8 } bind ]
        [ { pop pop 8 8 } bind ]
        [ { pop pop 8 7 } bind ]
        [ { pop pop 8 6 } bind ]
        [ { pop pop 8 5 } bind ]
        [ { pop pop 8 4 } bind ]
        [ { pop pop 8 3 } bind ]
        [ { pop pop 8 2 } bind ]
        [ { pop pop 8 1 } bind ]
    ]
    (rmqr) [
        [ { pop pop 11 3 } bind  { 3 sub exch 6 sub } bind ]
        [ { pop pop 11 2 } bind  { 4 sub exch 6 sub } bind ]
        [ { pop pop 11 1 } bind  { 5 sub exch 6 sub } bind ]
        [ { pop pop 10 5 } bind  { 6 sub exch 2 sub } bind ]
        [ { pop pop 10 4 } bind  { 6 sub exch 3 sub } bind ]
        [ { pop pop 10 3 } bind  { 6 sub exch 4 sub } bind ]
        [ { pop pop 10 2 } bind  { 6 sub exch 5 sub } bind ]
        [ { pop pop 10 1 } bind  { 6 sub exch 6 sub } bind ]
        [ { pop pop  9 5 } bind  { 7 sub exch 2 sub } bind ]
        [ { pop pop  9 4 } bind  { 7 sub exch 3 sub } bind ]
        [ { pop pop  9 3 } bind  { 7 sub exch 4 sub } bind ]
        [ { pop pop  9 2 } bind  { 7 sub exch 5 sub } bind ]
        [ { pop pop  9 1 } bind  { 7 sub exch 6 sub } bind ]
        [ { pop pop  8 5 } bind  { 8 sub exch 2 sub } bind ]
        [ { pop pop  8 4 } bind  { 8 sub exch 3 sub } bind ]
        [ { pop pop  8 3 } bind  { 8 sub exch 4 sub } bind ]
        [ { pop pop  8 2 } bind  { 8 sub exch 5 sub } bind ]
        [ { pop pop  8 1 } bind  { 8 sub exch 6 sub } bind ]
    ]
>> readonly def

%
% ECC values for generating format information
%
/qrcode.ecidfull [ 1 0 3 2 ] readonly def
/qrcode.ecidrmqr [ -1 0 -1 1 ] readonly def
/qrcode.ecidmicrosym [ [0] [1 2] [3 4] [5 6 7] ] readonly def

%
% Format information value tables
%
/qrcode.fmtvalsfull [
    16#5412 16#5125 16#5e7c 16#5b4b 16#45f9 16#40ce 16#4f97 16#4aa0
    16#77c4 16#72f3 16#7daa 16#789d 16#662f 16#6318 16#6c41 16#6976
    16#1689 16#13be 16#1ce7 16#19d0 16#0762 16#0255 16#0d0c 16#083b
    16#355f 16#3068 16#3f31 16#3a06 16#24b4 16#2183 16#2eda 16#2bed
] readonly def

/qrcode.fmtvalsmicro [
    16#4445 16#4172 16#4e2b 16#4b1c 16#55ae 16#5099 16#5fc0 16#5af7
    16#6793 16#62a4 16#6dfd 16#68ca 16#7678 16#734f 16#7c16 16#7921
    16#06de 16#03e9 16#0cb0 16#0987 16#1735 16#1202 16#1d5b 16#186c
    16#2508 16#203f 16#2f66 16#2a51 16#34e3 16#31d4 16#3e8d 16#3bba
] readonly def

/qrcode.fmtvalsrmqr1 [
    16#1fab2 16#1e597 16#1dbdd 16#1c4f8 16#1b86c 16#1a749 16#19903 16#18626
    16#17f0e 16#1602b 16#15e61 16#14144 16#13dd0 16#122f5 16#11cbf 16#1039a
    16#0f1ca 16#0eeef 16#0d0a5 16#0cf80 16#0b314 16#0ac31 16#0927b 16#08d5e
    16#07476 16#06b53 16#05519 16#04a3c 16#036a8 16#0298d 16#017c7 16#008e2
    16#3f367 16#3ec42 16#3d208 16#3cd2d 16#3b1b9 16#3ae9c 16#390d6 16#38ff3
    16#376db 16#369fe 16#357b4 16#34891 16#33405 16#32b20 16#3156a 16#30a4f
    16#2f81f 16#2e73a 16#2d970 16#2c655 16#2bac1 16#2a5e4 16#29bae 16#2848b
    16#27da3 16#26286 16#25ccc 16#243e9 16#23f7d 16#22058 16#21e12 16#20137
] readonly def

/qrcode.fmtvalsrmqr2 [
    16#20a7b 16#2155e 16#22b14 16#23431 16#248a5 16#25780 16#269ca 16#276ef
    16#28fc7 16#290e2 16#2aea8 16#2b18d 16#2cd19 16#2d23c 16#2ec76 16#2f353
    16#30103 16#31e26 16#3206c 16#33f49 16#343dd 16#35cf8 16#362b2 16#37d97
    16#384bf 16#39b9a 16#3a5d0 16#3baf5 16#3c661 16#3d944 16#3e70e 16#3f82b
    16#003ae 16#01c8b 16#022c1 16#03de4 16#04170 16#05e55 16#0601f 16#07f3a
    16#08612 16#09937 16#0a77d 16#0b858 16#0c4cc 16#0dbe9 16#0e5a3 16#0fa86
    16#108d6 16#117f3 16#129b9 16#1369c 16#14a08 16#1552d 16#16b67 16#17442
    16#18d6a 16#1924f 16#1ac05 16#1b320 16#1cfb4 16#1d091 16#1eedb 16#1f1fe
] readonly def

%
% Version information module map (QR Code only)
%
/qrcode.vimmap [
    [ {  9 sub 5 } bind  { 5 exch  9 sub } bind ]
    [ { 10 sub 5 } bind  { 5 exch 10 sub } bind ]
    [ { 11 sub 5 } bind  { 5 exch 11 sub } bind ]
    [ {  9 sub 4 } bind  { 4 exch  9 sub } bind ]
    [ { 10 sub 4 } bind  { 4 exch 10 sub } bind ]
    [ { 11 sub 4 } bind  { 4 exch 11 sub } bind ]
    [ {  9 sub 3 } bind  { 3 exch  9 sub } bind ]
    [ { 10 sub 3 } bind  { 3 exch 10 sub } bind ]
    [ { 11 sub 3 } bind  { 3 exch 11 sub } bind ]
    [ {  9 sub 2 } bind  { 2 exch  9 sub } bind ]
    [ { 10 sub 2 } bind  { 2 exch 10 sub } bind ]
    [ { 11 sub 2 } bind  { 2 exch 11 sub } bind ]
    [ {  9 sub 1 } bind  { 1 exch  9 sub } bind ]
    [ { 10 sub 1 } bind  { 1 exch 10 sub } bind ]
    [ { 11 sub 1 } bind  { 1 exch 11 sub } bind ]
    [ {  9 sub 0 } bind  { 0 exch  9 sub } bind ]
    [ { 10 sub 0 } bind  { 0 exch 10 sub } bind ]
    [ { 11 sub 0 } bind  { 0 exch 11 sub } bind ]
] readonly def

%
% Version information value table
%
/qrcode.vervals [
    16#07c94 16#085bc 16#09a99 16#0a4d3 16#0bbf6 16#0c762 16#0d847
    16#0e60d 16#0f928 16#10b78 16#1145d 16#12a17 16#13532 16#149a6
    16#15683 16#168c9 16#177ec 16#18ec4 16#191e1 16#1afab 16#1b08e
    16#1cc1a 16#1d33f 16#1ed75 16#1f250 16#209d5 16#216f0 16#228ba
    16#2379f 16#24b0b 16#2542e 16#26a64 16#27541 16#28c69
] readonly def

%
% Mode optimization arrays
%
% Number of before characters per vergrp, depending on current mode, for optimising modes
% Generated by contrib/development/build-qr-mode-optim-arrs.php
%
/e 10000 def

%                        Full     Micro    R7         R9           R11             R13              R15             R17
/qrcode.mode0forceKB  [  1  1  1  e e 1 1  1 1 1 1 1  1 1 1 1  1   1 1 1 1  1  1   1 1 1  1  1  1   1  1  1  1  1   1  1  1  1  1 ] readonly def
/qrcode.mode0forceA   [  1  1  1  e 1 1 1  1 1 1 1 1  1 1 1 1  1   1 1 1 1  1  1   1 1 1  1  1  1   1  1  1  1  1   1  1  1  1  1 ] readonly def
/qrcode.mode0forceN   [  1  1  1  1 1 1 1  1 1 1 1 1  1 1 1 1  1   1 1 1 1  1  1   1 1 1  1  1  1   1  1  1  1  1   1  1  1  1  1 ] readonly def
/qrcode.mode0NbeforeB [  4  4  5  e e 2 3  2 2 3 3 3  2 3 3 3  3   2 3 3 3  3  3   2 3 3  3  3  3   3  3  3  3  3   3  3  3  3  3 ] readonly def
/qrcode.modeBKbeforeB [  9 12 13  e e 4 6  4 5 6 6 6  5 6 6 6  7   4 6 6 6  7  7   5 6 6  7  7  7   6  6  7  7  7   6  7  7  7  8 ] readonly def
/qrcode.modeBKbeforeA [  8 10 11  e e 4 5  4 5 5 6 6  5 5 6 6  6   4 5 6 6  6  6   5 6 6  6  6  7   6  6  6  6  7   6  6  6  7  7 ] readonly def
/qrcode.modeBKbeforeN [  8  9 11  e e 3 5  3 4 5 5 5  4 5 5 5  6   3 5 5 5  6  6   4 5 5  6  6  6   5  5  6  6  7   5  6  6  6  7 ] readonly def
/qrcode.modeBKbeforeE [  5  5  6  e e 2 3  2 3 3 3 3  3 3 3 3  4   2 3 3 3  4  4   3 3 3  4  4  4   3  3  4  4  4   3  4  4  4  4 ] readonly def
/qrcode.modeBAbeforeK [ 11 12 14  e e 5 7  5 6 7 8 8  6 7 8 8  8   6 7 8 8  8  8   6 8 8  8  8  9   8  8  8  8  9   8  8  8  9  9 ] readonly def
/qrcode.modeBAbeforeB [ 11 15 16  e e 6 7  6 7 7 8 8  7 7 8 8  8   6 7 8 8  8  9   7 8 8  8  9  9   8  8  9  9  9   8  8  9  9 10 ] readonly def
/qrcode.modeBAbeforeN [ 12 13 15  e e 6 8  6 7 8 8 8  7 8 8 8  9   6 8 8 8  9  9   7 8 8  9  9 10   8  9  9  9 10   8  9  9 10 10 ] readonly def
/qrcode.modeBAbeforeE [  6  7  8  e e 3 4  3 4 4 4 4  4 4 4 4  5   4 4 4 4  5  5   4 4 4  5  5  5   4  5  5  5  5   4  5  5  5  5 ] readonly def
/qrcode.modeBNbeforeK [  6  7  8  e e 3 4  3 4 4 5 5  4 4 5 5  5   3 4 5 5  5  5   4 4 5  5  5  5   5  5  5  5  5   5  5  5  5  5 ] readonly def
/qrcode.modeBNbeforeB [  6  8  9  e e 3 4  3 4 4 5 5  4 4 5 5  5   3 4 5 5  5  5   4 4 5  5  5  5   5  5  5  5  5   5  5  5  5  6 ] readonly def
/qrcode.modeBNbeforeA [  6  7  8  e e 3 4  3 4 4 5 5  4 4 5 5  5   4 4 5 5  5  5   4 5 5  5  5  5   5  5  5  5  6   5  5  5  5  6 ] readonly def
/qrcode.modeBNbeforeE [  3  4  4  e e 2 3  2 2 3 3 3  2 3 3 3  3   2 3 3 3  3  3   2 3 3  3  3  3   3  3  3  3  3   3  3  3  3  3 ] readonly def
/qrcode.modeANbeforeA [ 13 15 17  e 5 7 9  7 8 9 9 9  8 9 9 9 11   7 9 9 9 11 11   8 9 9 10 11 11   9 10 11 11 11   9 11 11 11 11 ] readonly def
/qrcode.modeANbeforeB [ 13 17 18  e e 7 9  7 8 9 9 9  8 9 9 9 10   7 9 9 9 10 11   8 9 9  9 11 11   9  9 11 11 11   9 10 11 11 11 ] readonly def
/qrcode.modeANbeforeE [  7  8  9  e 3 4 5  4 5 5 5 5  5 5 5 5  6   4 5 5 5  6  6   5 5 5  5  6  6   5  5  6  6  6   5  6  6  6  6 ] readonly def

%
% Mask functions
%
/qrcode.maskfuncs [
    {add 2 mod} bind                                      % 0: (i+j) % 2
    {exch pop 2 mod} bind                                 % 1: j % 2
    {pop 3 mod} bind                                      % 2: i % 3
    {add 3 mod} bind                                      % 3: (i+j) % 3
    {2 idiv exch 3 idiv add 2 mod} bind                   % 4: (j/2 + i/3) % 2
    {mul dup 2 mod exch 3 mod add} bind                   % 5: (i*j) % 2 + (i*j) % 3
    {mul dup 2 mod exch 3 mod add 2 mod} bind             % 6: ((i*j) % 2 + (i*j) % 3) % 2
    {2 copy mul 3 mod 3 1 roll add 2 mod add 2 mod} bind  % 7: ((i*j) % 3 + (i+j) % 2) % 2
] readonly def

%
% Mask bit positions in funcpatlayers for each format
%
% Entries relate to the numbered mask functions above.
%
/qrcode.formatmaskbits <<
    (full)  [ 0 1 2 3 4 5 6 7 ]
    (micro) [ 1 4 6 7 ]
    (rmqr)  [ 4 ]
>> readonly def

/qrcode.latevars dup 9 dict def load /init {

    currentglobal
    true setglobal

    //qrcode.latevars begin

    %
    % Invert charmap to give character to value map
    %
    /charvals 44 dict def
    0 1 44 {dup //qrcode.charmap exch get exch charvals 3 1 roll put} for
    /charvals charvals readonly def

    %
    % Calculate the Reed-Solomon log and anti-log tables
    %
    /rsalog [ 1 255 { dup 2 mul dup 256 ge {285 xor} if } repeat ] readonly def
    /rslog 256 array def
    1 1 255 {dup rsalog exch get exch rslog 3 1 roll put} for
    /rslog rslog readonly def

    %
    % The mask functions have 6x12 periodicity, so we compute an 8-layer array
    % representing all mask function patterns at bit positions
    %
    /funcpatlayers 6 12 mul array def
    0 1 11 {
        /j exch def
        0 1 5 {
            /i exch def
            /bits 0 def
            0 1 7 {
                /m exch def
                i j //qrcode.maskfuncs m get exec 0 eq { /bits bits 1 m bitshift or def } if
            } for
            funcpatlayers j 6 mul i add bits put
        } for
    } for
    /funcpatlayers funcpatlayers readonly def

    /init { //qrcode.latevars {def} forall } def

    end

    //qrcode.latevars /init get exec

    setglobal

} bind put

/uk.co.terryburton.bwipp.global_ctx dup where {
    exch get /preload known {//qrcode.latevars /init get exec} if
} {pop} ifelse

/qrcode {

    20 dict begin

    /dontdraw false def
    /format (unset) def    % full or micro. rMQR symbols are specified using version
    /version (unset) def   % 1-40 or M1-M4 or R7x43, etc
    /eclevel (unset) def   % full: L, M, Q, H; micro: L, M, Q; rmqr: M, H
    /fixedeclevel false def
    /parse false def
    /parsefnc false def
    /mask -1 def
    /suppresskanjimode false def

    //processoptions exec /options exch def
    /barcode exch def

    //qrcode.latevars /init get exec

    barcode () eq {
        /bwipp.qrcodeEmptyData (The data must not be empty) //raiseerror exec
    } if

    %
    % If version is supplied and format is not given then set format to correspond
    %
    version (unset) ne {
        format (unset) eq {
            (full)
            version 0 1 getinterval (M) eq { pop (micro) } if
            version 0 1 getinterval (R) eq { pop (rmqr)  } if
            /format exch def
        } if
    } {
        format (unset) eq { /format (full) def } if  % Default to full
    } ifelse

    format (full) ne format (micro) ne format (rmqr) ne and and {
        /bwipp.qrcodeInvalidFormat (The format must be either full, micro or rmqr) //raiseerror exec
    } if

    format (rmqr) eq version (unset) eq and {
        /bwipp.qrcodeRMQRwithoutVersion (A version must be provided for RMQR) //raiseerror exec
    } if

    %
    % Default error correction level
    %
    eclevel (unset) eq {/eclevel format (micro) ne {(M)} {(L)} ifelse def} if

    eclevel (L) ne eclevel (M) ne eclevel (Q) ne eclevel (H) ne and and and {
        /bwipp.qrcodeInvalidEClevel (Error correction level must be either L, M, Q, or H) //raiseerror exec
    } if

    mask -1 ne format (rmqr) eq and {
        /bwipp.qrcodeRMQRmask (A mask cannot be supplied for RMQR) //raiseerror exec
    } if

    mask -1 ne {
        mask 1 lt mask format (full) eq {8} {4} ifelse gt or {
            /bwipp.qrcodeBadMask (An invalid mask was supplied) //raiseerror exec
        } if
    } if

    %
    % Parse the input
    %
    /fncvals <<
        /parse parse
        /parsefnc parsefnc
        /eci true
        (FNC1) //qrcode.fn1
    >> def
    /msg barcode fncvals //parseinput exec def
    /msglen msg length def

    %
    % If FNC1 in first position then escape % as %%
    %
    /fnc1first false def
    msglen 0 gt {
        msg 0 get //qrcode.fn1 eq {
            /fnc1first true def
            /msg [ msg 1 msglen 1 sub getinterval { dup 37 eq {dup} if } forall ] def
            /msglen msg length def
        } if
    } if

    %
    % Encoding functions
    %
    /tobin {
        string dup length 1 sub 0 exch 1 exch {1 index exch 48 put} for
        dup 3 -1 roll 2 2 index length string cvrs dup length 2 index length exch sub exch putinterval
    } def

    /encA {
        /in exch def
        fnc1first {  % FNC1 as %
            /in [ in { dup //qrcode.fn1 eq {pop 37} if } forall ] def
        } if
        /out in length 11 mul 2 idiv 1 add string def
        /k 0 def /m 0 def {
            k in length eq {exit} if
            k in length 1 sub lt {
                charvals in k get get 45 mul charvals in k 1 add get get add 11 tobin
                /k k 2 add def
            } {  % Final character
                charvals in k get get 6 tobin
                /k k 1 add def
            } ifelse
            dup out exch m exch putinterval
            length m add /m exch def
        } loop
        out 0 m getinterval
    } def

    /encN {
        /in exch def
        /out in length 10 mul 3 idiv 1 add string def
        /k 0 def /m 0 def {
            k in length eq {exit} if
            k in length 2 sub lt {
                in k 3 getinterval 0 exch {exch 10 mul 48 sub add} forall 10 tobin
                /k k 3 add def
            } {
                k in length 2 sub eq {  % Two final digits
                    in k 2 getinterval 0 exch {exch 10 mul 48 sub add} forall 7 tobin
                    /k k 2 add def
                } {  % One final digit
                    in k 1 getinterval 0 exch {exch 10 mul 48 sub add} forall 4 tobin
                    /k k 1 add def
                } ifelse
            } ifelse
            dup out exch m exch putinterval
            length m add /m exch def
        } loop
        out 0 m getinterval
    } def

    /encB {
        /in exch def
        fnc1first {  % FNC1 as GS
            /in [ in { dup //qrcode.fn1 eq {pop 29} if } forall ] def
        } if
        /out in length 8 mul string def
        0 1 in length 1 sub {
            /k exch def
            in k get cvi 8 tobin
            out k 8 mul 3 -1 roll putinterval
        } for
        out
    } def

    /encK {
        /in exch def
        /out in length 2 idiv 13 mul string def
        /k 0 def /m 0 def {
            k in length eq {exit} if
            in k get 256 mul in k 1 add get add
            dup 16#E040 lt {16#8140} {16#C140} ifelse sub
            dup -8 bitshift 16#C0 mul exch 16#00FF and add
            13 tobin dup out exch m exch putinterval
            length m add /m exch def
            /k k 2 add def
        } loop
        out
    } def

    /encE {
        0 get neg 1000000 sub
            dup 000127 le {  % ECI 000000 - 000127
            8 tobin
        } { dup 016383 le {  % ECI 000128 - 016383
                2#1000000000000000 add 16 tobin
        } {                  % ECI 016384 - 999999
                2#110000000000000000000000 add 24 tobin
        } ifelse } ifelse
    } def

    /addtobits {
        dup bits j 3 -1 roll putinterval
        length j add /j exch def
    } def

    /numNs [ msglen {0} repeat 0 ] def
    /numAs [ msglen {0} repeat 0 ] def
    /numAorNs [ msglen {0} repeat 0 ] def
    /numBs [ msglen {0} repeat 0 ] def
    /numKs [ msglen {0} repeat 0 ] def
    /nextNs [ msglen {0} repeat 9999 ] def
    /nextBs [ msglen {0} repeat 9999 ] def
    /nextAs [ msglen {0} repeat 9999 ] def
    /nextKs [ msglen {0} repeat 9999 ] def
    /isECI msglen array def
    msglen 1 sub -1 0 {
        /i exch def
        /barchar msg i get def
        //qrcode.Kexcl barchar known suppresskanjimode not and {
            i 1 add msglen lt { barchar 256 mul msg i 1 add get add } { 0 } ifelse
            dup                                               % Double byte:
            dup dup 16#8140 ge exch 16#9FFC le and exch       % 8140-9FFC or
                dup 16#E040 ge exch 16#EBBF le and or exch    % E040-EBBF
            16#FF and                                         % Low byte:
            dup dup 16#40 ge exch 16#FC le and exch 16#7F ne  % 40-FC except !7F
            and and {
                nextKs i 0 put
                numKs i numKs i 2 add get 1 add put
            } {
                nextKs i nextKs i 1 add get 1 add put
            } ifelse
        } {
            nextKs i nextKs i 1 add get 1 add put
        } ifelse
        //qrcode.Nexcl barchar known {
            nextNs i 0 put
            numNs i numNs i 1 add get 1 add put
            numAorNs i numAorNs i 1 add get 1 add put
        } {
            nextNs i nextNs i 1 add get 1 add put
        } ifelse
        //qrcode.Aexcl barchar known {
            nextAs i 0 put
            numAs i numAs i 1 add get 1 add put
            numAorNs i numAorNs i 1 add get 1 add put
        } {
            nextAs i nextAs i 1 add get 1 add put
        } ifelse
        isECI i barchar -1000000 le put
    } for
    0 1 msglen 1 sub {  % Scan forward to set any "2nd byte 1st byte" Kanji matches to zero
        /i exch def
        numKs i get 0 gt {
            numKs i 1 add 0 put
            nextKs i 1 add nextKs i 1 add get 1 add put
        } if
    } for
    msglen 1 sub -1 0 {  % Finally scan backwards again to set numBs/nextBs from "not others"
        /i exch def
        numNs i get numAs i get numKs i get add add 0 eq isECI i get not and {
            nextBs i 0 put
            numBs i numBs i 1 add get 1 add put
        } {
            nextBs i nextBs i 1 add get 1 add put
        } ifelse
    } for

    /KbeforeB {numK exch ver get ge nextBs numK 2 mul i add get 0 eq and} def
    /KbeforeA {numK exch ver get ge nextAs numK 2 mul i add get 0 eq and} def
    /KbeforeN {numK exch ver get ge nextNs numK 2 mul i add get 0 eq and} def
    /KbeforeE {numK exch ver get ge numK 2 mul i add msglen eq and} def
    /AbeforeK {numA exch ver get ge nextKs numA i add get 0 eq and} def
    /AbeforeB {numA exch ver get ge nextBs numA i add get 0 eq and} def
    /AbeforeN {numA exch ver get ge nextNs numA i add get 0 eq and} def
    /AbeforeE {numA exch ver get ge numA i add msglen eq and} def
    /NbeforeK {numN exch ver get ge nextKs numN i add get 0 eq and} def
    /NbeforeB {numN exch ver get ge nextBs numN i add get 0 eq and} def
    /NbeforeA {numN exch ver get ge nextAs numN i add get 0 eq and} def
    /NbeforeE {numN exch ver get ge numN i add msglen eq and} def
    /AorNbeforeB {numAorN exch ver get ge nextBs numAorN i add get 0 eq and} def
    /AorNbeforeE {numAorN exch ver get ge numAorN i add msglen eq and} def

    /nextNslt { nextNs i get msglen ge { pop true } { numNs nextNs i get i add get exch ver get lt } ifelse } def

    %
    % Determine which groups we need to encode
    %
    % Elements of the encoded message have differing lengths based on the
    % resulting symbol size. The symbol sizes with different element lengths
    % are batched into vergrps. To pick the smallest symbol that holds our
    % content we encode the message according to each available vergrp, based
    % on the format of symbol.
    %
    version (unset) ne {
        % A specific version of symbol is given so encode in just the corresponding vergrp
        //qrcode.versetmap format get version 2 copy known not {
            pop pop
            format (full) eq {
                /bwipp.qrcodeInvalidFullVersion (Valid versions for QR Code symbols are 1 to 40) //raiseerror exec
            } {
            format (micro) eq {
                /bwipp.qrcodeInvalidMicroVersion (Valid versions for Micro QR Code symbols are M1 to M4) //raiseerror exec
            } {  % rmqr
                /bwipp.qrcodeInvalidRMQRversion (Invalid version for an RMQR symbol) //raiseerror exec
            } ifelse } ifelse
        } if
        get [ exch ] /verset exch def
    } {
        % Just the format is specified so encode in each vergrp for the type of symbol
        format (full)  eq { /verset //qrcode.versetfull  def } if
        format (micro) eq { /verset //qrcode.versetmicro def } if
        % rMQR symbols are accessed with an explicit version
    } ifelse

    %
    % Encode unterminated bitstream for each compatible vergrp separately
    %
    /msgbits [ 39 {-1} repeat ] def

    verset {
        /ver exch def

        % Derive optimal sequence
        /mode -1 def /seq [] def /i 0 def {
            i msglen ge {exit} if
            /numK numKs i get def
            /numB numBs i get def
            /numA numAs i get def
            /numN numNs i get def
            /numAorN numAorNs i get def
            /eci isECI i get def
            ver //qrcode.vM1 eq numA 1 ge and {/seq -1 def exit} if
            ver //qrcode.vM1 eq numB 1 ge and {/seq -1 def exit} if
            ver //qrcode.vM1 eq numK 1 ge and {/seq -1 def exit} if
            ver //qrcode.vM1 eq eci and       {/seq -1 def exit} if
            ver //qrcode.vM2 eq numB 1 ge and {/seq -1 def exit} if
            ver //qrcode.vM2 eq numK 1 ge and {/seq -1 def exit} if
            ver //qrcode.vM2 eq eci and       {/seq -1 def exit} if
            ver //qrcode.vM3 eq eci and       {/seq -1 def exit} if
            ver //qrcode.vM4 eq eci and       {/seq -1 def exit} if
            {  % common exit
                eci {
                    //qrcode.E exit
                } if
                mode -1 eq {  % Set initial mode (or mode after ECI)
                    //qrcode.mode0forceKB  KbeforeA {//qrcode.K exit} if
                    //qrcode.mode0forceKB  KbeforeN {//qrcode.K exit} if
                    //qrcode.modeBKbeforeE KbeforeB {//qrcode.K exit} if  % Re-using modeB KbeforeE array
                    //qrcode.mode0forceKB  KbeforeE {//qrcode.K exit} if
                    numK 1 ge {//qrcode.B exit} if
                    //qrcode.mode0NbeforeB NbeforeK {//qrcode.N exit} if
                    //qrcode.mode0NbeforeB NbeforeB {//qrcode.N exit} if
                    //qrcode.mode0forceKB  NbeforeB {//qrcode.B exit} if
                    //qrcode.modeANbeforeE NbeforeA {//qrcode.N exit} if  % Re-using modeA NbeforeE array
                    //qrcode.mode0forceN   NbeforeE {//qrcode.N exit} if
                    //qrcode.modeBAbeforeE AbeforeK {//qrcode.A exit} if  % Re-using modeB AbeforeE array
                    //qrcode.modeBAbeforeE AorNbeforeB {//qrcode.A exit} if  % Re-using modeB AbeforeE array
                    //qrcode.mode0forceA   AorNbeforeE {//qrcode.A exit} if
                    //qrcode.B exit
                } if
                mode //qrcode.B eq {
                    //qrcode.modeBKbeforeB KbeforeB {//qrcode.K exit} if
                    //qrcode.modeBKbeforeA KbeforeA {//qrcode.K exit} if
                    //qrcode.modeBKbeforeN KbeforeN {//qrcode.K exit} if
                    //qrcode.modeBKbeforeE KbeforeE {//qrcode.K exit} if
                    //qrcode.modeBAbeforeK AbeforeK {//qrcode.A exit} if
                    //qrcode.modeBAbeforeB AbeforeB {//qrcode.A exit} if
                    //qrcode.modeBAbeforeN AbeforeN {//qrcode.A exit} if
                    //qrcode.modeBAbeforeE AbeforeE {//qrcode.A exit} if
                    //qrcode.modeBNbeforeK NbeforeK {//qrcode.N exit} if
                    //qrcode.modeBNbeforeB NbeforeB {//qrcode.N exit} if
                    //qrcode.modeBNbeforeA NbeforeA {//qrcode.N exit} if
                    //qrcode.modeBNbeforeE NbeforeE {//qrcode.N exit} if
                    //qrcode.modeBAbeforeE AorNbeforeE numAorN //qrcode.modeBAbeforeN ver get le and {  % If A/N sequence at end and short
                        //qrcode.modeBNbeforeA nextNslt {//qrcode.A exit} if  % And next N sequence shorter than NbeforeA
                    } if
                    //qrcode.B exit
                } if
                mode //qrcode.A eq {
                    numK 1 ge {//qrcode.K exit} if
                    numB 1 ge {//qrcode.B exit} if
                    //qrcode.modeANbeforeA NbeforeA {//qrcode.N exit} if
                    //qrcode.modeANbeforeB NbeforeB {//qrcode.N exit} if
                    //qrcode.modeANbeforeE NbeforeE {//qrcode.N exit} if
                    numA 1 ge numN 1 ge or {//qrcode.A exit} if
                    //qrcode.B exit
                } if
                mode //qrcode.N eq {
                    numK 1 ge {//qrcode.K exit} if
                    numB 1 ge {//qrcode.B exit} if
                    numA 1 ge {//qrcode.A exit} if
                    numN 1 ge {//qrcode.N exit} if
                    //qrcode.B exit
                } if
                mode //qrcode.K eq {
                    numB 1 ge {//qrcode.B exit} if
                    numA 1 ge {//qrcode.A exit} if
                    numN 1 ge {//qrcode.N exit} if
                    numK 1 ge {//qrcode.K exit} if
                    //qrcode.B exit
                } if
            } loop
            dup //qrcode.K eq fnc1first and {pop //qrcode.B} if  % No kanji with fnc1first
            dup mode eq {  % Same mode encode directly
                pop
                /dat msg i mode //qrcode.K eq {2} {1} ifelse getinterval def
                /seq [
                    seq aload pop
                    [ exch aload pop dat aload pop ]
                ] def
            } {  % Change mode
                /mode exch def
                mode //qrcode.K eq {//qrcode.K msg i numK 2 mul getinterval} if
                mode //qrcode.B eq {//qrcode.B msg i numB getinterval} if
                mode //qrcode.A eq {//qrcode.A msg i numA getinterval} if
                mode //qrcode.N eq {//qrcode.N msg i numN getinterval} if
                mode //qrcode.E eq {//qrcode.E msg i 1 getinterval  /mode -1 def} if
                /dat exch def /sw exch def
                /seq [ seq aload pop sw dat ] def
            } ifelse
            /i i dat length add def
        } loop

        %
        % Encode the sequence
        %
        {  % common exit
            seq -1 eq {exit} if  % Sequence not available
            /bits 23648 string def
            /j 0 def
            fnc1first {
                ver //qrcode.vR7x43 lt { (0101) } { (101) } ifelse addtobits
            } if
            /abort false def
            0 2 seq length 1 sub {
                /i exch def
                /mode seq i get def
                //qrcode.mids ver get mode get addtobits
                /chars seq i 1 add get def
                /charslen chars length mode //qrcode.K eq {2 idiv} if def
                mode //qrcode.E ne {
                    /cclen //qrcode.cclens ver get mode get def
                    charslen 2 cclen exp cvi ge {  % Too many characters for cc indicator
                        /abort true def exit
                    } if
                    charslen cclen tobin addtobits
                } if
                chars //qrcode.encfuncs mode get load exec addtobits
            } for
            abort {exit} if
            /bits bits 0 j getinterval def
            msgbits ver bits put
            exit
        } loop
    } forall

    %
    % Lookup the most appropriate symbol specification
    %
    /eclval (LMQH) eclevel search pop length exch pop exch pop def
    0 1 //qrcode.metrics length 1 sub {
        /i exch def
        /m //qrcode.metrics i get def
        /frmt m 0 get def                             % Format of the symbol
        /vers m 1 get def                             % Version of symbol
        /vergrp m 2 get def                           % Version group
        /verind i 44 sub def                          % Version indicator for rMQR format info
        /rows m 3 get def                             % Length of side
        /cols m 4 get def                             % Length of side
        /asp2 m 5 get def                             % Position of second alignment symbol
        /asp3 m 6 get def                             % Position of third alignment symbol
        /nmod m 7 get def                             % Number of modules
        /ncws nmod 8 idiv def                         % Total number of codewords
        /rbit nmod 8 mod def                          % Number of remainder bits
        /lc4b false def                               % Last data codeword is 4 bits long
        vers (M1) eq vers (M3) eq or {                % Adjustments for M1 and M3 symbols
            /ncws ncws 1 add def
            /rbit 0 def
            /lc4b true def
        } if
        /ecws m 8 get eclval get def                  % Number of error correction codewords
        /dcws ncws ecws sub def                       % Number of data codewords
        /dmod dcws 8 mul lc4b {4} {0} ifelse sub def  % Number of data modules
        /ecb1 m 9 get eclval 2 mul get def            % First error correction blocks
        /ecb2 m 9 get eclval 2 mul 1 add get def      % Second error correction blocks
        /okay true def
        format frmt ne {/okay false def} if           % The format must match that supplied
        frmt (micro) eq fnc1first and {/okay false def} if  % FNC1 mode is only available in full and rmqr
        version (unset) ne version vers ne and {/okay false def} if  % The version must match that supplied
        ecb1 -1 eq ecb2 -1 eq or {/okay false def} if % Error correction level must be valid
        /verbits msgbits vergrp get def
        verbits -1 eq {                               % Bitstream must be available
            /okay false def
        } {
            verbits length dmod gt {/okay false def} if  % and fit into data modules
        } ifelse
        /term (000000000) 0 //qrcode.termlens vergrp get getinterval def
        okay {exit} if
    } for

    okay not {
        /bwipp.qrcodeNoValidSymbol (Maximum length exceeded or invalid content) //raiseerror exec
    } if

    /format frmt def
    /version vers def
    /msgbits verbits def

    %
    % Opportunistically raise the error level if a better fit to the matrix is possible
    %
    fixedeclevel not {
        eclval 1 add 1 3 {
            /eclval_ exch def
            /ecws_ m 8 get eclval_ get def                  % Number of error correction codewords
            /dcws_ ncws ecws_ sub def                       % Number of data codewords
            /dmod_ dcws_ 8 mul lc4b {4} {0} ifelse sub def  % Number of data modules
            /ecb1_ m 9 get eclval_ 2 mul get def            % First error correction blocks
            /ecb2_ m 9 get eclval_ 2 mul 1 add get def      % Second error correction blocks
            /okay true def
            ecb1_ -1 eq ecb2_ -1 eq or {/okay false def} if % Error correction level must be valid
            msgbits length dmod_ gt {/okay false def} if    % and fit into data modules
            okay {
                /eclval eclval_ def
                /dcws dcws_ def
                /dmod dmod_ def
                /ecb1 ecb1_ def
                /ecb2 ecb2_ def
            } if
        } for
    } if

    /dcpb dcws ecb1 ecb2 add idiv def                 % Base data codewords per block
    /ecpb ncws ecb1 ecb2 add idiv dcpb sub def        % Error correction codewords per block

    %
    % Complete the message bits by adding the terminator, truncated if necessary
    %
    /term term 0 dmod msgbits length sub term length 2 copy gt {exch} if pop getinterval def
    msgbits length term length add string
    dup 0 msgbits putinterval
    dup msgbits length term putinterval
    /msgbits exch def

    %
    % Expand the message bits by adding padding as necessary
    %
    /pad dmod string def
    0 1 pad length 1 sub {pad exch 48 put} for
    pad 0 msgbits putinterval
    /padnum 0 def
    msgbits length 8 div ceiling 8 mul cvi 8 dmod lc4b {5} {1} ifelse sub {
        pad exch //qrcode.padstrs padnum get putinterval
        /padnum padnum 1 add 2 mod def
    } for

    %
    % Evaluate the padded message into codewords
    %
    /cws dcws array def
    0 1 cws length 1 sub {
        /c exch def
        /bpcw 8 def
        lc4b c cws length 1 sub eq and {/bpcw 4 def} if
        /cwb pad c 8 mul bpcw getinterval def
        /cw 0 def
        0 1 bpcw 1 sub {
            /i exch def
            /cw cw 2 bpcw i sub 1 sub exp cvi cwb i get 48 sub mul add def
        } for
        cws c cw put
    } for

    %
    % Short final data byte in M1 and M3 symbols has high-order value
    %
    lc4b {cws cws length 1 sub 2 copy get 4 bitshift put} if

    options /debugcws known { /bwipp.debugcws cws //raiseerror exec } if

    /rsprod {
        2 copy 0 ne exch 0 ne and {
            rslog exch get exch rslog exch get add 255 mod rsalog exch get
        } {
            pop pop 0
        } ifelse
    } def

    %
    % Generate the coefficients for the Reed-Solomon algorithm
    %
    /coeffs [ 1 ecpb {0} repeat ] def
    0 1 ecpb 1 sub {
        /i exch def
        /ai rsalog i get def
        coeffs i 1 add coeffs i get put
        i -1 1 {
            /j exch def
            coeffs j coeffs j 1 sub get coeffs j get ai rsprod xor put
        } for
        coeffs 0 coeffs 0 get ai rsprod put
    } for
    /coeffs coeffs 0 coeffs length 1 sub getinterval def

    %
    % Reed-Solomon algorithm to derive the error correction codewords
    %
    /rscodes {
        /rscws exch def
        /rsnd rscws length def
        /rscws [ rscws aload pop ecpb {0} repeat ] def
        0 1 rsnd 1 sub {
            /m exch def
            /k rscws m get def
            0 1 ecpb 1 sub {
                /j exch def
                rscws m j add 1 add coeffs ecpb j sub 1 sub get k rsprod rscws m j add 1 add get xor put
            } for
        } for
        rscws rsnd ecpb getinterval
    } def

    %
    % Divide codewords into two groups of blocks and calculate the error correction codewords
    %
    /dcwsb ecb1 ecb2 add array def
    /ecwsb ecb1 ecb2 add array def
    0 1 ecb1 1 sub {  % First group of blocks has smaller number of data codewords
        /i exch def
        dcwsb i cws i dcpb mul dcpb getinterval put
        ecwsb i dcwsb i get rscodes put
    } for
    0 1 ecb2 1 sub {  % Second group of blocks has larger number of data codewords
        /i exch def
        dcwsb ecb1 i add cws ecb1 dcpb mul i dcpb 1 add mul add dcpb 1 add getinterval put
        ecwsb ecb1 i add dcwsb ecb1 i add get rscodes put
    } for

    %
    % Reassemble the codewords
    %
    /cws ncws array def
    /cw 0 def
    0 1 dcpb {  % Interleave the data codeword blocks
        /i exch def
        0 1 ecb1 ecb2 add 1 sub {
            /j exch def
            i dcwsb j get length lt {  % Ignore the end of short blocks
                cws cw dcwsb j get i get put
                /cw cw 1 add def
            } if
        } for
    } for
    0 1 ecpb 1 sub {  % Interleave the error codeword blocks
        /i exch def
        0 1 ecb1 ecb2 add 1 sub {
            /j exch def
            cws cw ecwsb j get i get put
            /cw cw 1 add def
        } for
    } for

    %
    % Extend codewords by one if there are remainder bits
    %
    rbit 0 gt {
        /pad cws length 1 add array def
        pad 0 cws putinterval
        pad pad length 1 sub 0 put
        /cws pad def
    } if

    %
    % Fixups for the short final data byte in M1 and M3 symbols
    %
    lc4b {
        cws dcws 1 sub 2 copy get -4 bitshift put
        dcws 1 sub 1 ncws 2 sub {
            /i exch def
            cws i cws i get 15 and 4 bitshift put
            cws i cws i 1 add get -4 bitshift 15 and cws i get or put
        } for
        cws ncws 1 sub cws ncws 1 sub get 15 and 4 bitshift put
    } if

    options /debugecc known { /bwipp.debugecc cws //raiseerror exec } if

    %
    % Create the bitmap
    %
    /pixs [ rows cols mul {-1} repeat ] def
    /qmv {cols mul add} def

    %
    % Timing patterns
    %
    format (full) eq {
        8 1 cols 9 sub {
            /i exch def
            pixs i 6 qmv i 1 add 2 mod put
            pixs 6 i qmv i 1 add 2 mod put
        } for
    } if
    format (micro) eq {
        8 1 cols 1 sub {
            /i exch def
            pixs i 0 qmv i 1 add 2 mod put
            pixs 0 i qmv i 1 add 2 mod put
        } for
    } if
    format (rmqr) eq {
        3 1 cols 4 sub {  % Along top and bottom
            /i exch def
            pixs i 0 qmv i 1 add 2 mod put
            pixs i rows 1 sub qmv i 1 add 2 mod put
        } for
        3 1 rows 4 sub {  % Along left and right
            /i exch def
            pixs 0 i qmv i 1 add 2 mod put
            pixs cols 1 sub i qmv i 1 add 2 mod put
        } for
        asp2 1 sub asp3 asp2 sub cols 13 sub {  % Down interior
            /i exch def
            3 1 rows 4 sub {
                /j exch def
                pixs i j qmv j 1 add 2 mod put
            } for
        } for
    } if

    %
    % Place finder patterns
    %
    /fpats //qrcode.fpatmap format get def
    0 1 7 {
      /y exch def
      0 1 7 {
        /x exch def
        /fpb0 fpats 0 get y get x get def
        /fpb1 fpats 1 get y get x get def
        /fpb2 fpats 2 get y get x get def
        /fpb3 fpats 3 get y get x get def
        fpb0 9 ne y rows lt and {pixs x y qmv fpb0 put} if
        fpb1 9 ne {pixs cols x sub 1 sub y qmv fpb1 put} if
        fpb2 9 ne {pixs x rows y sub 1 sub qmv fpb2 put} if
        fpb3 9 ne {pixs cols x sub 1 sub rows y sub 1 sub qmv fpb3 put} if
      } for
    } for

    /putalgnpat {
        /py exch def
        /px exch def
        0 1 4 {
            /pb exch def
            0 1 4 {
                /pa exch def
                /algnb algnpat pb get pa get def
                algnb 9 ne {
                    pixs px pa add py pb add qmv algnb put
                } if
            } for
        } for
    } def

    %
    % Place alignment patterns
    %
    format (full) eq {
        /algnpat //qrcode.algnpatfull def
        asp2 2 sub asp3 asp2 sub cols 13 sub {
            /i exch def
            i 4 putalgnpat
            4 i putalgnpat
        } for
        asp2 2 sub asp3 asp2 sub cols 9 sub {
            /x exch def
            asp2 2 sub asp3 asp2 sub rows 9 sub {
                /y exch def
                x y putalgnpat
            } for
        } for
    } if
    format (rmqr) eq {
        /algnpat //qrcode.algnpatrmqr def
        asp2 2 sub asp3 asp2 sub cols 13 sub {
            /i exch def
            i 0 putalgnpat
            i rows 3 sub putalgnpat
        } for
    } if

    %
    % Derive the format information module map
    %
    /formatmap [
        //qrcode.formatfimmap format get {
            [ exch { rows exch cols exch exec 2 array astore } forall ]
        } forall
    ] def

    %
    % Reserve the format information modules
    %
    formatmap {
        { aload pop qmv pixs exch 1 put } forall
    } forall

    %
    % Derive the version information module map
    %
    format (full) eq cols 45 ge and {
        /versionmap [
            //qrcode.vimmap {
                [ exch { cols exch exec 2 array astore } forall ]
            } forall
        ] def
    } {
        /versionmap [] def
    } ifelse

    %
    % Reserve the version information modules
    %
    versionmap {
        { aload pop qmv pixs exch 0 put } forall
    } forall

    %
    % Reserve the solitary dark module in full symbols
    %
    format (full) eq {
        pixs 8 rows 8 sub qmv 0 put
    } if

    %
    % Lookup the mask bits corresponding to the mask functions applicable to
    % this format
    %
    mask -1 eq {
        /maskbits //qrcode.formatmaskbits format get def
    } {  % Just the indicated function when given a user-specified mask
        /maskbits [ //qrcode.formatmaskbits format get mask 1 sub get ] def
        /bestmaskval mask 1 sub def
    } ifelse
    /nmasks maskbits length def

    %
    % Build masklayers from the extruded funcpatlayers, with function cell
    % values included (as 0 or 255)
    %
    /masklayers rows cols mul array def
    0 1 rows 1 sub {
        /j exch def
        0 1 cols 1 sub {
            /i exch def
            /pos i j qmv def
            masklayers pos pixs pos get dup -1 eq {
                pop funcpatlayers j 6 mul 72 mod i 6 mod add get
            } {
                255 mul
            } ifelse put
        } for
    } for

    %
    % Walk the symbol placing the bitstream by merging it into masklayers
    %
    /posx cols format (rmqr) ne {1} {2} ifelse sub def
    /posy rows 1 sub def
    /dir -1 def  % -1 is upwards, 1 is downwards
    /col 1 def   % 0 is left bit, 1 is right bit
    /num 0 def
    { % loop
        posx 0 lt {exit} if
        /pos posx posy qmv def
        pixs pos get -1 eq {
            /bit cws num 8 idiv get 7 num 8 mod sub neg bitshift 1 and def
            masklayers pos masklayers pos get bit 255 mul xor put
            /num num 1 add def
        } if
        col 1 eq {
            /col 0 def
            /posx posx 1 sub def
        } {
            /col 1 def
            /posx posx 1 add def
            /posy posy dir add def
            posy 0 lt posy rows ge or {  % Turn around at top and bottom
                /dir dir -1 mul def
                /posy posy dir add def
                /posx posx 2 sub def
                % Hop over the timing pattern in full size symbols
                format (full) eq posx 6 eq and {/posx posx 1 sub def} if
            } if
        } ifelse
    } loop

    %
    % Evaluate runlength encoded rows or columns in full symbols
    %
    /evalfulln1n3 {
        /scrle exch def
        % Detect runs of 5 or more like modules
        /scr1 0 scrle { dup 5 ge {add 2 sub dup} if pop } forall def
        % Detect 1:1:3:1:1 ratio next to 4 modules of whitespace
        /scr3 0 def
        3 2 scrle length 3 sub {  % Scan odd (dark) runs within bounds
            /j exch def
            scrle j get 3 mod 0 eq {  % Multiple of 3 black modules
                /fact scrle j get 3 idiv def
                scrle j 2 sub 5 getinterval {fact eq} forall and exch pop and and {
                    j 3 eq j 4 add scrle length ge or {  % At either extent of run
                        /scr3 scr3 40 add def
                    } {  % Bounded by dark modules
                        scrle j 3 sub get 4 ge scrle j 3 add get 4 ge or {
                            /scr3 scr3 40 add def
                        } if
                    } ifelse
                } if
            } if
        } for
        scr1 scr3
    } def

    %
    % Evaluation algorithm for full symbols
    %
    /evalfull {
        /sym exch def

        /n1 0 def /n2 0 def /n3 0 def
        /rle cols 1 add array def
        /lastpairs cols array def
        /thispairs cols array def
        /colsadd1 cols 1 add def
        0 1 cols 1 sub {
            /i exch def

            % Runlength encode (light, dark, light, ...) and evaluate each column
            mark 0 0
            i cols dup dup mul 1 sub {
                sym exch get exch 1 index eq {exch 1 add exch} {1 exch} ifelse
            } for
            pop
            rle 0 counttomark 2 sub getinterval astore
            evalfulln1n3 n3 add /n3 exch def n1 add /n1 exch def
            pop

            % Runlength encode (light, dark, light, ...) and evaluate each row
            /symrow sym i cols mul cols getinterval def
            mark 0 0
            symrow {
                exch 1 index eq {exch 1 add exch} {1 exch} ifelse
            } forall
            pop
            rle 0 counttomark 2 sub getinterval astore
            evalfulln1n3 n3 add /n3 exch def n1 add /n1 exch def
            pop

            % Count and score same coloured blocks
            /lastpairs thispairs /thispairs lastpairs def def
            symrow 0 get 1 eq {0} {1} ifelse
            symrow {exch 1 index add exch} forall
            pop
            thispairs astore pop
            i 0 gt {
                mark
                lastpairs aload pop thispairs aload pop
                n2 cols { exch colsadd1 index add 3 and 0 eq {3 add} if } repeat
                /n2 exch def
                cleartomark
            } if

        } for

        % Score dark/light imbalance
        /dark 0 sym {add} forall def
        /n4 dark 100 mul cols dup mul div 50 sub abs 5 div cvi 10 mul def

        n1 n2 add n3 add n4 add
    } def

    %
    % Evaluation algorithm for micro symbols
    %
    /evalmicro {
        /sym exch def
        /dkrhs 0 def /dkbot 0 def
        1 1 cols 1 sub {
            /i exch def
            /dkrhs dkrhs sym cols 1 sub i qmv get add def
            /dkbot dkbot sym i cols 1 sub qmv get add def
        } for
        dkrhs dkbot le {
            dkrhs 16 mul dkbot add neg
        } {
            dkbot 16 mul dkrhs add neg
        } ifelse
    } def

    %
    % Extract each masked symbol from the required set and evaluate them to
    % find the most suitable
    %
    /bestscore 999999999 def
    0 1 nmasks 1 sub {
        /m exch def
        /maskbit maskbits m get def
        /masksym rows cols mul array def
        0 1 rows cols mul 1 sub {
            /i exch def
            masksym i masklayers i get maskbit neg bitshift 1 and put
        } for
        nmasks 1 ne {  % Not rMQR nor user-specified mask
            /score masksym format (full) eq {evalfull} {evalmicro} ifelse def
            score bestscore lt {
                /bestsym masksym def
                /bestmaskval m def
                /bestscore score def
            } if
        } {
            /bestsym masksym def
            % Note: bestmaskval never set for rMQR, but is not required
        } ifelse
    } for
    /pixs bestsym def

    %
    % Set the solitary dark module in full symbols
    %
    format (full) eq {
        pixs 8 cols 8 sub qmv 1 put
    } if

    %
    % Add the format information
    %
    format (full) eq {
        /ecid //qrcode.ecidfull eclval get def
        /fmtval //qrcode.fmtvalsfull ecid 3 bitshift bestmaskval add get def
        0 1 formatmap length 1 sub {
            /i exch def
            formatmap i get {
                pixs exch aload pop qmv fmtval 14 i sub neg bitshift 1 and put
            } forall
        } for
    } if
    format (micro) eq {
        /symid //qrcode.ecidmicrosym cols 11 sub 2 idiv get eclval get def
        /fmtval //qrcode.fmtvalsmicro symid 2 bitshift bestmaskval add get def
        0 1 formatmap length 1 sub {
            /i exch def
            pixs formatmap i get 0 get aload pop qmv fmtval 14 i sub neg bitshift 1 and put
        } for
    } if
    format (rmqr) eq {
        /fmtvalu //qrcode.ecidrmqr eclval get 5 bitshift verind add def
        /fmtval1 //qrcode.fmtvalsrmqr1 fmtvalu get def
        /fmtval2 //qrcode.fmtvalsrmqr2 fmtvalu get def
        0 1 formatmap length 1 sub {
            /i exch def
            pixs formatmap i get 0 get aload pop qmv fmtval1 17 i sub neg bitshift 1 and put
            pixs formatmap i get 1 get aload pop qmv fmtval2 17 i sub neg bitshift 1 and put
        } for
    } if

    %
    % Add the version information
    %
    format (full) eq cols 45 ge and {
        /verval //qrcode.vervals cols 17 sub 4 idiv 7 sub get def
        0 1 versionmap length 1 sub {
            /i exch def
            versionmap i get {
                pixs exch aload pop qmv verval 17 i sub neg bitshift 1 and put
            } forall
        } for
    } if

    %
    % Return the arguments
    %
    <<
    /ren /renmatrix
    /pixs pixs
    /pixx cols
    /pixy rows
    /height rows 2 mul 72 div
    /width cols 2 mul 72 div
    /borderleft format (full) eq {4.0} {2.0} ifelse
    /borderright format (full) eq {4.0} {2.0} ifelse
    /bordertop format (full) eq {4.0} {2.0} ifelse
    /borderbottom format (full) eq {4.0} {2.0} ifelse
    /opt options
    >>

    dontdraw not //renmatrix if

    end

}
[/barcode] {null def} forall
bind def
/qrcode dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
setglobal
% --END ENCODER qrcode--
