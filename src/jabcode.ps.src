% Barcode Writer in Pure PostScript
% https://bwipp.terryburton.co.uk
%
% Copyright (c) 2004-2024 Terry Burton
%
% $Id$
%
% Permission is hereby granted, free of charge, to any
% person obtaining a copy of this software and associated
% documentation files (the "Software"), to deal in the
% Software without restriction, including without
% limitation the rights to use, copy, modify, merge,
% publish, distribute, sublicense, and/or sell copies of
% the Software, and to permit persons to whom the Software
% is furnished to do so, subject to the following
% conditions:
%
% The above copyright notice and this permission notice
% shall be included in all copies or substantial portions
% of the Software.
%
% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY
% KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
% THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
% PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
% THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
% DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
% CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
% CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
% IN THE SOFTWARE.

% --BEGIN ENCODER jabcode--
% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput renmatrix--
% --DESC: JAB Code (Beta)
% --EXAM: This is JAB Code
% --EXOP: eclevel=6
% --RNDR: renmatrix
/setpacking where {pop currentpacking true setpacking} if
10 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /processoptions dup /uk.co.terryburton.bwipp findresource put
dup /parseinput dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/jabcode {

    20 dict begin

    /ctx null def
    /dontdraw false def
    /rows -1 def
    /columns -1 def
    /slave false def
    /colors 16 def
    /eclevel 6 def  % 0-10
    /raw false def
    /parse false def
    /parsefnc false def
    /mask -1 def    % 0-7

    //processoptions exec /options exch def
    /barcode exch def

    /databpm colors ln 2 ln div round cvi def
    /metabpm colors dup 8 gt {pop 8} if ln 2 ln div round cvi def

     % Parse the input
    /fn1 -1 def
    /fncvals <<
        /parse parse
        /parsefnc parsefnc
        (FNC1) fn1
    >> def
    /msg barcode fncvals //parseinput exec def
    /msglen msg length def

    % Wide array support, as needed
    {65536 array} stopped {
        pop
        /arrayw {
            dup 65535 idiv 1 add dup array exch 0 exch 1 sub {2 copy 65535 array put 1 add} repeat
            1 index 4 1 roll 3 -1 roll 65535 mod array put
        } def
        /getw  {exch 1 index 65535 idiv get exch 65535 mod get} def
        /putw  {3 1 roll exch 1 index 65535 idiv get exch 65535 mod 3 -1 roll put} def
        /copyw {exch 0 exch {dup length array copy 3 copy put pop 1 add} forall pop} def
    } {
        pop
        /arrayw {array} def
        /getw   {get}   def
        /putw   {put}   def
        /copyw  {copy}  def
    } ifelse

    /addtobits {
        dup bits j 3 -1 roll putinterval
        length j add /j exch def
    } def

    /tofixedbits {  % Zero padded base 2 string
        (0000000000000) 13 string copy dup 4 -1 roll 2 13 string cvrs
        dup length 4 index exch sub exch putinterval
        0 3 -1 roll getinterval
    } def

    % Encode the data using byte mode encoding and terminate with EOM
    /bits 7 msglen 15 le {4} {17} ifelse add msglen 8 mul add 12 add string def
    /j 0 def
    31 5 tofixedbits addtobits  % MS
    (00) addtobits              % S/B
    msglen 15 le {
        msglen 4 tofixedbits addtobits
    } {
        (0000) addtobits
        msglen 16 sub 13 tofixedbits addtobits
    } ifelse
    0 1 msglen 1 sub {
        msg exch get 8 tofixedbits addtobits
    } for
    28 5 tofixedbits addtobits  % L/L
    31 5 tofixedbits addtobits  % MS
    (11) addtobits              % EOM

    % TODO Cascade
    /diffside 21 def
    /sameshape false def
    /sameecc false def
    /hasslaves false def

    % Determine the metrics for a symbol of a given size
    /metrics {
        /mc exch def  /mr exch def
        mc mr mul                                      % All modules
        mc 25 sub 16 idiv 2 add mr 25 sub 16 idiv 2 add
        mul 4 sub 7 mul                                % Alignment modules
        64 colors 2 copy gt {exch} if pop 2 mul        % Palette modules
        slave {7} {17} ifelse 4 mul                    % Finder modules

        % Metadata bits and modules
        slave not {  % Master
            /metass mr mc eq {0} {1} ifelse def
            mr mc 2 copy lt {exch} if pop
            21 sub 16 idiv [ 0 1 2 2 3 3 3 3 ] exch get  /metavf exch def
            /metavlen metass 0 eq {[2 2 3 4]} {[4 6 8 10]} ifelse metavf get def
            /metaelen metavf 2 mul 10 add def
            7                                          % II:  SS VF MSK SF
            metavlen add metaelen add                  % III: V E
            hasslaves {4 add} if                       % III: S
            2 mul                                      % LDPC
            metabpm div ceiling cvi
            dup metabpm mul 6 add /nummetabits exch def
            6 add                                      % I:   Nc into 6 modules
        } {  % Slave
            3                                          % I:   SS SE SF
            sameshape not {5 add} if                   % II:  V
            hasslaves     {3 add} if                   % II:  S
            sameecc not {
                mr mc 2 copy lt {exch} if pop
                21 sub 16 idiv [ 10 12 14 14 16 16 16 16 ] exch get
                add                                    % III: E
            } if
            2 mul                                      % LDPC
            metabpm div ceiling cvi
            dup metabpm mul /nummetabits exch def
        } ifelse

        dup              /nummetamodules exch def
        add add add sub  /numdatamodules exch def
        /numdatabits numdatamodules databpm mul def
    } def

    % Select a symbol size sufficient to carry the message
    /coderate [ 0.67 0.63 0.57 0.55 0.50 0.43 0.34 0.25 0.20 0.17 0.14 ] eclevel get def
    /grosslen bits length coderate div ceiling cvi def
    /snapsize {ceiling cvi 18 sub dup 0 lt {pop 0} if 4 idiv 4 mul 21 add} def

    rows -1 eq columns -1 eq and {        % Square if neither rows or columns fixed
        /size grosslen sqrt snapsize def
        {
            size size metrics
            grosslen numdatabits le {exit} if
            /size size 4 add def
        } loop
        /rows size def
        /columns size def
    } {
        columns -1 eq rows -1 ne and {     % Fixed height
            /columns grosslen rows div snapsize def
            {
                rows columns metrics
                grosslen numdatabits le {exit} if
                /columns columns 4 add def
            } loop
        } if
        rows -1 eq columns -1 ne and {     % Fixed width
            /rows grosslen columns div snapsize def
            {
                rows columns metrics
                grosslen numdatabits le {exit} if
                /rows rows 4 add def
            } loop
        } if
        rows -1 ne columns -1 ne and {     % Fixed height and width
            rows columns metrics
        } if
    } ifelse
    /C numdatabits def
    /cols columns def

    % TODO Reject all invalid sizes
    rows 145 gt cols 145 gt or {
        /bwipp.jabcodeNoValidSymbol (Maximum length exceeded or invalid content) //raiseerror exec
    } if

    % Pick ECC params to maximally fill symbol
    /min C def
    3 1 8 {
        /i exch def
        i 1 add 1 9 {
            /j exch def
            /dist C j idiv j mul C j idiv i mul sub bits length sub def
            dist min lt dist 0 ge and {
                /datawc i def
                /datawr j def
                /min dist def
            } if
        } for
    } for

    % Extend the encoded data to fill the required data length
    /tmpbits C datawr idiv datawr mul C datawr idiv datawc mul sub string def
    tmpbits 0 bits putinterval
    bits length 1 tmpbits length 1 sub {
        dup 1 sub tmpbits exch get dup 2 mod 0 eq {1 add} {1 sub} ifelse
        tmpbits 3 1 roll put
    } for
    /bits tmpbits def

    % Avoid 15-bit overflow when multiplying the digits by stealing from the second digit
    % m = 6364136223846793005 = 0x 5851 f42d 4c95 7f2d
    /m0 16#5851 16#1 add def  /m1 16#f42d 16#10000 sub def  /m2 16#4c95 def  /m3 16#7f2d def

    /lcg64_temper {

        % Multiply seed by 6364136223846793005 then add 1

        /p00 m0 s0 mul def  /p01 m0 s1 mul def  /p02 m0 s2 mul def  /p03 m0 s3 mul def
        /p10 m1 s0 mul def  /p11 m1 s1 mul def  /p12 m1 s2 mul def  /p13 m1 s3 mul def
        /p20 m2 s0 mul def  /p21 m2 s1 mul def  /p22 m2 s2 mul def  /p23 m2 s3 mul def
        /p30 m3 s0 mul def  /p31 m3 s1 mul def  /p32 m3 s2 mul def  /p33 m3 s3 mul def

        /s3 p33 16#10000 mod                     1 add def  % 1 added here
        /s2 p32 16#10000 mod p33 16#10000 idiv add
            p23 16#10000 mod                       add def
        /s1 p31 16#10000 mod p32 16#10000 idiv add
            p22 16#10000 mod p23 16#10000 idiv add add
            p13 16#10000 mod                       add def
        /s0 p30 16#10000 mod p31 16#10000 idiv add
            p21 16#10000 mod p22 16#10000 idiv add add
            p12 16#10000 mod p13 16#10000 idiv add add
            p03 16#10000 mod                       add def

        % Simplify carry by making each digit positive by borrowing from more significant digit
        /s3 s3 16#10000 add def
        /s2 s2 16#ffff  add def
        /s1 s1 16#ffff  add def
        /s0 s0 16#ffff  add def

        % Carry
        /s2 s3 16#10000 idiv s2 add def  /s3 s3 16#10000 mod def
        /s1 s2 16#10000 idiv s1 add def  /s2 s2 16#10000 mod def
        /s0 s1 16#10000 idiv s0 add def  /s1 s1 16#10000 mod def
                                         /s0 s0 16#10000 mod def

        % Temper most significant 32 bits
        s0 16#8000 sub 16#10000 mul s1 add 16#80000000 xor
        16#ffffffff and
        dup -11 bitshift xor
        dup   7 bitshift 16#62d3a980 neg and xor  % 0x9D2C5680 - 0x100000000
        dup  15 bitshift 16#103a0000 neg and xor  % 0xEFC60000 - 0x100000000
        16#ffffffff and
        dup -18 bitshift xor

    } def

    /createMatrixA {

        /nb_pcb wr 4 lt {Pg_sub_block 2 idiv} {Pg_sub_block wr idiv wc mul} ifelse def
        /offset Pg_sub_block 32 div ceiling cvi def
        /effwidth offset 32 mul def
        /matrixA offset nb_pcb mul arrayw def
        0 1 offset nb_pcb mul 1 sub {matrixA exch 0 putw} for
        /permutation Pg_sub_block array def
        0 1 Pg_sub_block 1 sub {permutation exch dup put} for

        0 1 Pg_sub_block wr idiv 1 sub {
            /i exch def
            0 1 wr 1 sub {
                /j exch def
                matrixA i effwidth wr add mul j add 32 idiv
                2 copy getw 1 31 i effwidth wr add mul j add 32 mod sub bitshift or putw
            } for
        } for

        % Pseudorandom permutation
        /s0 16#0000 def  /s1 16#0000 def  /s2 16#000B def  /s3 16#FC39 def  % s=785465
        1 1 wc 1 sub {
            /i exch def
            /off_index Pg_sub_block wr idiv i mul def
            0 1 Pg_sub_block 1 sub {
                /j exch def
                lcg64_temper
                dup 0 lt {16#80000000 xor 2147483648.0 add} if
                4294967296.0 div Pg_sub_block j sub mul cvi  % (float)UINT32_MAX = 65536.0 * 65536
                /pos exch def
                0 1 Pg_sub_block wr idiv 1 sub {
                    /k exch def
                    matrixA off_index k add offset mul j 32 idiv add
                    2 copy getw
                        matrixA permutation pos get 32 idiv k offset mul add getw
                        31      permutation pos get 32 mod  sub neg bitshift 1 and
                        31 j                        32 mod  sub bitshift
                    or putw
                } for
                permutation pos permutation Pg_sub_block 1 sub j sub 2 copy get permutation pos get
                exch 4 1 roll   % p b p a p[a] p[b] -> p b p[a] p a p[b]
                put put
            } for
        } for

    } def

    /createMetadataMatrixA {

        /nb_pcb Pg_sub_block 2 idiv def
        /offset Pg_sub_block 32 div ceiling cvi def
        /matrixA offset nb_pcb mul arrayw def
        0 1 offset nb_pcb mul 1 sub {matrixA exch 0 putw} for
        /permutation Pg_sub_block array def
        0 1 Pg_sub_block 1 sub {permutation exch dup put} for

        % Pseudorandom permutation
        /s0 16#0000 def  /s1 16#0000 def  /s2 16#0000 def  /s3 16#9691 def  % s=38545
        /nb_once nb_pcb wc div Pg_sub_block mul 3 add cvi nb_pcb idiv def
        0 1 nb_pcb 1 sub {
            /i exch def
            0 1 nb_once 1 sub {
                /j exch def
                lcg64_temper
                dup 0 lt {16#80000000 xor 2147483648.0 add} if
                4294967296.0 div Pg_sub_block j sub mul cvi  % (float)UINT32_MAX = 65536.0 * 65536
                /pos exch def
                matrixA i offset mul permutation pos get 32 idiv add
                2 copy getw 1 31 permutation pos get 32 mod sub bitshift or putw
                permutation pos permutation Pg_sub_block 1 sub j sub 2 copy get permutation pos get
                exch 4 1 roll   % p b p a p[a] p[b] -> p b p[a] p a p[b]
                put put
            } for
        } for

    } def

    /GaussJordan {

        /nb_pcb wr 4 lt {Pg_sub_block 2 idiv} {Pg_sub_block wr idiv wc mul} ifelse def
        /offset Pg_sub_block 32 div ceiling cvi def
        /matrixH matrixA dup length array copyw def
        /column_arrangement [ Pg_sub_block       {0}     repeat ] def
        /processed_column   [ Pg_sub_block       {false} repeat ] def
        /zero_lines_nb      [ nb_pcb             {0}     repeat ] def
        /swap_col           [ Pg_sub_block 2 mul {0}     repeat ] def
        /zero_lines 0 def

        /loop0 0 def
        0 1 nb_pcb 1 sub {
            /i exch def
            /pivot_column Pg_sub_block 1 add def
            0 1 Pg_sub_block 1 sub {
                /j exch def
                matrixH offset 32 mul i mul j add 32 idiv getw
                31 offset 32 mul i mul j add 32 mod sub neg bitshift 1 and 1 eq {
                    /pivot_column j def
                    exit
                } if
            } for
            pivot_column Pg_sub_block lt {
                processed_column   pivot_column true put
                column_arrangement pivot_column i put
                pivot_column nb_pcb ge {
                    swap_col loop0 2 mul pivot_column put
                    /loop0 loop0 1 add def
                } if
                /off_index  pivot_column 32 idiv def
                /off_index1 pivot_column 32 mod def
                0 1 nb_pcb 1 sub {
                    /j exch def
                    i j ne {
                        matrixH off_index j offset mul add getw
                        31 off_index1 sub neg bitshift 1 and 1 eq {
                            0 1 offset 1 sub {
                                /k exch def
                                matrixH offset j mul k add
                                2 copy getw matrixH offset i mul k add getw xor putw
                            } for
                        } if
                    } if
                } for
            } {
                zero_lines_nb zero_lines i put
                /zero_lines zero_lines 1 add def
            } ifelse
        } for

        /matrix_rank nb_pcb zero_lines sub def
        /loop2 0 def
        matrix_rank 1 nb_pcb 1 sub {
            /i exch def
            column_arrangement i get 0 gt {
                0 1 nb_pcb 1 sub {
                    /j exch def
                    processed_column j get not {
                        column_arrangement j column_arrangement i get put
                        column_arrangement i 0 put
                        processed_column   j true put
                        processed_column   i false put
                        swap_col loop0 2 mul       i put
                        swap_col loop0 2 mul 1 add j put
                        column_arrangement i j put
                        /loop0 loop0 1 add def
                        /loop2 loop2 1 add def
                        exit
                    } if
                } for
            } if
        } for

        /loop1 0 def
        0 1 nb_pcb 1 sub {
            /kl exch def
            processed_column kl get not loop1 loop0 loop2 sub lt and {
                column_arrangement kl column_arrangement swap_col loop1 2 mul get get put
                processed_column kl true put
                swap_col loop1 2 mul 1 add kl put
                /loop1 loop1 1 add def
            } if
        } for

        /loop1 0 def
        0 1 nb_pcb 1 sub {
            /kl exch def
            processed_column kl get not {
                column_arrangement kl zero_lines_nb loop1 get put
                /loop1 loop1 1 add def
            } if
        } for

        0 1 nb_pcb 1 sub {
            /i exch def
            0 1 offset 1 sub {
                /j exch def
                matrixH column_arrangement i get offset mul j add getw
                matrixA exch i offset mul j add exch putw
            } for
        } for

        /tmp 0 def
        0 1 loop0 1 sub {
            /i exch def
            0 1 nb_pcb 1 sub {
                /j exch def
                matrixA swap_col i 2 mul get 32 idiv j offset mul add getw
                31 swap_col i 2 mul get 32 mod sub neg bitshift 1 and neg tmp xor 1 and
                tmp xor /tmp exch def
                matrixA     swap_col i 2 mul       get 32 idiv j offset mul add
                2 copy getw
                    matrixA swap_col i 2 mul 1 add get 32 idiv j offset mul add getw
                    31      swap_col i 2 mul 1 add get 32 mod  sub neg bitshift 1 and neg
                    matrixA swap_col i 2 mul       get 32 idiv j offset mul add getw xor
                    1 31    swap_col i 2 mul       get 32 mod  sub     bitshift and
                xor putw
                matrixA swap_col i 2 mul 1 add get 32 idiv j offset mul add
                2 copy getw
                    tmp 1 and neg
                    matrixA swap_col i 2 mul 1 add get 32 idiv j offset mul add getw xor
                    1 31    swap_col i 2 mul 1 add get 32 mod  sub     bitshift and
                xor putw
            } for
        } for

    } def

    /createGeneratorMatrix {

        /pn Pg_sub_block matrix_rank sub def
        /offset pn 32 div ceiling cvi def
        /effwidth offset 32 mul def
        /offset_cap Pg_sub_block 32 div ceiling cvi def
        /G offset Pg_sub_block mul arrayw def
        0 1 offset Pg_sub_block mul 1 sub {
            G exch 0 putw
        } for
        0 1 pn 1 sub {
            /i exch def
            G Pg_sub_block pn sub i add offset mul i 32 idiv add
            2 copy getw 1 31 i 32 mod sub bitshift or putw
        } for
        /matrix_index Pg_sub_block pn sub def
        /loop0 0 def
        0 1 Pg_sub_block pn sub effwidth mul 1 sub {
            /i exch def
            matrix_index Pg_sub_block ge {
                /loop0 loop0 1 add def
                /matrix_index Pg_sub_block pn sub def
            } if
            i effwidth mod pn lt {
                G i 32 idiv
                2 copy getw
                    matrixA matrix_index 32 idiv offset_cap loop0 mul add getw
                    31      matrix_index 32 mod sub neg bitshift 1 and neg
                    G       i            32 idiv getw xor
                    1 31    i            32 mod sub     bitshift and
                xor putw
                /matrix_index matrix_index 1 add def
            } if
        } for

    } def

    /ldpc {

        /wr exch def
        /wc exch def
        [ exch {48 sub} forall ] /data exch def

        /Pn data length def
        wr -1 ne {  % Message data
            /Pg Pn wr mul wr wc sub div ceiling wr div ceiling wr mul cvi def
            /nb_sub_blocks Pg 2700 idiv 1 add def
            /Pg_sub_block  Pg nb_sub_blocks idiv wr idiv wr mul def
            /Pn_sub_block  Pg_sub_block wr wc sub mul wr idiv def
            /nb_sub_blocks Pg Pg_sub_block idiv def
            /encoding_iterations Pg Pg_sub_block idiv Pn_sub_block nb_sub_blocks mul Pn lt {1 sub} if def
            createMatrixA
        } {         % Metadata
            /Pg Pn 2 mul def
            /nb_sub_blocks 1 def
            /Pg_sub_block  Pg def
            /Pn_sub_block  Pn def
            /encoding_iterations 1 def
            createMetadataMatrixA
        } ifelse
        GaussJordan
        createGeneratorMatrix

        /ecc_encoded_data Pg array def

        /offset Pg_sub_block matrix_rank sub 32 div ceiling cvi def
        0 1 encoding_iterations 1 sub {
            /iter exch def
            0 1 Pg_sub_block 1 sub {
                /i exch def
                /temp 0 def
                /loop0 0 def
                /offset_index offset i mul def
                iter Pn_sub_block mul 1 iter 1 add Pn_sub_block mul 1 sub {
                    data exch get
                    G offset_index loop0 32 idiv add getw 31 loop0 32 mod sub neg bitshift 1 and and
                    /temp exch temp xor def
                    /loop0 loop0 1 add def
                } for
                ecc_encoded_data i iter Pg_sub_block mul add temp put
            } for
        } for

        encoding_iterations nb_sub_blocks ne {
            /start      encoding_iterations Pn_sub_block mul def
            /last_index encoding_iterations Pg_sub_block mul def
            /Pg_sub_block Pg encoding_iterations Pg_sub_block mul sub def
            /Pn_sub_block Pg_sub_block wr wc sub mul wr idiv def
            createMatrixA
            GaussJordan
            createGeneratorMatrix
            /offset Pg_sub_block matrix_rank sub 32 div ceiling cvi def
            0 1 Pg_sub_block 1 sub {
                /i exch def
                /temp 0 def
                /loop0 0 def
                /offset_index offset i mul def
                start 1 Pn 1 sub {
                    data exch get
                    G offset_index loop0 32 idiv add getw 31 loop0 32 mod sub neg bitshift 1 and and
                    /temp exch temp xor def
                    /loop0 loop0 1 add def
                } for
                ecc_encoded_data i last_index add temp put
            } for
        } if

        /out Pg string def
        0 1 Pg 1 sub {
            dup ecc_encoded_data exch get
            out 3 1 roll 48 add put
        } for
        out

    } def

    % Replace data bitstream with LDPC error correction stream
    /bits bits datawc datawr ldpc def

    % Interleave via pseudorandom permutation
    /s0 16#0000 def  /s1 16#0000 def  /s2 16#0003 def  /s3 16#75C7 def  % s=226759
    bits length 1 sub -1 1 {
        /l exch def
        lcg64_temper
        dup 0 lt {16#80000000 xor 2147483648.0 add} if
        4294967296.0 div l 1 add mul cvi  % (float)UINT32_MAX = 65536.0 * 65536
        /r exch def
        bits l get bits r get
        bits exch l exch put
        bits exch r exch put
    } for

    % Append padding bits to the interleaved, ECC encoded data up to capacity
    /tmpbits C string def
    tmpbits 0 bits putinterval
    /j bits length def
    C j sub 1 add 2 idiv {
        tmpbits j 48 put
        j 1 add C lt {tmpbits j 1 add 49 put} if
        /j j 2 add def
    } repeat
    /bits tmpbits def

    % Define the color palette
    colors 4 eq {
        /bi 0 def  /gi 1 def  /mi 2 def  /yi 3 def
        /ki 4 def  /wi 5 def  % Extended
        /palette <<
            bi (0000FF)  gi (00FF00)  mi (FF00FF)  yi (FFFF00)
            ki (000000)  wi (FFFFFF)
        >> def
        /metacolorindex [bi gi mi yi] def
        /palettelayout  [bi gi mi yi] def
    } {
        /rgbres <<
              % r g b   Graduations
           8  [ 2 2 2 ]
          16  [ 4 2 2 ]
          32  [ 4 4 2 ]
          64  [ 4 4 4 ]
         128  [ 8 4 4 ]
         256  [ 8 8 4 ]
        >> colors get def

        /rvals rgbres 0 get [ exch 1 sub dup 0 exch 1 exch {255 2 index div mul round cvi exch} for pop ] def
        /gvals rgbres 1 get [ exch 1 sub dup 0 exch 1 exch {255 2 index div mul round cvi exch} for pop ] def
        /bvals rgbres 2 get [ exch 1 sub dup 0 exch 1 exch {255 2 index div mul round cvi exch} for pop ] def

        /palette colors dict def
        /palettelayout 64 colors 2 copy gt {exch} if pop array def
        /i 0 def  /j 8 def
        rvals {
            /r exch def
            gvals {
                /g exch def
                bvals {
                    /b exch def
                    r 16 bitshift g 8 bitshift or b or
                    (000000) 6 string copy dup 3 -1 roll 16 6 string cvrs dup length 6 exch sub exch putinterval
                    false
                    1 index (000000) eq {/ki i def  pop true} if
                    1 index (0000FF) eq {/bi i def  pop true} if
                    1 index (00FF00) eq {/gi i def  pop true} if
                    1 index (00FFFF) eq {/ci i def  pop true} if
                    1 index (FF0000) eq {/ri i def  pop true} if
                    1 index (FF00FF) eq {/mi i def  pop true} if
                    1 index (FFFF00) eq {/yi i def  pop true} if
                    1 index (FFFFFF) eq {/wi i def  pop true} if
                    not {
                        colors 64 le
                        colors 128 eq
                            r 0 eq r 73 eq or r 182 eq or r 255 eq or and
                        colors 256 eq
                            r 0 eq r 73 eq or r 182 eq or r 255 eq or and
                            g 0 eq g 73 eq or g 182 eq or g 255 eq or and
                        or or {  % RGB space is sampled into 64 slots
                            palettelayout j i put
                            /j j 1 add def
                        } if
                    } if
                    palette exch i exch put
                    /i i 1 add def
                } forall
            } forall
        } forall
        palettelayout 0 [ki bi gi ci ri mi yi wi] putinterval
        /metacolorindex [ki bi gi ci ri mi yi wi] def
    } ifelse

    % Create the pixel map
    /pixs [rows cols mul {-1} repeat] def
    /jmv {cols mul add} def

    % Finder patterns
    slave not {  % Master alignment pattern
        /fpat [
            [ 1 1 1 0 0 ]
            [ 1 2 2 0 0 ]
            [ 1 2 1 2 1 ]
            [ 0 0 2 2 1 ]
            [ 0 0 1 1 1 ]
        ] def
        /fmap [
            [ -1 bi yi ]  % UL
            [ -1 yi bi ]  % LL
            [ -1 gi mi ]  % UR
            [ -1 mi gi ]  % LR
        ] def
    } {  % Slave alignment pattern
        /fpat [
            [ 0 0 0 0 0 ]
            [ 0 2 2 0 0 ]
            [ 0 2 1 2 0 ]
            [ 0 0 2 2 0 ]
            [ 0 0 0 0 0 ]
        ] def
        /fmap [
            [ -1 ki wi ]  % UL
            [ -1 ki wi ]  % LL
            [ -1 ki wi ]  % UR
            [ -1 ki wi ]  % LR
        ] def
    } ifelse
    0 1 4 {
      /y exch def
      0 1 4 {
        /x exch def
        /fpb fpat y get x get def
        pixs x 1 add y 1 add                     jmv fmap 0 get fpb get put
        pixs x 1 add           rows y sub 2 sub  jmv fmap 1 get fpb get put
        pixs x cols add 6 sub  y 1 add           jmv fmap 2 get fpb get put
        pixs x cols add 6 sub  rows y sub 2 sub  jmv fmap 3 get fpb get put
      } for
    } for

    % Alignment patterns
    /algnpat0 [
        [ ki ki -1 ]
        [ ki wi ki ]
        [ -1 ki ki ]
    ] def
    /algnpat1 [
        [ -1 ki ki ]
        [ ki wi ki ]
        [ ki ki -1 ]
    ] def
    /num cols 16 div round cvi 1 sub def
    /algnrpos [ 3 17 ] def
    num 0 gt {
        /algnrpos [ 0 1 num {cols 7 sub num div mul cvi 3 add} for ] def
    } if
    /num rows 16 div round cvi 1 sub def
    /algncpos [ 3 17 ] def
    num 0 gt {
        /algncpos [ 0 1 num {rows 7 sub num div mul cvi 3 add} for ] def
    } if
    /putalgnpat {
        /pp exch def
        /py exch def
        /px exch def
        0 1 2 {
            /pb exch def
            0 1 2 {
                /pa exch def
                pixs px pa add py pb add jmv pp pb get pa get put
            } for
        } for
    } def
    0 1 algncpos length 1 sub {
        /j exch def
        /y algncpos j get def
        0 1 algnrpos length 1 sub {
            /i exch def
            /x algnrpos i get def
            pixs x y jmv get -1 eq {
                x 1 sub y 1 sub i j add 2 mod 0 eq {algnpat0} {algnpat1} ifelse putalgnpat
            } if
        } for
    } for

    slave not {

        [  % Expanded to [ x y ] [ x -y ] [ -x -y ] [ x -y ]
            % Metadata and palette
            [ 6 1 ] [ 6 2 ] [ 6 3 ] [ 6 4 ] [ 6 5 ] [ 6 6 ] [ 5 6 ] [ 4 6 ] [ 3 6 ] [ 2 6 ]  %  0-39
            [ 1 6 ] [ 7 1 ] [ 7 2 ] [ 7 3 ] [ 7 4 ] [ 7 5 ] [ 7 6 ] [ 7 7 ] [ 6 7 ] [ 5 7 ]  % 40-79
            % Palette only
            [  4  7 ] [  3  7 ] [  2  7 ] [  1  7 ] [  8  1 ] [  8  2 ] [  8  3 ] [  8  4 ]  % 16-31
            [  8  5 ] [  8  6 ] [  8  7 ] [  8  8 ] [  7  8 ] [  6  8 ] [  5  8 ] [  4  8 ]  % 32-47
            [  3  8 ] [  2  8 ] [  1  8 ] [  9  1 ] [  9  2 ] [  9  3 ] [  9  4 ] [  9  5 ]  % 48-63
        ] {
            aload pop /y exch def /x exch def
            [ x y ] [ x neg y ] [ x neg y neg ] [ x y neg ]
        } forall
        176 array astore /metadatamap exch def

        /palettemap1 [
            [  4  1 ] [  4  2 ] [  5  1 ] [  5  2 ] [  2  4 ] [  2  5 ] [  1  4 ] [  1  5 ]  %  0-7
            [ -2  1 ] [ -2  2 ] [ -1  1 ] [ -1  2 ] [ -4  4 ] [ -4  5 ] [ -5  4 ] [ -5  5 ]  %  8-15
        ] def

        /palettemap2 [
            [ -4 -5 ] [ -4 -4 ] [ -5 -5 ] [ -5 -4 ] [ -2 -2 ] [ -2 -1 ] [ -1 -2 ] [ -1 -1 ]  %  0-7
            [  2 -5 ] [  2 -4 ] [  1 -5 ] [  1 -4 ] [  4 -2 ] [  4 -1 ] [  5 -2 ] [  5 -1 ]  %  8-15
        ] def

    } {  % Slave

        % TODO Cascade

        /metadatamap [
            1 1 19 {
                /i exch def
                [ 0 i ] [ 1 i ]
            } for
            5 1 12 {
                /i exch def
                [ 2 i ] [ 3 i ]
            } for
        ] def

        /palettemap1 [
             5  1 12 { [ exch 4 exch ] } for
            12 -1  5 { [ exch 5 exch ] } for
             5  1 12 { [ exch 6 exch ] } for
            12 -1  5 { [ exch 7 exch ] } for
        ] def

        /palettemap2 [
            palettemap1 {[ exch aload pop neg exch neg exch]} forall
        ] def

    } ifelse

    % Normalise wrapping
    metadatamap {
        dup 0 get dup 0 lt {cols add 1 sub 1 index 0 3 -1 roll put} {pop} ifelse
        dup 1 get dup 0 lt {rows add 1 sub 1 index 1 3 -1 roll put} {pop} ifelse
        pop
    } forall
    palettemap1 {
        dup 0 get dup 0 lt {cols add 1 sub 1 index 0 3 -1 roll put} {pop} ifelse
        dup 1 get dup 0 lt {rows add 1 sub 1 index 1 3 -1 roll put} {pop} ifelse
        pop
    } forall
    palettemap2 {
        dup 0 get dup 0 lt {cols add 1 sub 1 index 0 3 -1 roll put} {pop} ifelse
        dup 1 get dup 0 lt {rows add 1 sub 1 index 1 3 -1 roll put} {pop} ifelse
        pop
    } forall

    % Reserve the metadata modules to be placed once mask is determined
    0 1 nummetamodules 1 sub {
        pixs exch metadatamap exch get aload pop jmv 0 put
    } for

    % Place the color palette
    slave not {
        % Up to first 16 colors into finder slots
        0 1 16 colors 2 copy gt {exch} if pop 1 sub {
            /i exch def
            palettelayout i get dup
            pixs exch palettemap1 i get aload pop jmv exch put
            pixs exch palettemap2 i get aload pop jmv exch put
        } for
        /i 16 def
    } {
        /i 0 def
    } ifelse

    % Continue palette placement after end of metadata modules
    /j nummetamodules def
    i 2 palettelayout length 1 sub {
        /i exch def
        palettelayout i get dup
        pixs exch metadatamap j       get aload pop jmv exch put
        pixs exch metadatamap j 2 add get aload pop jmv exch put
        palettelayout i 1 add get dup
        pixs exch metadatamap j 1 add get aload pop jmv exch put
        pixs exch metadatamap j 3 add get aload pop jmv exch put
        /j j 4 add def
    } for

    % Calculate the mask patterns applied to data modules
    /maskfuncs [
        {add colors mod}
        {pop colors mod}
        {exch pop colors mod}
        {3 idiv exch 2 idiv add colors mod}
        {2 idiv exch 3 idiv add colors mod}
        {add dup 2 idiv exch 3 idiv add colors mod}
        {2 copy exch dup mul mul 7 mod 3 1 roll exch dup mul add 2 mul 19 mod add colors mod}
        {2 copy dup mul mul 5 mod 3 1 roll dup mul exch 2 mul add 13 mod add colors mod}
    ] def
    mask -1 ne {  % User specifies a mask
        /maskfuncs [maskfuncs mask get] def
        /bestmaskval mask def
    } if
    /masks maskfuncs length array def
    0 1 masks length 1 sub {
        /m exch def
        /mask rows cols mul array def
        0 1 rows 1 sub {
            /j exch def
            0 1 cols 1 sub {
                /i exch def
                pixs i j jmv get -1 eq {i j maskfuncs m get exec} {0} ifelse
                mask i j jmv 3 -1 roll put
            } for
        } for
        masks m mask put
    } for

    % Walk the symbol placing the data bitstream
    /posx 0 def  /posy 0 def
    /i 0 def
    { % loop
        posx cols eq {exit} if
        pixs posx posy jmv get -1 eq {
            bits i databpm getinterval 0 exch {48 sub add 2 mul} forall 2 idiv
            pixs posx posy jmv 3 -1 roll put
            /i i databpm add def
        } if
        /posy posy 1 add def
        posy rows eq {/posy 0 def /posx posx 1 add def} if
    } loop

    % Evaluate runlength encoded rows or columns in full symbols
    /evalrle {
        /scrle exch def
        /scr1 0 def  /scr3 0 def
        0 2 scrle length 2 sub {
            /j exch def
            scrle j 1 add get -1 ne {  % Skip over voids
                % Detect runs of 5 or more like modules, except in voids
                scrle j get dup 5 ge {2 sub /scr1 exch scr1 add def} {pop} ifelse
                % Detect finder pattern
                j 4 ge j scrle length 5 sub le and {
                    scrle j 4 sub 10 getinterval                     % n1 c1 ... n5 c5
                    dup {1 eq} forall pop 4 {exch pop and} repeat {  % n{1-5}=1
                        mark exch aload pop
                        8 index dup 6 index eq exch 2 index eq and   % c1=c3=c5
                        7 index 4 index eq and {                     % c2=c4
                            2 index  /c4 exch def  /c5 exch def
                            c4 bi eq c5 yi eq and  c4 yi eq c5 bi eq and
                            c4 gi eq c5 mi eq and  c4 mi eq c5 gi eq and
                            or or or {/scr3 scr3 100 add def} if
                        } if
                        cleartomark
                    } {pop} ifelse
                } if
            } if
        } for
        scr1 scr3
    } def

    /evalmask {
        /sym exch def

        /n1 0 def /n2 0 def /n3 0 def
        /rle rows cols 2 copy lt {exch} if pop 2 mul 2 add array def
        /lastpairs cols array def
        /thispairs cols array def

        % Runlength encode and evaluate each column
        0 1 cols 1 sub {
            /i exch def
            mark 0 -1
            i cols rows cols mul 1 sub {
                sym exch get 2 copy eq {pop exch 1 add exch} {1 exch} ifelse
            } for
            rle 0 counttomark 2 sub getinterval astore
            evalrle n3 add /n3 exch def n1 add /n1 exch def
            pop
        } for

        0 1 rows 1 sub {
            /i exch def

            % Runlength encode and evaluate each row
            /symrow sym i cols mul cols getinterval def
            mark 0 -1
            symrow {
                2 copy eq {pop exch 1 add exch} {1 exch} ifelse
            } forall
            rle 0 counttomark 2 sub getinterval astore
            evalrle n3 add /n3 exch def n1 add /n1 exch def
            pop

            % Count and score same coloured blocks
            /lastpairs thispairs /thispairs lastpairs def def
            -1 symrow {exch 2 copy ne {pop -1 exch} if} forall
            pop
            thispairs astore pop
            i 0 gt {
                mark
                lastpairs aload pop thispairs aload pop
                n2 cols { exch dup -1 ne { cols 1 add index eq {3 add} if } {pop} ifelse } repeat
                /n2 exch def
                cleartomark
            } if
        } for

        n1 n2 add n3 add
    } def

    % Evaluate the masked symbols to find the most suitable
    /bestscore 999999999 def
    0 1 masks length 1 sub {
        /m exch def
        /masksym rows cols mul array def
        0 1 rows cols mul 1 sub {
            /i exch def
            masksym i pixs i get masks m get i get xor put
        } for
        masks length 1 ne {
            masksym evalmask /score exch def
            score bestscore lt {
                /bestsym masksym def
                /bestmaskval m def
                /bestscore score def
            } if
        } {
            /bestsym masksym def
        } ifelse
    } for
    /pixs bestsym def
    /metamask bestmaskval def

    % Derive the metadata bitstream
    /addtometapart {
        dup metapart p 3 -1 roll putinterval
        length p add /p exch def
    } def

    /addtometabits {
        dup metabits q 3 -1 roll putinterval
        length q add /q exch def
    } def

    /metapart 40 string def
    /metabits nummetabits string def
    /p 0 def  /q 0 def
    slave not {

        % Part I
        colors ln 2 ln div round cvi 1 sub
        3 tofixedbits addtometapart                                 % Nc
        metapart 0 p getinterval 2 -1 ldpc addtometabits  /p 0 def

        % Part II
        metass   1 tofixedbits addtometapart                        % SS
        metavf   2 tofixedbits addtometapart                        % VF
        metamask 3 tofixedbits addtometapart                        % MSK
        hasslaves {(1)} {(0)} ifelse addtometapart                  % SF
        metapart 0 p getinterval 2 -1 ldpc addtometabits  /p 0 def

        % Part III
        metass 0 eq {  % Square
            cols 17 sub 4 idiv [ 0 4 8 16 ] metavf get sub 1 sub
            metavlen tofixedbits addtometapart                      % V
        } {  % Rectangular
            cols 17 sub 4 idiv 1 sub
            metavlen 2 idiv tofixedbits addtometapart               % V1
            rows 17 sub 4 idiv 1 sub
            metavlen 2 idiv tofixedbits addtometapart               % V2
        } ifelse
        datawc 3 sub metaelen 2 idiv tofixedbits addtometapart      % E1
        datawr 4 sub metaelen 2 idiv tofixedbits addtometapart      % E2
        hasslaves {  % TODO Cascading
            0 4 tofixedbits addtometapart                           % S
        } if
        metapart 0 p getinterval 2 -1 ldpc addtometabits  /p 0 def

    } {  % slave

        % Part I
        sameshape {0} {1} ifelse 1 tofixedbits addtometapart        % SS
        sameecc   {0} {1} ifelse 1 tofixedbits addtometapart        % SE
        hasslaves {1} {0} ifelse 1 tofixedbits addtometapart        % SF
        metapart 0 p getinterval 2 -1 ldpc addtometabits  /p 0 def

        % Part II
        sameshape not {
            diffside 17 sub 4 idiv 1 sub
            5 tofixedbits addtometapart                             % V
        } if
        hasslaves {  % TODO Cascading
            0 3 tofixedbits addtometapart                           % S
        } if
        metapart 0 p getinterval 2 -1 ldpc addtometabits  /p 0 def

        % Part III
        sameecc not {
            datawc 3 sub metaelen 2 idiv tofixedbits addtometapart  % E1
            datawr 4 sub metaelen 2 idiv tofixedbits addtometapart  % E2
        } if
        metapart 0 p getinterval 2 -1 ldpc addtometabits  /p 0 def

    } ifelse
    q 1 nummetabits 1 sub {  % Pad with 0s
        metabits exch 48 put
    } for

    % Place the metadata
    /i 0 def  /j 0 def
    slave not {  % Two-color encoding of Part I (Nc) in master symbols
        metabits i 6 getinterval {
            colors 4 eq {[bi yi]} {[ki wi]} ifelse exch 48 sub get
            pixs metadatamap j get aload pop jmv 3 -1 roll put
            /j j 1 add def
        } forall
        /i i 6 add def
    } if
    nummetabits i sub metabpm idiv {
        metabits i metabpm getinterval 0 exch {48 sub add 2 mul} forall 2 idiv
        metacolorindex exch get
        pixs metadatamap j get aload pop jmv 3 -1 roll put
        /i i metabpm add def
        /j j 1 add def
    } repeat

    <<
    /ren /renmatrix
    /pixs pixs
    /pixx cols
    /pixy rows
    /colormap palette
    /height rows 2 mul 72 div
    /width  cols 2 mul 72 div
    /borderleft 0.0
    /borderright 0.0
    /bordertop 0.0
    /borderbottom 0.0
    /opt options
    >>

    dontdraw not //renmatrix if

    end

}
[/barcode] {null def} forall
bind def
/jabcode dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER jabcode--
