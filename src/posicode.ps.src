% Barcode Writer in Pure PostScript
% https://bwipp.terryburton.co.uk
%
% vim: set sw=4 sts=4 et:
%
% Copyright (c) 2004-2026 Terry Burton
%
% $Id$
%
% Permission is hereby granted, free of charge, to any
% person obtaining a copy of this software and associated
% documentation files (the "Software"), to deal in the
% Software without restriction, including without
% limitation the rights to use, copy, modify, merge,
% publish, distribute, sublicense, and/or sell copies of
% the Software, and to permit persons to whom the Software
% is furnished to do so, subject to the following
% conditions:
%
% The above copyright notice and this permission notice
% shall be included in all copies or substantial portions
% of the Software.
%
% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY
% KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
% THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
% PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
% THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
% DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
% CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
% CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
% IN THE SOFTWARE.

% --BEGIN ENCODER posicode--
% --REQUIRES preamble raiseerror setuphooks processoptions parseinput setanycolor rendertext renlinear--
% --DESC: PosiCode
% --EXAM: ABC123
% --EXOP: version=b inkspread=-0.5 parsefnc includetext
% --RNDR: renlinear
currentglobal
true setglobal
/setpacking where {pop currentpacking true setpacking} if
16 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /processoptions dup /uk.co.terryburton.bwipp findresource put
dup /parseinput dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin

%
% Special function characters
%
/posicode.la0  -1 def  /posicode.la1  -2 def  /posicode.la2  -3 def
/posicode.sf0  -4 def  /posicode.sf1  -5 def  /posicode.sf2  -6 def
/posicode.fn1  -7 def  /posicode.fn2  -8 def  /posicode.fn3  -9 def  /posicode.fn4 -10 def

/la0 //posicode.la0 def  /la1 //posicode.la1 def  /la2 //posicode.la2 def
/sf0 //posicode.sf0 def  /sf1 //posicode.sf1 def  /sf2 //posicode.sf2 def
/fn1 //posicode.fn1 def  /fn2 //posicode.fn2 def  /fn3 //posicode.fn3 def  /fn4 //posicode.fn4 def

%
% Character maps for each state
%
/posicode.charmapsnormal [
    %  0    1    2        0    1    2        0    1    2
    [ (0)  (^)  (') ]  [ (1)  (;)   27 ]  [ (2)  (<)   28 ]  % 0-2
    [ (3)  (=)   29 ]  [ (4)  (>)   30 ]  [ (5)  (?)   31 ]  % 3-5
    [ (6)  (@)  (!) ]  [ (7)  ([)  (") ]  [ (8)   92  (#) ]  % 6-8
    [ (9)  (])  (&) ]  [ (A)  (a)    1 ]  [ (B)  (b)    2 ]  % 9-11
    [ (C)  (c)    3 ]  [ (D)  (d)    4 ]  [ (E)  (e)    5 ]  % 12-14
    [ (F)  (f)    6 ]  [ (G)  (g)    7 ]  [ (H)  (h)    8 ]  % 15-17
    [ (I)  (i)    9 ]  [ (J)  (j)   10 ]  [ (K)  (k)   11 ]  % 18-20
    [ (L)  (l)   12 ]  [ (M)  (m)   13 ]  [ (N)  (n)   14 ]  % 21-23
    [ (O)  (o)   15 ]  [ (P)  (p)   16 ]  [ (Q)  (q)   17 ]  % 24-26
    [ (R)  (r)   18 ]  [ (S)  (s)   19 ]  [ (T)  (t)   20 ]  % 27-29
    [ (U)  (u)   21 ]  [ (V)  (v)   22 ]  [ (W)  (w)   23 ]  % 30-32
    [ (X)  (x)   24 ]  [ (Y)  (y)   25 ]  [ (Z)  (z)   26 ]  % 33-35
    [ (-)  (_)   40 ]  [ (.)  (`)   41 ]  [ ( )  127    0 ]  % 36-38
    [ ($)  ({)  (*) ]  [ (/)  (|)  (,) ]  [ (+)  (})  (:) ]  % 39-41
    [ (%)  (~)  fn1 ]  [ la1  la0  fn2 ]  [ sf1  sf0  fn3 ]  % 42-44
    [ sf2  sf2  fn4 ]                                        % 45
] readonly def

/posicode.charmapslimited [
    [ (0)  -98  -98 ]  [ (1)  -98   -98 ]  [ (2)  -98  -98 ]  % 0-2
    [ (3)  -98  -98 ]  [ (4)  -98   -98 ]  [ (5)  -98  -98 ]  % 3-5
    [ (6)  -98  -98 ]  [ (7)  -98   -98 ]  [ (8)  -98  -98 ]  % 6-8
    [ (9)  -98  -98 ]  [ (A)  -98   -98 ]  [ (B)  -98  -98 ]  % 9-11
    [ (C)  -98  -98 ]  [ (D)  -98   -98 ]  [ (E)  -98  -98 ]  % 12-14
    [ (F)  -98  -98 ]  [ (G)  -98   -98 ]  [ (H)  -98  -98 ]  % 15-17
    [ (I)  -98  -98 ]  [ (J)  -98   -98 ]  [ (K)  -98  -98 ]  % 18-20
    [ (L)  -98  -98 ]  [ (M)  -98   -98 ]  [ (N)  -98  -98 ]  % 21-23
    [ (O)  -98  -98 ]  [ (P)  -98   -98 ]  [ (Q)  -98  -98 ]  % 24-26
    [ (R)  -98  -98 ]  [ (S)  -98   -98 ]  [ (T)  -98  -98 ]  % 27-29
    [ (U)  -98  -98 ]  [ (V)  -98   -98 ]  [ (W)  -98  -98 ]  % 30-32
    [ (X)  -98  -98 ]  [ (Y)  -98   -98 ]  [ (Z)  -98  -98 ]  % 33-35
    [ (-)  -98  -98 ]  [ (.)  -98   -98 ]                     % 36-37
] readonly def

/posicode.encmaps <<   % ";"=11, "<"=12
/a
    [ (141112) (131212) (121312) (111412) (131113)
      (121213) (111313) (121114) (111214) (111115)
      (181111) (171211) (161311) (151411) (141511)
      (131611) (121711) (111811) (171112) (161212)
      (151312) (141412) (131512) (121612) (111712)
      (161113) (151213) (141313) (131413) (121513)
      (111613) (151114) (141214) (131314) (121414)
      (111514) (141115) (131215) (121315) (111415)
      (131116) (121216) (111316) (121117) (111217)
      (111118) (1<111112) (111111111;1)
    ]
/b
    [ (151213) (141313) (131413) (121513) (141214)
      (131314) (121414) (131215) (121315) (121216)
      (191212) (181312) (171412) (161512) (151612)
      (141712) (131812) (121912) (181213) (171313)
      (161413) (151513) (141613) (131713) (121813)
      (171214) (161314) (151414) (141514) (131614)
      (121714) (161215) (151315) (141415) (131515)
      (121615) (151216) (141316) (131416) (121516)
      (141217) (131317) (121417) (131218) (121318)
      (121219) (1<121312) (121212121<1)
    ]
/limiteda
    [ (111411) (111312) (111213) (111114) (121311)
      (121212) (121113) (141111) (131211) (131112)
      (171111) (161211) (151311) (141411) (131511)
      (121611) (111711) (161112) (151212) (141312)
      (131412) (121512) (111612) (151113) (141213)
      (131313) (121413) (111513) (141114) (131214)
      (121314) (111414) (131115) (121215) (111315)
      (121116) (111216) (111117) (151111) (1)
    ]
/limitedb
    [ (121512) (121413) (121314) (121215) (131412)
      (131313) (131214) (151212) (141312) (141213)
      (181212) (171312) (161412) (151512) (141612)
      (131712) (121812) (171213) (161313) (151413)
      (141513) (131613) (121713) (161214) (151314)
      (141414) (131514) (121614) (151215) (141315)
      (131415) (121515) (141216) (131316) (121416)
      (131217) (121317) (121218) (141212) (1)
    ]
>> readonly def

/posicode.c2w [
    [ 495 330 210 126  70  35  15   5 ]
    [ 165 120  84  56  35  20  10   4 ]
    [  45  36  28  21  15  10   6   3 ]
    [   9   8   7   6   5   4   3   2 ]
    [   1   1   1   1   1   1   1   1 ]
] readonly def

/posicode.latevars dup 8 dict def load /init {

    currentglobal
    true setglobal

    //posicode.latevars begin

    %
    % Pre-compute charvals for normal charmaps
    %
    /charvals_normal [
        //posicode.charmapsnormal length dict
        //posicode.charmapsnormal length dict
        //posicode.charmapsnormal length dict
    ] def
    0 1 //posicode.charmapsnormal length 1 sub {
        /i exch def
        /encs //posicode.charmapsnormal i get def
        0 1 2 {
            /j exch def
            encs j get dup type /stringtype eq {0 get} if
            charvals_normal j get exch i put
        } for
    } for
    /charvals_normal charvals_normal readonly def

    %
    % Pre-compute charvals for limited charmaps
    %
    /charvals_limited [
        //posicode.charmapslimited length dict
        //posicode.charmapslimited length dict
        //posicode.charmapslimited length dict
    ] def
    0 1 //posicode.charmapslimited length 1 sub {
        /i exch def
        /encs //posicode.charmapslimited i get def
        0 1 2 {
            /j exch def
            encs j get dup type /stringtype eq {0 get} if
            charvals_limited j get exch i put
        } for
    } for
    /charvals_limited charvals_limited readonly def

    /init { //posicode.latevars {def} forall } def

    end

    //posicode.latevars /init get exec

    setglobal

} bind put

/uk.co.terryburton.bwipp.global_ctx dup where {
    exch get /preload known {//posicode.latevars /init get exec} if
} {pop} ifelse

/posicode {

    64 dict begin

    /dontdraw false def
    /includetext false def    % Enable/disable text
    /textfont /Courier def
    /textsize 10.0 def
    /textxoffset 0.0 def
    /textyoffset -7.0 def
    /height 1.0 def
    /encoding (auto) def
    /version (a) def
    /checkoffset 0 def
    /raw false def
    /parse false def
    /parsefnc false def

    //processoptions exec /options exch def
    /barcode exch def

    /_render
        dontdraw /uk.co.terryburton.bwipp.global_ctx dup where {exch get /enabledontdraw known} {pop false} ifelse and
        /uk.co.terryburton.bwipp._dontdraw dup where {exch get} {pop false} ifelse or not
    def

    //posicode.latevars /init get exec

    version (a) ne version (b) ne and version (limiteda) ne and version (limitedb) ne and {
        /bwipp.posicodeInvalidVersion (The version must be either a, b, limiteda or limitedb) //raiseerror exec
    } if

    /charmaps version (a) eq version (b) eq or {//posicode.charmapsnormal} {//posicode.charmapslimited} ifelse def

    %
    % Select the pre-computed charvals for the selected version
    %
    /charvals version (a) eq version (b) eq or {charvals_normal} {charvals_limited} ifelse def
    /set0 charvals 0 get def
    /set1 charvals 1 get def
    /set2 charvals 2 get def

    %
    % Validate the input if limited
    %
    version (limiteda) eq version (limitedb) eq or {
        0 1 barcode length 1 sub {
            barcode exch 1 getinterval 0 get set0 exch known not {
                /bwipp.posicodeBadCharacter (Posicode limited must contain only digits, capital letters, and the symbols - and .) //raiseerror exec
            } if
        } for
    } if

    raw {/encoding (raw) def} if

    encoding (raw) eq {
        /cws barcode length array def
        /i 0 def /j 0 def
        { % loop
            i barcode length eq {exit} if
            /cw barcode i 1 add 3 getinterval cvi def
            cws j cw put
            /i i 4 add def
            /j j 1 add def
        } loop
        /cws cws 0 j getinterval def
        /text () def
    } if

    encoding (auto) eq {

        %
        % Parse the input
        %
        /fncvals <<
            /parse parse
            /parsefnc parsefnc
            (FNC1) //posicode.fn1
            (FNC2) //posicode.fn2
            (FNC3) //posicode.fn3
%            (FNC4) fn4        Not user accessible as encoded automatically
        >> def
        barcode fncvals //parseinput exec /msg exch def
        /msglen msg length def

        /text msglen string def
        0 1 msglen 1 sub {
            /i exch def
            text i msg i get dup 0 lt { pop 32 } if put
        } for

        %
        % Standard and extended ASCII runlength at position
        %
        /numSA [ msglen {0} repeat 0 ] def
        /numEA [ msglen {0} repeat 0 ] def
        msglen 1 sub -1 0 {
            /i exch def
            msg i get 0 ge {
                msg i get 128 ge {
                    numEA i numEA i 1 add get 1 add put
                } {
                    numSA i numSA i 1 add get 1 add put
                } ifelse
            } if
        } for

        %
        % FNC4 codeword insertion for extended ASCII
        %
        /ea false def
        mark
        0 1 msglen 1 sub {
            /i exch def
            /c msg i get def
            ea c 128 lt xor not c 0 ge and {  % Other mode required
                ea {numSA} {numEA} ifelse i get dup  % Runlength of other mode
                i add msglen eq {3} {5} ifelse       % Does run terminate symbol
                lt {  % Shift
                    //posicode.fn4
                } {   % Latch
                    //posicode.fn4 //posicode.fn4
                    /ea ea not def
                } ifelse
            } if
            c 0 ge {c 127 and} {c} ifelse
        } for
        counttomark array astore /msg exch def pop
        /msglen msg length def

        %
        % Convert the input message to codewords
        %
        /enc {
            exch get cws exch j exch put
            /j j 1 add def
        } def

        /cws msglen 2 mul array def
        /i 0 def /j 0 def /cset (set0) def
        {
            i msglen eq {exit} if

            {  % common exit

                %
                % Read next two characters
                %
                /char1 msg i get def
                /char2 i 1 add msglen lt {msg i 1 add get} {-99} ifelse def

                %
                % If current mode is sufficient then directly encode
                %
                cset load char1 known {
                    char1 cset load enc
                    /i i 1 add def
                    exit
                } if

                %
                % If char1 is in set2 then shift encode
                %
                set2 char1 known {
                    //posicode.sf2 cset load enc
                    char1 set2 enc
                    /i i 1 add def
                    exit
                } if

                %
                % If char2 is also not in this set then latch else shift encode
                %
                cset load char2 known not {
                    cset (set0) eq {
                       //posicode.la1 cset load enc
                       /cset (set1) def
                    } {
                       //posicode.la0 cset load enc
                       /cset (set0) def
                    } ifelse
                    exit
                } {
                    cset (set0) eq {
                        //posicode.sf1 cset load enc
                        char1 set1 enc
                    } {
                        //posicode.sf0 cset load enc
                        char1 set0 enc
                    } ifelse
                    /i i 1 add def
                    exit
                } ifelse

                exit
            } loop

        } loop
        /cws cws 0 j getinterval def
    } if  % auto encoding

    %
    % Create an array containing the character mappings
    %
    //posicode.encmaps version get /encs exch def

    /v 0 def
    cws {
        /cw exch def
        6 {
            cw v xor 1 and 0 ne {
                /v v 7682 xor def
            } if
            /v v -1 bitshift def
            /cw cw -1 bitshift def
        } repeat
    } forall
    /v v checkoffset add def

    version (limiteda) eq version (limitedb) eq or {
        /v v 1023 and def
        v 824 gt v 853 lt and {
            /v v 292 add def
        } if
    } {
        /v v 1023 and 45 add def
    } ifelse

    /d [ 2 2 2 2 2 2 ] def
    /r 0 def /c 0 def /w 0 def /sum 0 def
    {
        sum v eq {exit} if
        /t sum //posicode.c2w r get c get add def
        t v eq {
            /w w 1 add def
            d r w 2 add put
            /sum t def
        } if
        t v gt {
            d r w 2 add put
            /r r 1 add def
            /w 0 def
        } if
        t v lt {
            /c c 1 add def
            /w w 1 add def
            /sum t def
        } if
    } loop
    20 0 1 4 {d exch get sub} for
    d exch 5 exch put
    version (b) eq version (limitedb) eq or {
        /d [ d {1 add} forall ] def
    } if
    /cbs (111111111111) 12 string copy def
    5 -1 0 {
        /i exch def
        cbs 5 i sub 2 mul 1 add d i get 47 add put
    } for

    %
    % Concatenate the space bar successions
    %
    /sbs cws length 6 mul 31 add string def
    encs encs length 2 sub get dup
    sbs exch 0 exch putinterval
    length /j exch def
    0 1 cws length 1 sub {
        /i exch def
        sbs j encs cws i get get putinterval
        /j j 6 add def
    } for
    sbs j cbs putinterval
    /j j 12 add def
    encs encs length 1 sub get dup
    sbs exch j exch putinterval
    length j add /j exch def
    /sbs sbs 0 j getinterval def

    <<
    /ren /renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    /txt [ [text textxoffset textyoffset textfont textsize] ]
    /textxalign (center)
    /borderleft  << /a 0.0  /b 0.0  /limiteda 12.0  /limitedb 13.0 >> version get
    /borderright << /a 0.0  /b 0.0  /limiteda 12.0  /limitedb 13.0 >> version get
    /opt options
    >>

    _render //renlinear if

    end

}
[/barcode] {null def} forall
bind def
/posicode dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
setglobal
% --END ENCODER posicode--
