%!PS

% Barcode Writer in Pure PostScript
% https://bwipp.terryburton.co.uk
%
% Copyright (c) 2004-2023 Terry Burton
%
% $Id$
%
% Permission is hereby granted, free of charge, to any
% person obtaining a copy of this software and associated
% documentation files (the "Software"), to deal in the
% Software without restriction, including without
% limitation the rights to use, copy, modify, merge,
% publish, distribute, sublicense, and/or sell copies of
% the Software, and to permit persons to whom the Software
% is furnished to do so, subject to the following
% conditions:
%
% The above copyright notice and this permission notice
% shall be included in all copies or substantial portions
% of the Software.
%
% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY
% KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
% THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
% PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
% THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
% DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
% CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
% CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
% IN THE SOFTWARE.

% --BEGIN ENCODER qrcode--
% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput renmatrix--
% --DESC: QR Code
% --EXAM: http://goo.gl/0bis
% --EXOP: eclevel=M
% --RNDR: renmatrix
/setpacking where {pop currentpacking true setpacking} if
10 dict
dup /loadctx dup /uk.co.terryburton.bwipp findresource put
dup /unloadctx dup /uk.co.terryburton.bwipp findresource put
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /processoptions dup /uk.co.terryburton.bwipp findresource put
dup /parseinput dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/qrcode {

    20 dict begin

    /ctx null def
    /dontdraw false def
    /format (unset) def    % full or micro. rMQR symbols are specified using version
    /version (unset) def   % 1-40 or M1-M4 or R7x43, etc
    /eclevel (unset) def   % full: L, M, Q, H; micro: L, M, Q; rmqr: M, H
    /parse false def
    /parsefnc false def
    /mask -1 def

    //processoptions exec /options exch def
    /barcode exch def

    /qrcode //loadctx exec

    % If version is supplied and format is not given then set format to correspond
    version (unset) ne {
        format (unset) eq {
            (full)
            version 0 1 getinterval (M) eq { pop (micro) } if
            version 0 1 getinterval (R) eq { pop (rmqr) } if
            /format exch def
        } if
    } {
        format (unset) eq { /format (full) def } if  % Default to full
    } ifelse

    % Default error correction level
    eclevel (unset) eq {/eclevel format (micro) ne {(M)} {(L)} ifelse def} if

    % Parse the input
    /fn1 -1 def
    /fncvals <<
        /parse parse
        /parsefnc parsefnc
        /eci true
        (FNC1) fn1
    >> def
    /msg barcode fncvals //parseinput exec def
    /msglen msg length def

    % If FNC1 in first position then escape % as %%
    /fnc1first false def
    msglen 0 gt {
        msg 0 get fn1 eq {
            /fnc1first true def
            /msg [ msg 1 msglen 1 sub getinterval { dup 37 eq {dup} if } forall ] def
            /msglen msg length def
        } if
    } if

{  % context

    % Enumerate vergrps
    [
        /v1to9    /v10to26  /v27to40
        /vM1      /vM2      /vM3      /vM4
        /vR7x43   /vR7x59   /vR7x77   /vR7x99   /vR7x139
        /vR9x43   /vR9x59   /vR9x77   /vR9x99   /vR9x139
        /vR11x27  /vR11x43  /vR11x59  /vR11x77  /vR11x99   /vR11x139
        /vR13x27  /vR13x43  /vR13x59  /vR13x77  /vR13x99   /vR13x139
        /vR15x43  /vR15x59  /vR15x77  /vR15x99  /vR15x139
        /vR17x43  /vR17x59  /vR17x77  /vR17x99  /vR17x139
    ] 0 exch {1 index def 1 add} forall pop

    % Convert from input into message bitstream
    %
    % Modes: (N)umeric, (A)lphanumeric, (B)yte, (K)anji, (E)CI
    %
    /N 0 def  /A 1 def  /B 2 def  /K 3 def  /E 4 def

    /Nexcl <<
       [
           16#30 1 16#39 {} for
       ] {-1} forall
    >> def

    /Aexcl <<
        [
            16#20 16#24 16#25 16#2A 16#2B 16#2D 16#2E 16#2F 16#3A
            16#41 1 16#5A {} for
            fn1
        ] {-1} forall
    >> def

    % Binary exclusives calculated from "not others"

    /Kexcl <<
        [
            16#81 1 16#9F {} for
            16#E0 1 16#EB {} for
        ] {-1} forall
    >> def

    /mids [
        %    N      A      B      K      E
        [ (0001) (0010) (0100) (1000) (0111) ]  % v1to9
        [ (0001) (0010) (0100) (1000) (0111) ]  % v10to26
        [ (0001) (0010) (0100) (1000) (0111) ]  % v27to40
        [     ()   -1     -1     -1     -1   ]  % vM1
        [    (0)    (1)   -1     -1     -1   ]  % vM2
        [   (00)   (01)   (10)   (11)   -1   ]  % vM3
        [  (000)  (001)  (010)  (011)   -1   ]  % vM4
      32 {
        [  (001)  (010)  (011)  (100)  (111) ]  % rMQR
      } repeat
    ] def

    /cclens [  % N  A  B  K
        [ 10  9  8  8 ]  % v1to9
        [ 12 11 16 10 ]  % v10to26
        [ 14 13 16 12 ]  % v27to40
        [  3 -1 -1 -1 ]  % vM1
        [  4  3 -1 -1 ]  % vM2
        [  5  4  4  3 ]  % vM3
        [  6  5  5  4 ]  % vM4
        [  4  3  3  2 ]  % vR7x43
        [  5  5  4  3 ]  % vR7x59
        [  6  5  5  4 ]  % vR7x77
        [  7  6  5  5 ]  % vR7x99
        [  7  6  6  5 ]  % vR7x139
        [  5  5  4  3 ]  % vR9x43
        [  6  5  5  4 ]  % vR9x59
        [  7  6  5  5 ]  % vR9x77
        [  7  6  6  5 ]  % vR9x99
        [  8  7  6  6 ]  % vR9x139
        [  4  4  3  2 ]  % vR11x27
        [  6  5  5  4 ]  % vR11x43
        [  7  6  5  5 ]  % vR11x59
        [  7  6  6  5 ]  % vR11x77
        [  8  7  6  6 ]  % vR11x99
        [  8  7  7  6 ]  % vR11x139
        [  5  5  4  3 ]  % vR13x27
        [  6  6  5  5 ]  % vR13x43
        [  7  6  6  5 ]  % vR13x59
        [  7  7  6  6 ]  % vR13x77
        [  8  7  7  6 ]  % vR13x99
        [  8  8  7  7 ]  % vR13x139
        [  7  6  6  5 ]  % vR15x43
        [  7  7  6  5 ]  % vR15x59
        [  8  7  7  6 ]  % vR15x77
        [  8  7  7  6 ]  % vR15x99
        [  9  8  7  7 ]  % vR15x139
        [  7  6  6  5 ]  % vR17x43
        [  8  7  6  6 ]  % vR17x59
        [  8  7  7  6 ]  % vR17x77
        [  8  8  7  6 ]  % vR17x99
        [  9  8  8  7 ]  % vR17x139
    ] def

    /termlens [
      3 {
        4  % Full
      } repeat
        3  % vM1
        5  % vM2
        7  % vM3
        9  % vM4
      32 {
        3  % rMQR
      } repeat
    ] def

    /padstrs [ (11101100) (00010001) ] def

    % Alphanumeric character to value map
    /charmap (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:) def
    /charvals 44 dict def
    0 1 44 {dup charmap exch get exch charvals 3 1 roll put} for

} ctxdef

    % Encoding functions
    /tobin {
        string dup length 1 sub 0 exch 1 exch {1 index exch 48 put} for
        dup 3 -1 roll 2 2 index length string cvrs dup length 2 index length exch sub exch putinterval
    } def

    /encA {
        /in exch def
        fnc1first {  % FNC1 as %
            /in [ in { dup fn1 eq {pop 37} if } forall ] def
        } if
        /out in length 11 mul 2 idiv 1 add string def
        /k 0 def /m 0 def {
            k in length eq {exit} if
            k in length 1 sub lt {
                charvals in k get get 45 mul charvals in k 1 add get get add 11 tobin
                /k k 2 add def
            } {  % Final character
                charvals in k get get 6 tobin
                /k k 1 add def
            } ifelse
            dup out exch m exch putinterval
            length m add /m exch def
        } loop
        out 0 m getinterval
    } def

    /encN {
        /in exch def
        /out in length 10 mul 3 idiv 1 add string def
        /k 0 def /m 0 def {
            k in length eq {exit} if
            k in length 2 sub lt {
                in k 3 getinterval 0 exch {exch 10 mul 48 sub add} forall 10 tobin
                /k k 3 add def
            } {
                k in length 2 sub eq {  % Two final digits
                    in k 2 getinterval 0 exch {exch 10 mul 48 sub add} forall 7 tobin
                    /k k 2 add def
                } {  % One final digit
                    in k 1 getinterval 0 exch {exch 10 mul 48 sub add} forall 4 tobin
                    /k k 1 add def
                } ifelse
            } ifelse
            dup out exch m exch putinterval
            length m add /m exch def
        } loop
        out 0 m getinterval
    } def

    /encB {
        /in exch def
        fnc1first {  % FNC1 as GS
            /in [ in { dup fn1 eq {pop 29} if } forall ] def
        } if
        /out in length 8 mul string def
        0 1 in length 1 sub {
            /k exch def
            in k get cvi 8 tobin
            out k 8 mul 3 -1 roll putinterval
        } for
        out
    } def

    /encK {
        /in exch def
        /out in length 2 idiv 13 mul string def
        /k 0 def /m 0 def {
            k in length eq {exit} if
            in k get 256 mul in k 1 add get add
            dup 16#E040 lt {16#8140} {16#C140} ifelse sub
            dup -8 bitshift 16#C0 mul exch 16#00FF and add
            13 tobin dup out exch m exch putinterval
            length m add /m exch def
            /k k 2 add def
        } loop
        out
    } def

    /encE {
        0 get neg 1000000 sub
            dup 000127 le {  % ECI 000000 - 000127
            8 tobin
        } { dup 016383 le {  % ECI 000128 - 016383
                2#1000000000000000 add 16 tobin
        } {                  % ECI 016384 - 999999
                2#110000000000000000000000 add 24 tobin
        } ifelse } ifelse
    } def

    /encfuncs [ /encN /encA /encB /encK /encE ] def

    /addtobits {
        dup bits j 3 -1 roll putinterval
        length j add /j exch def
    } def

    /numNs [ msglen {0} repeat 0 ] def
    /numAs [ msglen {0} repeat 0 ] def
    /numAorNs [ msglen {0} repeat 0 ] def
    /numBs [ msglen {0} repeat 0 ] def
    /numKs [ msglen {0} repeat 0 ] def
    /nextNs [ msglen {0} repeat 9999 ] def
    /nextBs [ msglen {0} repeat 9999 ] def
    /nextAs [ msglen {0} repeat 9999 ] def
    /nextKs [ msglen {0} repeat 9999 ] def
    /isECI msglen array def
    msglen 1 sub -1 0 {
        /i exch def
        /barchar msg i get def
        Kexcl barchar known {
            /sjis i 1 add msglen lt { barchar 256 mul msg i 1 add get add } {0} ifelse def  % Zero if last char
            sjis 16#8140 ge sjis 16#9FFC le and sjis 16#E040 ge sjis 16#EBBF le and or {
                nextKs i 0 put
                numKs i numKs i 2 add get 1 add put
            } {
                nextKs i nextKs i 1 add get 1 add put
            } ifelse
        } {
            nextKs i nextKs i 1 add get 1 add put
        } ifelse
        Nexcl barchar known {
            nextNs i 0 put
            numNs i numNs i 1 add get 1 add put
            numAorNs i numAorNs i 1 add get 1 add put
        } {
            nextNs i nextNs i 1 add get 1 add put
        } ifelse
        Aexcl barchar known {
            nextAs i 0 put
            numAs i numAs i 1 add get 1 add put
            numAorNs i numAorNs i 1 add get 1 add put
        } {
            nextAs i nextAs i 1 add get 1 add put
        } ifelse
        isECI i barchar -1000000 le put
    } for
    0 1 msglen 1 sub {  % Scan forward to set any "2nd byte 1st byte" Kanji matches to zero
        /i exch def
        numKs i get 0 gt {
            numKs i 1 add 0 put
            nextKs i 1 add nextKs i 1 add get 1 add put
        } if
    } for
    msglen 1 sub -1 0 {  % Finally scan backwards again to set numBs/nextBs from "not others"
        /i exch def
        numNs i get numAs i get numKs i get add add 0 eq isECI i get not and {
            nextBs i 0 put
            numBs i numBs i 1 add get 1 add put
        } {
            nextBs i nextBs i 1 add get 1 add put
        } ifelse
    } for

    /KbeforeB {numK exch ver get ge nextBs numK 2 mul i add get 0 eq and} def
    /KbeforeA {numK exch ver get ge nextAs numK 2 mul i add get 0 eq and} def
    /KbeforeN {numK exch ver get ge nextNs numK 2 mul i add get 0 eq and} def
    /KbeforeE {numK exch ver get ge numK 2 mul i add msglen eq and} def
    /AbeforeK {numA exch ver get ge nextKs numA i add get 0 eq and} def
    /AbeforeB {numA exch ver get ge nextBs numA i add get 0 eq and} def
    /AbeforeN {numA exch ver get ge nextNs numA i add get 0 eq and} def
    /AbeforeE {numA exch ver get ge numA i add msglen eq and} def
    /NbeforeK {numN exch ver get ge nextKs numN i add get 0 eq and} def
    /NbeforeB {numN exch ver get ge nextBs numN i add get 0 eq and} def
    /NbeforeA {numN exch ver get ge nextAs numN i add get 0 eq and} def
    /NbeforeE {numN exch ver get ge numN i add msglen eq and} def
    /AorNbeforeB {numAorN exch ver get ge nextBs numAorN i add get 0 eq and} def
    /AorNbeforeE {numAorN exch ver get ge numAorN i add msglen eq and} def

    /nextNslt { nextNs i get msglen ge { pop true } { numNs nextNs i get i add get exch ver get lt } ifelse } def

    % Elements of the encoded message have differing lengths based on the
    % resulting symbol size. The symbol sizes with different element lengths
    % are batched into vergrps. To pick the smallest symbol that holds our
    % content we encode the message according to each available vergrp, based
    % on the format of symbol.

    % Determine which groups we need to encode
{
    /versetmap <<
        % Full
         0 1  9 { 10 2 string cvrs v1to9   } for
        10 1 26 { 10 2 string cvrs v10to26 } for
        27 1 40 { 10 2 string cvrs v27to40 } for

        % Micro
        (M1) vM1  (M2) vM2  (M3) vM3  (M4) vM4

        % rMQR
                          (R7x43)  vR7x43   (R7x59)  vR7x59   (R7x77)  vR7x77   (R7x99)  vR7x99   (R7x139)  vR7x139
                          (R9x43)  vR9x43   (R9x59)  vR9x59   (R9x77)  vR9x77   (R9x99)  vR9x99   (R9x139)  vR9x139
        (R11x27) vR11x27  (R11x43) vR11x43  (R11x59) vR11x59  (R11x77) vR11x77  (R11x99) vR11x99  (R11x139) vR11x139
        (R13x27) vR13x27  (R13x43) vR13x43  (R13x59) vR13x59  (R13x77) vR13x77  (R13x99) vR13x99  (R13x139) vR13x139
                          (R15x43) vR15x43  (R15x59) vR15x59  (R15x77) vR15x77  (R15x99) vR15x99  (R15x139) vR15x139
                          (R17x43) vR17x43  (R17x59) vR17x59  (R17x77) vR17x77  (R17x99) vR17x99  (R17x139) vR17x139
    >> def
    /versetfull  [v1to9 v10to26 v27to40] def
    /versetmicro [vM1 vM2 vM3 vM4] def
} ctxdef
    version (unset) ne {
        % A specific version of symbol is given so encode in just the corresponding vergrp
        /verset versetmap version get [ exch ] def
    } {
        % Just the format is specified so encode in each vergrp for the type of symbol
        format (full)  eq { /verset versetfull  def } if
        format (micro) eq { /verset versetmicro def } if
        % rMQR symbols are accessed with an explicit version
    } ifelse

    % Encode unterminated bitstream for each compatible vergrp separately
    /msgbits [ 39 {-1} repeat ] def
    /e 10000 def

    % Number of before characters per vergrp, depending on current mode, for optimising modes
    % Generated by contrib/development/build-qr-mode-optim-arrs.php
    %                Full     Micro    R7         R9           R11             R13              R15             R17
{
    /mode0forceKB  [ 1  1  1  e e 1 1  1 1 1 1 1  1 1 1 1  1   1 1 1 1  1  1   1 1 1  1  1  1   1  1  1  1  1   1  1  1  1  1] def
    /mode0forceA   [ 1  1  1  e 1 1 1  1 1 1 1 1  1 1 1 1  1   1 1 1 1  1  1   1 1 1  1  1  1   1  1  1  1  1   1  1  1  1  1] def
    /mode0forceN   [ 1  1  1  1 1 1 1  1 1 1 1 1  1 1 1 1  1   1 1 1 1  1  1   1 1 1  1  1  1   1  1  1  1  1   1  1  1  1  1] def

    /mode0NbeforeB [ 4  4  5  e e 2 3  2 2 3 3 3  2 3 3 3  3   2 3 3 3  3  3   2 3 3  3  3  3   3  3  3  3  3   3  3  3  3  3] def

    /modeBKbeforeB [ 9 12 13  e e 4 6  4 5 6 6 6  5 6 6 6  7   4 6 6 6  7  7   5 6 6  7  7  7   6  6  7  7  7   6  7  7  7  8] def
    /modeBKbeforeA [ 8 10 11  e e 4 5  4 5 5 6 6  5 5 6 6  6   4 5 6 6  6  6   5 6 6  6  6  7   6  6  6  6  7   6  6  6  7  7] def
    /modeBKbeforeN [ 8  9 11  e e 3 5  3 4 5 5 5  4 5 5 5  6   3 5 5 5  6  6   4 5 5  6  6  6   5  5  6  6  7   5  6  6  6  7] def
    /modeBKbeforeE [ 5  5  6  e e 2 3  2 3 3 3 3  3 3 3 3  4   2 3 3 3  4  4   3 3 3  4  4  4   3  3  4  4  4   3  4  4  4  4] def

    /modeBAbeforeK [11 12 14  e e 5 7  5 6 7 8 8  6 7 8 8  8   6 7 8 8  8  8   6 8 8  8  8  9   8  8  8  8  9   8  8  8  9  9] def
    /modeBAbeforeB [11 15 16  e e 6 7  6 7 7 8 8  7 7 8 8  8   6 7 8 8  8  9   7 8 8  8  9  9   8  8  9  9  9   8  8  9  9 10] def
    /modeBAbeforeN [12 13 15  e e 6 8  6 7 8 8 8  7 8 8 8  9   6 8 8 8  9  9   7 8 8  9  9 10   8  9  9  9 10   8  9  9 10 10] def
    /modeBAbeforeE [ 6  7  8  e e 3 4  3 4 4 4 4  4 4 4 4  5   4 4 4 4  5  5   4 4 4  5  5  5   4  5  5  5  5   4  5  5  5  5] def

    /modeBNbeforeK [ 6  7  8  e e 3 4  3 4 4 5 5  4 4 5 5  5   3 4 5 5  5  5   4 4 5  5  5  5   5  5  5  5  5   5  5  5  5  5] def
    /modeBNbeforeB [ 6  8  9  e e 3 4  3 4 4 5 5  4 4 5 5  5   3 4 5 5  5  5   4 4 5  5  5  5   5  5  5  5  5   5  5  5  5  6] def
    /modeBNbeforeA [ 6  7  8  e e 3 4  3 4 4 5 5  4 4 5 5  5   4 4 5 5  5  5   4 5 5  5  5  5   5  5  5  5  6   5  5  5  5  6] def
    /modeBNbeforeE [ 3  4  4  e e 2 3  2 2 3 3 3  2 3 3 3  3   2 3 3 3  3  3   2 3 3  3  3  3   3  3  3  3  3   3  3  3  3  3] def

    /modeANbeforeA [13 15 17  e 5 7 9  7 8 9 9 9  8 9 9 9 11   7 9 9 9 11 11   8 9 9 10 11 11   9 10 11 11 11   9 11 11 11 11] def
    /modeANbeforeB [13 17 18  e e 7 9  7 8 9 9 9  8 9 9 9 10   7 9 9 9 10 11   8 9 9  9 11 11   9  9 11 11 11   9 10 11 11 11] def
    /modeANbeforeE [ 7  8  9  e 3 4 5  4 5 5 5 5  5 5 5 5  6   4 5 5 5  6  6   5 5 5  5  6  6   5  5  6  6  6   5  6  6  6  6] def
} ctxdef

    verset {
        /ver exch def

        % Derive optimal sequence
        /mode -1 def /seq [] def /i 0 def {
            i msglen ge {exit} if
            /numK numKs i get def
            /numB numBs i get def
            /numA numAs i get def
            /numN numNs i get def
            /numAorN numAorNs i get def
            /eci isECI i get def
            ver vM1 eq numA 1 ge and {/seq -1 def exit} if
            ver vM1 eq numB 1 ge and {/seq -1 def exit} if
            ver vM1 eq numK 1 ge and {/seq -1 def exit} if
            ver vM1 eq eci and       {/seq -1 def exit} if
            ver vM2 eq numB 1 ge and {/seq -1 def exit} if
            ver vM2 eq numK 1 ge and {/seq -1 def exit} if
            ver vM2 eq eci and       {/seq -1 def exit} if
            ver vM3 eq eci and       {/seq -1 def exit} if
            ver vM4 eq eci and       {/seq -1 def exit} if
            {  % common exit
                eci {
                    E exit
                } if
                mode -1 eq {  % Set initial mode (or mode after ECI)
                    mode0forceKB  KbeforeA {K exit} if
                    mode0forceKB  KbeforeN {K exit} if
                    modeBKbeforeE KbeforeB {K exit} if  % Re-using modeB KbeforeE array
                    mode0forceKB  KbeforeE {K exit} if
                    numK 1 ge {B exit} if
                    mode0NbeforeB NbeforeB {N exit} if
                    mode0forceKB  NbeforeB {B exit} if
                    modeANbeforeE NbeforeA {N exit} if  % Re-using modeA NbeforeE array
                    mode0forceN   NbeforeE {N exit} if
                    modeBAbeforeE AbeforeK {A exit} if  % Re-using modeB AbeforeE array
                    modeBAbeforeE AorNbeforeB {A exit} if  % Re-using modeB AbeforeE array
                    mode0forceA   AorNbeforeE {A exit} if
                    B exit
                } if
                mode B eq {
                    modeBKbeforeB KbeforeB {K exit} if
                    modeBKbeforeA KbeforeA {K exit} if
                    modeBKbeforeN KbeforeN {K exit} if
                    modeBKbeforeE KbeforeE {K exit} if
                    modeBAbeforeK AbeforeK {A exit} if
                    modeBAbeforeB AbeforeB {A exit} if
                    modeBAbeforeN AbeforeN {A exit} if
                    modeBAbeforeE AbeforeE {A exit} if
                    modeBNbeforeK NbeforeK {N exit} if
                    modeBNbeforeB NbeforeB {N exit} if
                    modeBNbeforeA NbeforeA {N exit} if
                    modeBNbeforeE NbeforeE {N exit} if
                    modeBAbeforeE AorNbeforeE numAorN modeBAbeforeN ver get le and {  % If A/N sequence at end and short
                        modeBNbeforeA nextNslt {A exit} if  % And next N sequence shorter than NbeforeA
                    } if
                    B exit
                } if
                mode A eq {
                    numK 1 ge {K exit} if
                    numB 1 ge {B exit} if
                    modeANbeforeA NbeforeA {N exit} if
                    modeANbeforeB NbeforeB {N exit} if
                    modeANbeforeE NbeforeE {N exit} if
                    numA 1 ge numN 1 ge or {A exit} if
                    B exit
                } if
                mode N eq {
                    numK 1 ge {K exit} if
                    numB 1 ge {B exit} if
                    numA 1 ge {A exit} if
                    numN 1 ge {N exit} if
                    B exit
                } if
                mode K eq {
                    numB 1 ge {B exit} if
                    numA 1 ge {A exit} if
                    numN 1 ge {N exit} if
                    numK 1 ge {K exit} if
                    B exit
                } if
            } loop
            dup K eq fnc1first and {pop B} if  % No kanji with fnc1first
            dup mode eq {  % Same mode encode directly
                pop
                /dat msg i mode K eq {2} {1} ifelse getinterval def
                /seq [
                    seq aload pop
                    [ exch aload pop dat aload pop ]
                ] def
            } {  % Change mode
                /mode exch def
                mode K eq {K msg i numK 2 mul getinterval} if
                mode B eq {B msg i numB getinterval} if
                mode A eq {A msg i numA getinterval} if
                mode N eq {N msg i numN getinterval} if
                mode E eq {E msg i 1 getinterval  /mode -1 def} if
                /dat exch def /sw exch def
                /seq [ seq aload pop sw dat ] def
            } ifelse
            /i i dat length add def
        } loop

        % Encode the sequence
        {  % common exit
            seq -1 eq {exit} if  % Sequence not available
            /bits 23648 string def
            /j 0 def
            fnc1first {
                ver vR7x43 lt { (0101) } { (101) } ifelse addtobits
            } if
            /abort false def
            0 2 seq length 1 sub {
                /i exch def
                /mode seq i get def
                mids ver get mode get addtobits
                /chars seq i 1 add get def
                /charslen chars length mode K eq {2 idiv} if def
                mode E ne {
                    /cclen cclens ver get mode get def
                    charslen 2 cclen exp cvi ge {  % Too many characters for cc indicator
                        /abort true def exit
                    } if
                    charslen cclen tobin addtobits
                } if
                chars encfuncs mode get load exec addtobits
            } for
            abort {exit} if
            /bits bits 0 j getinterval def
            msgbits ver bits put
            exit
        } loop
    } forall

    % Lookup the most appropriate symbol specification
{
    /metrics [
        % format   vers       vergrp  rows cols align modules    error codewords        error correction blocks
        %                                                        L    M    Q    H       L1 L2 M1 M2 Q1 Q2 H1 H2
        [ (micro)  (M1)       vM1       11  11  98 99     36  [   2   99   99   99 ]  [  1  0 -1 -1 -1 -1 -1 -1 ] ]
        [ (micro)  (M2)       vM2       13  13  98 99     80  [   5    6   99   99 ]  [  1  0  1  0 -1 -1 -1 -1 ] ]
        [ (micro)  (M3)       vM3       15  15  98 99    132  [   6    8   99   99 ]  [  1  0  1  0 -1 -1 -1 -1 ] ]
        [ (micro)  (M4)       vM4       17  17  98 99    192  [   8   10   14   99 ]  [  1  0  1  0  1  0 -1 -1 ] ]
        [ (full)   (1)        v1to9     21  21  98 99    208  [   7   10   13   17 ]  [  1  0  1  0  1  0  1  0 ] ]
        [ (full)   (2)        v1to9     25  25  18 99    359  [  10   16   22   28 ]  [  1  0  1  0  1  0  1  0 ] ]
        [ (full)   (3)        v1to9     29  29  22 99    567  [  15   26   36   44 ]  [  1  0  1  0  2  0  2  0 ] ]
        [ (full)   (4)        v1to9     33  33  26 99    807  [  20   36   52   64 ]  [  1  0  2  0  2  0  4  0 ] ]
        [ (full)   (5)        v1to9     37  37  30 99   1079  [  26   48   72   88 ]  [  1  0  2  0  2  2  2  2 ] ]
        [ (full)   (6)        v1to9     41  41  34 99   1383  [  36   64   96  112 ]  [  2  0  4  0  4  0  4  0 ] ]
        [ (full)   (7)        v1to9     45  45  22 38   1568  [  40   72  108  130 ]  [  2  0  4  0  2  4  4  1 ] ]
        [ (full)   (8)        v1to9     49  49  24 42   1936  [  48   88  132  156 ]  [  2  0  2  2  4  2  4  2 ] ]
        [ (full)   (9)        v1to9     53  53  26 46   2336  [  60  110  160  192 ]  [  2  0  3  2  4  4  4  4 ] ]
        [ (full)   (10)       v10to26   57  57  28 50   2768  [  72  130  192  224 ]  [  2  2  4  1  6  2  6  2 ] ]
        [ (full)   (11)       v10to26   61  61  30 54   3232  [  80  150  224  264 ]  [  4  0  1  4  4  4  3  8 ] ]
        [ (full)   (12)       v10to26   65  65  32 58   3728  [  96  176  260  308 ]  [  2  2  6  2  4  6  7  4 ] ]
        [ (full)   (13)       v10to26   69  69  34 62   4256  [ 104  198  288  352 ]  [  4  0  8  1  8  4 12  4 ] ]
        [ (full)   (14)       v10to26   73  73  26 46   4651  [ 120  216  320  384 ]  [  3  1  4  5 11  5 11  5 ] ]
        [ (full)   (15)       v10to26   77  77  26 48   5243  [ 132  240  360  432 ]  [  5  1  5  5  5  7 11  7 ] ]
        [ (full)   (16)       v10to26   81  81  26 50   5867  [ 144  280  408  480 ]  [  5  1  7  3 15  2  3 13 ] ]
        [ (full)   (17)       v10to26   85  85  30 54   6523  [ 168  308  448  532 ]  [  1  5 10  1  1 15  2 17 ] ]
        [ (full)   (18)       v10to26   89  89  30 56   7211  [ 180  338  504  588 ]  [  5  1  9  4 17  1  2 19 ] ]
        [ (full)   (19)       v10to26   93  93  30 58   7931  [ 196  364  546  650 ]  [  3  4  3 11 17  4  9 16 ] ]
        [ (full)   (20)       v10to26   97  97  34 62   8683  [ 224  416  600  700 ]  [  3  5  3 13 15  5 15 10 ] ]
        [ (full)   (21)       v10to26  101 101  28 50   9252  [ 224  442  644  750 ]  [  4  4 17  0 17  6 19  6 ] ]
        [ (full)   (22)       v10to26  105 105  26 50  10068  [ 252  476  690  816 ]  [  2  7 17  0  7 16 34  0 ] ]
        [ (full)   (23)       v10to26  109 109  30 54  10916  [ 270  504  750  900 ]  [  4  5  4 14 11 14 16 14 ] ]
        [ (full)   (24)       v10to26  113 113  28 54  11796  [ 300  560  810  960 ]  [  6  4  6 14 11 16 30  2 ] ]
        [ (full)   (25)       v10to26  117 117  32 58  12708  [ 312  588  870 1050 ]  [  8  4  8 13  7 22 22 13 ] ]
        [ (full)   (26)       v10to26  121 121  30 58  13652  [ 336  644  952 1110 ]  [ 10  2 19  4 28  6 33  4 ] ]
        [ (full)   (27)       v27to40  125 125  34 62  14628  [ 360  700 1020 1200 ]  [  8  4 22  3  8 26 12 28 ] ]
        [ (full)   (28)       v27to40  129 129  26 50  15371  [ 390  728 1050 1260 ]  [  3 10  3 23  4 31 11 31 ] ]
        [ (full)   (29)       v27to40  133 133  30 54  16411  [ 420  784 1140 1350 ]  [  7  7 21  7  1 37 19 26 ] ]
        [ (full)   (30)       v27to40  137 137  26 52  17483  [ 450  812 1200 1440 ]  [  5 10 19 10 15 25 23 25 ] ]
        [ (full)   (31)       v27to40  141 141  30 56  18587  [ 480  868 1290 1530 ]  [ 13  3  2 29 42  1 23 28 ] ]
        [ (full)   (32)       v27to40  145 145  34 60  19723  [ 510  924 1350 1620 ]  [ 17  0 10 23 10 35 19 35 ] ]
        [ (full)   (33)       v27to40  149 149  30 58  20891  [ 540  980 1440 1710 ]  [ 17  1 14 21 29 19 11 46 ] ]
        [ (full)   (34)       v27to40  153 153  34 62  22091  [ 570 1036 1530 1800 ]  [ 13  6 14 23 44  7 59  1 ] ]
        [ (full)   (35)       v27to40  157 157  30 54  23008  [ 570 1064 1590 1890 ]  [ 12  7 12 26 39 14 22 41 ] ]
        [ (full)   (36)       v27to40  161 161  24 50  24272  [ 600 1120 1680 1980 ]  [  6 14  6 34 46 10  2 64 ] ]
        [ (full)   (37)       v27to40  165 165  28 54  25568  [ 630 1204 1770 2100 ]  [ 17  4 29 14 49 10 24 46 ] ]
        [ (full)   (38)       v27to40  169 169  32 58  26896  [ 660 1260 1860 2220 ]  [  4 18 13 32 48 14 42 32 ] ]
        [ (full)   (39)       v27to40  173 173  26 54  28256  [ 720 1316 1950 2310 ]  [ 20  4 40  7 43 22 10 67 ] ]
        [ (full)   (40)       v27to40  177 177  30 58  29648  [ 750 1372 2040 2430 ]  [ 19  6 18 31 34 34 20 61 ] ]
        [ (rmqr)   (R7x43)    vR7x43     7  43  22 99    104  [  99    7   99   10 ]  [ -1 -1  1  0 -1 -1  1  0 ] ]
        [ (rmqr)   (R7x59)    vR7x59     7  59  20 40    171  [  99    9   99   14 ]  [ -1 -1  1  0 -1 -1  1  0 ] ]
        [ (rmqr)   (R7x77)    vR7x77     7  77  26 52    261  [  99   12   99   22 ]  [ -1 -1  1  0 -1 -1  1  0 ] ]
        [ (rmqr)   (R7x99)    vR7x99     7  99  24 50    358  [  99   16   99   30 ]  [ -1 -1  1  0 -1 -1  1  0 ] ]
        [ (rmqr)   (R7x139)   vR7x139    7 139  28 56    545  [  99   24   99   44 ]  [ -1 -1  1  0 -1 -1  2  0 ] ]
        [ (rmqr)   (R9x43)    vR9x43     9  43  22 99    170  [  99    9   99   14 ]  [ -1 -1  1  0 -1 -1  1  0 ] ]
        [ (rmqr)   (R9x59)    vR9x59     9  59  20 40    267  [  99   12   99   22 ]  [ -1 -1  1  0 -1 -1  1  0 ] ]
        [ (rmqr)   (R9x77)    vR9x77     9  77  26 52    393  [  99   18   99   32 ]  [ -1 -1  1  0 -1 -1  1  1 ] ]
        [ (rmqr)   (R9x99)    vR9x99     9  99  24 50    532  [  99   24   99   44 ]  [ -1 -1  1  0 -1 -1  2  0 ] ]
        [ (rmqr)   (R9x139)   vR9x139    9 139  28 56    797  [  99   36   99   66 ]  [ -1 -1  1  1 -1 -1  3  0 ] ]
        [ (rmqr)   (R11x27)   vR11x27   11  27  98 99    122  [  99    8   99   10 ]  [ -1 -1  1  0 -1 -1  1  0 ] ]
        [ (rmqr)   (R11x43)   vR11x43   11  43  22 99    249  [  99   12   99   20 ]  [ -1 -1  1  0 -1 -1  1  0 ] ]
        [ (rmqr)   (R11x59)   vR11x59   11  59  20 40    376  [  99   16   99   32 ]  [ -1 -1  1  0 -1 -1  1  1 ] ]
        [ (rmqr)   (R11x77)   vR11x77   11  77  26 52    538  [  99   24   99   44 ]  [ -1 -1  1  0 -1 -1  1  1 ] ]
        [ (rmqr)   (R11x99)   vR11x99   11  99  24 50    719  [  99   32   99   60 ]  [ -1 -1  1  1 -1 -1  1  1 ] ]
        [ (rmqr)   (R11x139)  vR11x139  11 139  28 56   1062  [  99   48   99   90 ]  [ -1 -1  2  0 -1 -1  3  0 ] ]
        [ (rmqr)   (R13x27)   vR13x27   13  27  98 99    172  [  99    9   99   14 ]  [ -1 -1  1  0 -1 -1  1  0 ] ]
        [ (rmqr)   (R13x43)   vR13x43   13  43  22 99    329  [  99   14   99   28 ]  [ -1 -1  1  0 -1 -1  1  0 ] ]
        [ (rmqr)   (R13x59)   vR13x59   13  59  20 40    486  [  99   22   99   40 ]  [ -1 -1  1  0 -1 -1  2  0 ] ]
        [ (rmqr)   (R13x77)   vR13x77   13  77  26 52    684  [  99   32   99   56 ]  [ -1 -1  1  1 -1 -1  1  1 ] ]
        [ (rmqr)   (R13x99)   vR13x99   13  99  24 50    907  [  99   40   99   78 ]  [ -1 -1  1  1 -1 -1  1  2 ] ]
        [ (rmqr)   (R13x139)  vR13x139  13 139  28 56   1328  [  99   60   99  112 ]  [ -1 -1  2  1 -1 -1  2  2 ] ]
        [ (rmqr)   (R15x43)   vR15x43   15  43  22 99    409  [  99   18   99   36 ]  [ -1 -1  1  0 -1 -1  1  1 ] ]
        [ (rmqr)   (R15x59)   vR15x59   15  59  20 40    596  [  99   26   99   48 ]  [ -1 -1  1  0 -1 -1  2  0 ] ]
        [ (rmqr)   (R15x77)   vR15x77   15  77  26 52    830  [  99   36   99   72 ]  [ -1 -1  1  1 -1 -1  2  1 ] ]
        [ (rmqr)   (R15x99)   vR15x99   15  99  24 50   1095  [  99   48   99   88 ]  [ -1 -1  2  0 -1 -1  4  0 ] ]
        [ (rmqr)   (R15x139)  vR15x139  15 139  28 56   1594  [  99   72   99  130 ]  [ -1 -1  2  1 -1 -1  1  4 ] ]
        [ (rmqr)   (R17x43)   vR17x43   17  43  22 99    489  [  99   22   99   40 ]  [ -1 -1  1  0 -1 -1  1  1 ] ]
        [ (rmqr)   (R17x59)   vR17x59   17  59  20 40    706  [  99   32   99   60 ]  [ -1 -1  2  0 -1 -1  2  0 ] ]
        [ (rmqr)   (R17x77)   vR17x77   17  77  26 52    976  [  99   44   99   84 ]  [ -1 -1  2  0 -1 -1  1  2 ] ]
        [ (rmqr)   (R17x99)   vR17x99   17  99  24 50   1283  [  99   60   99  104 ]  [ -1 -1  2  1 -1 -1  4  0 ] ]
        [ (rmqr)   (R17x139)  vR17x139  17 139  28 56   1860  [  99   80   99  156 ]  [ -1 -1  4  0 -1 -1  2  4 ] ]
    ] def
} ctxdef

    /eclval (LMQH) eclevel search pop length exch pop exch pop def
    0 1 metrics length 1 sub {
        /i exch def
        /m metrics i get def
        /frmt m 0 get def                             % Format of the symbol
        /vers m 1 get def                             % Version of symbol
        /vergrp m 2 get def                           % Version group
        /verind i 44 sub def                          % Version indicator for rMQR format info
        /rows m 3 get def                             % Length of side
        /cols m 4 get def                             % Length of side
        /asp2 m 5 get def                             % Position of second alignment symbol
        /asp3 m 6 get def                             % Position of third alignment symbol
        /nmod m 7 get def                             % Number of modules
        /ncws nmod 8 idiv def                         % Total number of codewords
        /rbit nmod 8 mod def                          % Number of remainder bits
        /lc4b false def                               % Last data codeword is 4 bits long
        vers (M1) eq vers (M3) eq or {                % Adjustments for M1 and M3 symbols
            /ncws ncws 1 add def
            /rbit 0 def
            /lc4b true def
        } if
        /ecws m 8 get eclval get def                  % Number of error correction codewords
        /dcws ncws ecws sub def                       % Number of data codewords
        /dmod dcws 8 mul lc4b {4} {0} ifelse sub def  % Number of data modules
        /ecb1 m 9 get eclval 2 mul get def            % First error correction blocks
        /ecb2 m 9 get eclval 2 mul 1 add get def      % Second error correction blocks
        /okay true def
        format frmt ne {/okay false def} if           % The format must match that supplied
        frmt (micro) eq fnc1first and {/okay false def} if  % FNC1 mode is only available in full and rmqr
        version (unset) ne version vers ne and {/okay false def} if  % The version must match that supplied
        ecb1 -1 eq ecb2 -1 eq or {/okay false def} if % Error correction level must be valid
        /verbits msgbits vergrp get def
        verbits -1 eq {                               % Bitstream must be available
            /okay false def
        } {
            verbits length dmod gt {/okay false def} if  % and fit into data modules
        } ifelse
        /term (000000000) 0 termlens vergrp get getinterval def
        okay {exit} if
    } for

    okay not {
        /bwipp.qrcodeNoValidSymbol (Maximum length exceeded or invalid content) //raiseerror exec
    } if

    /format frmt def
    /version vers def
    /msgbits verbits def
    /dcpb dcws ecb1 ecb2 add idiv def                 % Base data codewords per block
    /ecpb ncws ecb1 ecb2 add idiv dcpb sub def        % Error correction codewords per block

    % Complete the message bits by adding the terminator, truncated if necessary
    /term term 0 dmod msgbits length sub term length 2 copy gt {exch} if pop getinterval def
    msgbits length term length add string
    dup 0 msgbits putinterval
    dup msgbits length term putinterval
    /msgbits exch def

    % Expand the message bits by adding padding as necessary
    /pad dmod string def
    0 1 pad length 1 sub {pad exch 48 put} for
    pad 0 msgbits putinterval
    /padnum 0 def
    msgbits length 8 div ceiling 8 mul cvi 8 dmod lc4b {5} {1} ifelse sub {
        pad exch padstrs padnum get putinterval
        /padnum padnum 1 add 2 mod def
    } for

    % Evaluate the padded message into codewords
    /cws dcws array def
    0 1 cws length 1 sub {
        /c exch def
        /bpcw 8 def
        lc4b c cws length 1 sub eq and {/bpcw 4 def} if
        /cwb pad c 8 mul bpcw getinterval def
        /cw 0 def
        0 1 bpcw 1 sub {
            /i exch def
            /cw cw 2 bpcw i sub 1 sub exp cvi cwb i get 48 sub mul add def
        } for
        cws c cw put
    } for

    % Short final data byte in M1 and M3 symbols has high-order value
    lc4b {cws cws length 1 sub 2 copy get 4 bitshift put} if

    options /debugcws known { /bwipp.debugcws cws //raiseerror exec } if

    % Calculate the log and anti-log tables
{
    /rsalog [ 1 255 { dup 2 mul dup 256 ge {285 xor} if } repeat ] def
    /rslog 256 array def
    1 1 255 {dup rsalog exch get exch rslog 3 1 roll put} for
} ctxdef

    % Function to calculate the product in the field
    /rsprod {
        2 copy 0 ne exch 0 ne and {
            rslog exch get exch rslog exch get add 255 mod rsalog exch get
        } {
            pop pop 0
        } ifelse
    } def

    % Generate the coefficients for the Reed-Solomon algorithm
    /coeffs [ 1 ecpb {0} repeat ] def
    0 1 ecpb 1 sub {
        /i exch def
        coeffs i 1 add coeffs i get put
        i -1 1 {
            /j exch def
            coeffs j coeffs j 1 sub get coeffs j get rsalog i get rsprod xor put
        } for
        coeffs 0 coeffs 0 get rsalog i get rsprod put
    } for
    /coeffs coeffs 0 coeffs length 1 sub getinterval def

    % Reed-Solomon algorithm to derive the error correction codewords
    /rscodes {
        /rscws exch def
        /rsnd rscws length def
        /rscws [ rscws {} forall ecpb {0} repeat ] def
        0 1 rsnd 1 sub {
            /m exch def
            /k rscws m get def
            0 1 ecpb 1 sub {
                /j exch def
                rscws m j add 1 add coeffs ecpb j sub 1 sub get k rsprod rscws m j add 1 add get xor put
            } for
        } for
        rscws rsnd ecpb getinterval
    } def

    % Divide codewords into two groups of blocks and calculate the error correction codewords
    /dcwsb ecb1 ecb2 add array def
    /ecwsb ecb1 ecb2 add array def
    0 1 ecb1 1 sub {  % First group of blocks has smaller number of data codewords
        /i exch def
        dcwsb i cws i dcpb mul dcpb getinterval put
        ecwsb i dcwsb i get rscodes put
    } for
    0 1 ecb2 1 sub {  % Second group of blocks has larger number of data codewords
        /i exch def
        dcwsb ecb1 i add cws ecb1 dcpb mul i dcpb 1 add mul add dcpb 1 add getinterval put
        ecwsb ecb1 i add dcwsb ecb1 i add get rscodes put
    } for

    % Reassemble the codewords
    /cws ncws array def
    /cw 0 def
    0 1 dcpb {  % Interleave the data codeword blocks
        /i exch def
        0 1 ecb1 ecb2 add 1 sub {
            /j exch def
            i dcwsb j get length lt {  % Ignore the end of short blocks
                cws cw dcwsb j get i get put
                /cw cw 1 add def
            } if
        } for
    } for
    0 1 ecpb 1 sub {  % Interleave the error codeword blocks
        /i exch def
        0 1 ecb1 ecb2 add 1 sub {
            /j exch def
            cws cw ecwsb j get i get put
            /cw cw 1 add def
        } for
    } for

    % Extend codewords by one if there are remainder bits
    rbit 0 gt {
        /pad cws length 1 add array def
        pad 0 cws putinterval
        pad pad length 1 sub 0 put
        /cws pad def
    } if

    % Fixups for the short final data byte in M1 and M3 symbols
    lc4b {
        cws dcws 1 sub 2 copy get -4 bitshift put
        dcws 1 sub 1 ncws 2 sub {
            /i exch def
            cws i cws i get 15 and 4 bitshift put
            cws i cws i 1 add get -4 bitshift 15 and cws i get or put
        } for
        cws ncws 1 sub cws ncws 1 sub get 15 and 4 bitshift put
    } if

    options /debugecc known { /bwipp.debugecc cws //raiseerror exec } if

    % Create the bitmap
    /pixs [ rows cols mul {-1} repeat ] def
    /qmv {cols mul add} def

    % Timing patterns
    format (full) eq {
        8 1 cols 9 sub {
            /i exch def
            pixs i 6 qmv i 1 add 2 mod put
            pixs 6 i qmv i 1 add 2 mod put
        } for
    } if
    format (micro) eq {
        8 1 cols 1 sub {
            /i exch def
            pixs i 0 qmv i 1 add 2 mod put
            pixs 0 i qmv i 1 add 2 mod put
        } for
    } if
    format (rmqr) eq {
        3 1 cols 4 sub {  % Along top and bottom
            /i exch def
            pixs i 0 qmv i 1 add 2 mod put
            pixs i rows 1 sub qmv i 1 add 2 mod put
        } for
        3 1 rows 4 sub {  % Along left and right
            /i exch def
            pixs 0 i qmv i 1 add 2 mod put
            pixs cols 1 sub i qmv i 1 add 2 mod put
        } for
        asp2 1 sub asp3 asp2 sub cols 13 sub {  % Down interior
            /i exch def
            3 1 rows 4 sub {
                /j exch def
                pixs i j qmv j 1 add 2 mod put
            } for
        } for
    } if

    % Finder patterns
{
    /fpat [
        [ 1 1 1 1 1 1 1 0 ]
        [ 1 0 0 0 0 0 1 0 ]
        [ 1 0 1 1 1 0 1 0 ]
        [ 1 0 1 1 1 0 1 0 ]
        [ 1 0 1 1 1 0 1 0 ]
        [ 1 0 0 0 0 0 1 0 ]
        [ 1 1 1 1 1 1 1 0 ]
        [ 0 0 0 0 0 0 0 0 ]
    ] def
    /fsubpat [
        [ 1 1 1 1 1 9 9 9 ]
        [ 1 0 0 0 1 9 9 9 ]
        [ 1 0 1 0 1 9 9 9 ]
        [ 1 0 0 0 1 9 9 9 ]
        [ 1 1 1 1 1 9 9 9 ]
        [ 9 9 9 9 9 9 9 9 ]
        [ 9 9 9 9 9 9 9 9 ]
        [ 9 9 9 9 9 9 9 9 ]
    ] def
    /fcorpat [
        [ 1 1 1 9 9 9 9 9 ]
        [ 1 0 9 9 9 9 9 9 ]
        [ 1 9 9 9 9 9 9 9 ]
        [ 9 9 9 9 9 9 9 9 ]
        [ 9 9 9 9 9 9 9 9 ]
        [ 9 9 9 9 9 9 9 9 ]
        [ 9 9 9 9 9 9 9 9 ]
        [ 9 9 9 9 9 9 9 9 ]
    ] def
    /fnullpat [
        [ 9 9 9 9 9 9 9 9 ]
        [ 9 9 9 9 9 9 9 9 ]
        [ 9 9 9 9 9 9 9 9 ]
        [ 9 9 9 9 9 9 9 9 ]
        [ 9 9 9 9 9 9 9 9 ]
        [ 9 9 9 9 9 9 9 9 ]
        [ 9 9 9 9 9 9 9 9 ]
        [ 9 9 9 9 9 9 9 9 ]
    ] def
    /fpatmap <<
        %          TL     TR       BL       BR
        (full)  [ fpat fpat     fpat     fnullpat ]
        (micro) [ fpat fnullpat fnullpat fnullpat ]
        (rmqr)  [ fpat fcorpat  fcorpat  fsubpat  ]
    >> def
} ctxdef
    /fpats fpatmap format get def
    0 1 7 {
      /y exch def
      0 1 7 {
        /x exch def
        /fpb0 fpats 0 get y get x get def
        /fpb1 fpats 1 get y get x get def
        /fpb2 fpats 2 get y get x get def
        /fpb3 fpats 3 get y get x get def
        fpb0 9 ne y rows lt and {pixs x y qmv fpb0 put} if
        fpb1 9 ne {pixs cols x sub 1 sub y qmv fpb1 put} if
        fpb2 9 ne {pixs x rows y sub 1 sub qmv fpb2 put} if
        fpb3 9 ne {pixs cols x sub 1 sub rows y sub 1 sub qmv fpb3 put} if
      } for
    } for

    % Alignment patterns
{
    /algnpatfull [
        [ 1 1 1 1 1 ]
        [ 1 0 0 0 1 ]
        [ 1 0 1 0 1 ]
        [ 1 0 0 0 1 ]
        [ 1 1 1 1 1 ]
    ] def
    /algnpatrmqr [
        [ 1 1 1 9 9 ]
        [ 1 0 1 9 9 ]
        [ 1 1 1 9 9 ]
        [ 9 9 9 9 9 ]
        [ 9 9 9 9 9 ]
    ] def
} ctxdef

    /putalgnpat {
        /py exch def
        /px exch def
        0 1 4 {
            /pb exch def
            0 1 4 {
                /pa exch def
                /algnb algnpat pb get pa get def
                algnb 9 ne {
                    pixs px pa add py pb add qmv algnb put
                } if
            } for
        } for
    } def
    format (full) eq {
        /algnpat algnpatfull def
        asp2 2 sub asp3 asp2 sub cols 13 sub {
            /i exch def
            i 4 putalgnpat
            4 i putalgnpat
        } for
        asp2 2 sub asp3 asp2 sub cols 9 sub {
            /x exch def
            asp2 2 sub asp3 asp2 sub rows 9 sub {
                /y exch def
                x y putalgnpat
            } for
        } for
    } if
    format (rmqr) eq {
        /algnpat algnpatrmqr def
        asp2 2 sub asp3 asp2 sub cols 13 sub {
            /i exch def
            i 0 putalgnpat
            i rows 3 sub putalgnpat
        } for
    } if

    % Format information modules
{
    /formatmapmicro [
            [ [ 1 8 ] ]  [ [ 2 8 ] ]  [ [ 3 8 ] ]  [ [ 4 8 ] ]  [ [ 5 8 ] ]
            [ [ 6 8 ] ]  [ [ 7 8 ] ]  [ [ 8 8 ] ]  [ [ 8 7 ] ]  [ [ 8 6 ] ]
            [ [ 8 5 ] ]  [ [ 8 4 ] ]  [ [ 8 3 ] ]  [ [ 8 2 ] ]  [ [ 8 1 ] ]
    ] def
} ctxdef
    /formatmap <<
        (full) [
            [ [ 0 8 ] [ 8 cols 1 sub ] ]  [ [ 1 8 ] [ 8 cols 2 sub ] ]  [ [ 2 8 ] [ 8 cols 3 sub ] ]
            [ [ 3 8 ] [ 8 cols 4 sub ] ]  [ [ 4 8 ] [ 8 cols 5 sub ] ]  [ [ 5 8 ] [ 8 cols 6 sub ] ]
            [ [ 7 8 ] [ 8 cols 7 sub ] ]  [ [ 8 8 ] [ cols 8 sub 8 ] ]  [ [ 8 7 ] [ cols 7 sub 8 ] ]
            [ [ 8 5 ] [ cols 6 sub 8 ] ]  [ [ 8 4 ] [ cols 5 sub 8 ] ]  [ [ 8 3 ] [ cols 4 sub 8 ] ]
            [ [ 8 2 ] [ cols 3 sub 8 ] ]  [ [ 8 1 ] [ cols 2 sub 8 ] ]  [ [ 8 0 ] [ cols 1 sub 8 ] ]
        ]
        (micro) formatmapmicro
        (rmqr) [
            [ [ 11 3 ] [ cols 3 sub rows 6 sub ] ]  [ [ 11 2 ] [ cols 4 sub rows 6 sub ] ]  [ [ 11 1 ] [ cols 5 sub rows 6 sub ] ]
            [ [ 10 5 ] [ cols 6 sub rows 2 sub ] ]  [ [ 10 4 ] [ cols 6 sub rows 3 sub ] ]  [ [ 10 3 ] [ cols 6 sub rows 4 sub ] ]
            [ [ 10 2 ] [ cols 6 sub rows 5 sub ] ]  [ [ 10 1 ] [ cols 6 sub rows 6 sub ] ]  [ [  9 5 ] [ cols 7 sub rows 2 sub ] ]
            [ [  9 4 ] [ cols 7 sub rows 3 sub ] ]  [ [  9 3 ] [ cols 7 sub rows 4 sub ] ]  [ [  9 2 ] [ cols 7 sub rows 5 sub ] ]
            [ [  9 1 ] [ cols 7 sub rows 6 sub ] ]  [ [  8 5 ] [ cols 8 sub rows 2 sub ] ]  [ [  8 4 ] [ cols 8 sub rows 3 sub ] ]
            [ [  8 3 ] [ cols 8 sub rows 4 sub ] ]  [ [  8 2 ] [ cols 8 sub rows 5 sub ] ]  [ [  8 1 ] [ cols 8 sub rows 6 sub ] ]
        ]
    >> format get def
    formatmap {
        { {} forall qmv pixs exch 1 put } forall
    } forall

    % Version information modules
    format (full) eq cols 45 ge and {
        /versionmap [
            [ [ cols  9 sub 5 ] [ 5 cols  9 sub ] ]  [ [ cols 10 sub 5 ] [ 5 cols 10 sub ] ]
            [ [ cols 11 sub 5 ] [ 5 cols 11 sub ] ]  [ [ cols  9 sub 4 ] [ 4 cols  9 sub ] ]
            [ [ cols 10 sub 4 ] [ 4 cols 10 sub ] ]  [ [ cols 11 sub 4 ] [ 4 cols 11 sub ] ]
            [ [ cols  9 sub 3 ] [ 3 cols  9 sub ] ]  [ [ cols 10 sub 3 ] [ 3 cols 10 sub ] ]
            [ [ cols 11 sub 3 ] [ 3 cols 11 sub ] ]  [ [ cols  9 sub 2 ] [ 2 cols  9 sub ] ]
            [ [ cols 10 sub 2 ] [ 2 cols 10 sub ] ]  [ [ cols 11 sub 2 ] [ 2 cols 11 sub ] ]
            [ [ cols  9 sub 1 ] [ 1 cols  9 sub ] ]  [ [ cols 10 sub 1 ] [ 1 cols 10 sub ] ]
            [ [ cols 11 sub 1 ] [ 1 cols 11 sub ] ]  [ [ cols  9 sub 0 ] [ 0 cols  9 sub ] ]
            [ [ cols 10 sub 0 ] [ 0 cols 10 sub ] ]  [ [ cols 11 sub 0 ] [ 0 cols 11 sub ] ]
        ] def
    } {
        /versionmap [] def
    } ifelse
    versionmap {
        { {} forall qmv pixs exch 0 put } forall
    } forall

    % Reserve the solitary dark module in full symbols
    format (full) eq {
        pixs 8 rows 8 sub qmv 0 put
    } if

    % Calculate the mask patterns
    /maskfuncs <<
        (full) [
            {add 2 mod}
            {exch pop 2 mod}
            {pop 3 mod}
            {add 3 mod}
            {2 idiv exch 3 idiv add 2 mod}
            {mul dup 2 mod exch 3 mod add}
            {mul dup 2 mod exch 3 mod add 2 mod}
            {2 copy mul 3 mod 3 1 roll add 2 mod add 2 mod}
        ]
        (micro) [
            {exch pop 2 mod}
            {2 idiv exch 3 idiv add 2 mod}
            {mul dup 2 mod exch 3 mod add 2 mod}
            {2 copy mul 3 mod 3 1 roll add 2 mod add 2 mod}
        ]
        (rmqr) [
            {2 idiv exch 3 idiv add 2 mod}
        ]
    >> format get def
    mask -1 ne {  % User specifies a mask
        /maskfuncs [maskfuncs mask 1 sub get] def
        /bestmaskval mask 1 sub def
    } if
    /masks maskfuncs length array def
    0 1 masks length 1 sub {
        /m exch def
        /mask rows cols mul array def
        0 1 rows 1 sub {
            /j exch def
            0 1 cols 1 sub {
                /i exch def
                i j maskfuncs m get exec 0 eq
                pixs i j qmv get -1 eq and {1} {0} ifelse
                mask i j qmv 3 -1 roll put
            } for
        } for
        masks m mask put
    } for

    % Walk the symbol placing the bitstream
    /posx cols format (rmqr) ne {1} {2} ifelse sub def
    /posy rows 1 sub def
    /dir -1 def  % -1 is upwards, 1 is downwards
    /col 1 def   % 0 is left bit, 1 is right bit
    /num 0 def
    { % loop
        posx 0 lt {exit} if
        pixs posx posy qmv get -1 eq {
            cws num 8 idiv get 7 num 8 mod sub neg bitshift 1 and
            pixs posx posy qmv 3 -1 roll put
            /num num 1 add def
        } if
        col 1 eq {
            /col 0 def
            /posx posx 1 sub def
        } {
            /col 1 def
            /posx posx 1 add def
            /posy posy dir add def
            posy 0 lt posy rows ge or {  % Turn around at top and bottom
                /dir dir -1 mul def
                /posy posy dir add def
                /posx posx 2 sub def
                % Hop over the timing pattern in full size symbols
                format (full) eq posx 6 eq and {/posx posx 1 sub def} if
            } if
        } ifelse
    } loop

    % Evaluate runlength encoded rows or columns in full symbols
    /evalfulln1n3 {
        /scrle exch def
        % Detect runs of 5 or more like modules
        /scr1 0 scrle { dup 5 ge {add 2 sub dup} if pop } forall def
        % Detect 1:1:3:1:1 ratio next to 4 modules of whitespace
        /scr3 0 def
        3 2 scrle length 3 sub {  % Scan odd (dark) runs within bounds
            /j exch def
            scrle j get 3 mod 0 eq {  % Multiple of 3 black modules
                /fact scrle j get 3 idiv def
                scrle j 2 sub 5 getinterval {fact eq} forall and exch pop and and {
                    j 3 eq j 4 add scrle length ge or {  % At either extent of run
                        /scr3 scr3 40 add def
                    } {  % Bounded by dark modules
                        scrle j 3 sub get 4 ge scrle j 3 add get 4 ge or {
                            /scr3 scr3 40 add def
                        } if
                    } ifelse
                } if
            } if
        } for
        scr1 scr3
    } def

    % Evaluation algorithm for full symbols
    /evalfull {
        /sym exch def

        /n1 0 def /n2 0 def /n3 0 def
        /rle cols 1 add array def
        /lastpairs cols array def
        /thispairs cols array def
        /colsadd1 cols 1 add def
        0 1 cols 1 sub {
            /i exch def

            % Runlength encode (light, dark, light, ...) and evaluate each column
            mark 0 0
            i cols dup dup mul 1 sub {
                sym exch get exch 1 index eq {exch 1 add exch} {1 exch} ifelse
            } for
            pop
            rle 0 counttomark 2 sub getinterval astore
            evalfulln1n3 n3 add /n3 exch def n1 add /n1 exch def
            pop

            % Runlength encode (light, dark, light, ...) and evaluate each row
            /symrow sym i cols mul cols getinterval def
            mark 0 0
            symrow {
                exch 1 index eq {exch 1 add exch} {1 exch} ifelse
            } forall
            pop
            rle 0 counttomark 2 sub getinterval astore
            evalfulln1n3 n3 add /n3 exch def n1 add /n1 exch def
            pop

            % Count and score same coloured blocks
            /lastpairs thispairs /thispairs lastpairs def def
            symrow 0 get 1 eq {0} {1} ifelse
            symrow {exch 1 index add exch} forall
            pop
            thispairs astore pop
            i 0 gt {
                mark
                lastpairs aload pop thispairs aload pop
                n2 cols { exch colsadd1 index add 3 and 0 eq {3 add} if } repeat
                /n2 exch def
                cleartomark
            } if

        } for

        % Score dark/light imbalance
        /dark 0 sym {add} forall def
        /n4 dark 100 mul cols dup mul div 50 sub abs 5 div cvi 10 mul def

        n1 n2 add n3 add n4 add
    } def

    % Evaluation algorithm for micro symbols
    /evalmicro {
        /sym exch def
        /dkrhs 0 def /dkbot 0 def
        1 1 cols 1 sub {
            /i exch def
            /dkrhs dkrhs sym cols 1 sub i qmv get add def
            /dkbot dkbot sym i cols 1 sub qmv get add def
        } for
        dkrhs dkbot le {
            dkrhs 16 mul dkbot add neg
        } {
            dkbot 16 mul dkrhs add neg
        } ifelse
    } def

    % Evaluate the masked symbols to find the most suitable
    /bestscore 999999999 def
    0 1 masks length 1 sub {
        /m exch def
        /masksym rows cols mul array def
        0 1 rows cols mul 1 sub {
            /i exch def
            masksym i pixs i get masks m get i get xor put
        } for
        masks length 1 ne {  % Not rMQR nor user-specified mask
            format (full) eq {
                masksym evalfull /score exch def
            } {
                masksym evalmicro /score exch def
            } ifelse
            score bestscore lt {
                /bestsym masksym def
                /bestmaskval m def
                /bestscore score def
            } if
        } {
            /bestsym masksym def
        } ifelse
    } for
    /pixs bestsym def

    % Set the solitary dark module in full symbols
    format (full) eq {
        pixs 8 cols 8 sub qmv 1 put
    } if

    % Add the format information
{
    /fmtvalsfull [
        16#5412 16#5125 16#5e7c 16#5b4b 16#45f9 16#40ce 16#4f97 16#4aa0
        16#77c4 16#72f3 16#7daa 16#789d 16#662f 16#6318 16#6c41 16#6976
        16#1689 16#13be 16#1ce7 16#19d0 16#0762 16#0255 16#0d0c 16#083b
        16#355f 16#3068 16#3f31 16#3a06 16#24b4 16#2183 16#2eda 16#2bed
    ] def
    /fmtvalsmicro [
        16#4445 16#4172 16#4e2b 16#4b1c 16#55ae 16#5099 16#5fc0 16#5af7
        16#6793 16#62a4 16#6dfd 16#68ca 16#7678 16#734f 16#7c16 16#7921
        16#06de 16#03e9 16#0cb0 16#0987 16#1735 16#1202 16#1d5b 16#186c
        16#2508 16#203f 16#2f66 16#2a51 16#34e3 16#31d4 16#3e8d 16#3bba
    ] def
    /fmtvalsrmqr1 [
        16#1fab2 16#1e597 16#1dbdd 16#1c4f8 16#1b86c 16#1a749 16#19903 16#18626
        16#17f0e 16#1602b 16#15e61 16#14144 16#13dd0 16#122f5 16#11cbf 16#1039a
        16#0f1ca 16#0eeef 16#0d0a5 16#0cf80 16#0b314 16#0ac31 16#0927b 16#08d5e
        16#07476 16#06b53 16#05519 16#04a3c 16#036a8 16#0298d 16#017c7 16#008e2
        16#3f367 16#3ec42 16#3d208 16#3cd2d 16#3b1b9 16#3ae9c 16#390d6 16#38ff3
        16#376db 16#369fe 16#357b4 16#34891 16#33405 16#32b20 16#3156a 16#30a4f
        16#2f81f 16#2e73a 16#2d970 16#2c655 16#2bac1 16#2a5e4 16#29bae 16#2848b
        16#27da3 16#26286 16#25ccc 16#243e9 16#23f7d 16#22058 16#21e12 16#20137
    ] def
    /fmtvalsrmqr2 [
        16#20a7b 16#2155e 16#22b14 16#23431 16#248a5 16#25780 16#269ca 16#276ef
        16#28fc7 16#290e2 16#2aea8 16#2b18d 16#2cd19 16#2d23c 16#2ec76 16#2f353
        16#30103 16#31e26 16#3206c 16#33f49 16#343dd 16#35cf8 16#362b2 16#37d97
        16#384bf 16#39b9a 16#3a5d0 16#3baf5 16#3c661 16#3d944 16#3e70e 16#3f82b
        16#003ae 16#01c8b 16#022c1 16#03de4 16#04170 16#05e55 16#0601f 16#07f3a
        16#08612 16#09937 16#0a77d 16#0b858 16#0c4cc 16#0dbe9 16#0e5a3 16#0fa86
        16#108d6 16#117f3 16#129b9 16#1369c 16#14a08 16#1552d 16#16b67 16#17442
        16#18d6a 16#1924f 16#1ac05 16#1b320 16#1cfb4 16#1d091 16#1eedb 16#1f1fe
    ] def
} ctxdef
    format (full) eq {
        /ecid (MLHQ) eclevel search pop length exch pop exch pop def
        /fmtval fmtvalsfull ecid 3 bitshift bestmaskval add get def
        0 1 formatmap length 1 sub {
            /i exch def
            formatmap i get {
                pixs exch aload pop qmv fmtval 14 i sub neg bitshift 1 and put
            } forall
        } for
    } if
    format (micro) eq {
        /symid [ [0] [1 2] [3 4] [5 6 7] ] cols 11 sub 2 idiv get eclval get def
        /fmtval fmtvalsmicro symid 2 bitshift bestmaskval add get def
        0 1 formatmap length 1 sub {
            /i exch def
            pixs formatmap i get 0 get aload pop qmv fmtval 14 i sub neg bitshift 1 and put
        } for
    } if
    format (rmqr) eq {
        /fmtvalu (MH) eclevel search pop length exch pop exch pop 5 bitshift verind add def
        /fmtval1 fmtvalsrmqr1 fmtvalu get def
        /fmtval2 fmtvalsrmqr2 fmtvalu get def
        0 1 formatmap length 1 sub {
            /i exch def
            pixs formatmap i get 0 get aload pop qmv fmtval1 17 i sub neg bitshift 1 and put
            pixs formatmap i get 1 get aload pop qmv fmtval2 17 i sub neg bitshift 1 and put
        } for
    } if

    % Add the version information
{
    /vervals [
        16#07c94 16#085bc 16#09a99 16#0a4d3 16#0bbf6 16#0c762 16#0d847
        16#0e60d 16#0f928 16#10b78 16#1145d 16#12a17 16#13532 16#149a6
        16#15683 16#168c9 16#177ec 16#18ec4 16#191e1 16#1afab 16#1b08e
        16#1cc1a 16#1d33f 16#1ed75 16#1f250 16#209d5 16#216fd 16#228ba
        16#2379f 16#24b0b 16#2542e 16#26a64 16#27541 16#28c69
    ] def
} ctxdef
    format (full) eq cols 45 ge and {
        /verval vervals cols 17 sub 4 idiv 7 sub get def
        0 1 versionmap length 1 sub {
            /i exch def
            versionmap i get {
                pixs exch {} forall qmv verval 17 i sub neg bitshift 1 and put
            } forall
        } for
    } if

    % Return the arguments
    <<
    /ren //renmatrix
    /pixs pixs
    /pixx cols
    /pixy rows
    /height rows 2 mul 72 div
    /width cols 2 mul 72 div
    /opt options
    >>

    dontdraw not //renmatrix if

    //unloadctx exec

    end

}
[/barcode] {null def} forall
bind def
/qrcode dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER qrcode--
