%!PS

/_isEqual {
    2 copy type exch type ne {/testError pstack quit} if
    dup type dup /arraytype eq exch /stringtype eq or {
        2 copy
        length exch length ne {/testError pstack quit} if
        dup length 1 sub 0 exch 1 exch {
            dup 3 index exch get exch 2 index exch get  % ... a b
            2 copy type /realtype eq exch type /realtype eq or {
                sub abs 0.0001 gt {/testError pstack quit} if
            } {
                ne {/testError pstack quit} if
            } ifelse
        } for
    } {
        2 copy ne {/testError pstack quit}
    } ifelse
    pop pop
} bind def

/_isError {
    exch pop
    2 copy ne {/testError pstack quit} if
    pop pop
} bind def

/_debugIsEqual {
    2 copy
    length exch length ne {/testError pstack quit} if
    dup length 1 sub 0 exch 1 exch {
        dup 3 index exch get exch 2 index exch get  % ... a b
        2 copy type /realtype eq exch type /realtype eq or {
            sub abs 0.0001 gt {/testError pstack quit} if
        } {
            ne {/testError pstack quit} if
        } ifelse
    } for
    pop
    pop pop
} bind def

/_doTest {
  /test exch def
  /expect exch def
  /cmd exch def
  /cds countdictstack def
  /testStart /cmd load  % Put useful debugging info on stack
  0 dict begin
  {
      cmd exec
  } stopped {
      $error /errorname get     % Put error details on the stack
      $error /errorname () put  % and clear the error dictionary
      $error /errorinfo get
      $error /errorinfo () put
  } if
  end
  expect /test load exec
  clear                                % Clear the operand stack
  countdictstack cds sub {end} repeat  % Pop any stray dicts from the dictstack
} bind def

/isEqual { //_isEqual //_doTest exec } def
/isError { //_isError //_doTest exec } def
/debugIsEqual { //_debugIsEqual //_doTest exec } def

