%!PS

/_isEqual {
    2 copy
    length exch length ne {/testError pstack quit} if
    dup length 1 sub 0 exch 1 exch {
        dup 3 index exch get exch 2 index exch get ne {/testError pstack quit} if
    } for
    pop pop
} bind def

/_isError {
    exch pop
    2 copy ne {/testError pstack quit} if
    pop pop
} bind def

/_debugIsEqual {
    2 copy
    length exch length ne {/testError pstack quit} if
    dup length 1 sub 0 exch 1 exch {
        dup 3 index exch get exch 2 index exch get ne {/testError pstack quit} if
    } for
    pop
    pop pop
} bind def

/_doTest {
  /test exch def
  /expect exch def
  /cmd exch def
  /testStart /cmd load  % Put useful debugging info on stack
  0 dict begin
  {
      cmd exec
  } stopped {
      $error /errorname get  % Put an error on the stack
      $error /errorinfo get  % Put details on the stack
  } if
  end
  expect /test load exec
  pop pop  % Clear debugging info on stack
} bind def

/isEqual { //_isEqual //_doTest exec } def
/isError { //_isError //_doTest exec } def
/debugIsEqual { //_debugIsEqual //_doTest exec } def

[
    (../../../tests/ps_tests/parseinput.ps)
    (../../../tests/ps_tests/ean13.ps)
    (../../../tests/ps_tests/ean8.ps)
    (../../../tests/ps_tests/upca.ps)
    (../../../tests/ps_tests/upce.ps)
    (../../../tests/ps_tests/qrcode.ps)
] { 1 dict begin run end } forall

(%stdout) (w) file dup (\nPASS\n) writestring dup flushfile
